<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hibara</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-07T13:06:05.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>jhy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/posts/4a17b156.html"/>
    <id>http://example.com/posts/4a17b156.html</id>
    <published>2025-06-24T12:01:22.562Z</published>
    <updated>2023-08-07T13:06:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>zkBridge</title>
    <link href="http://example.com/posts/e15e124.html"/>
    <id>http://example.com/posts/e15e124.html</id>
    <published>2024-09-13T11:44:08.000Z</published>
    <updated>2024-09-18T12:32:27.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="zkBridge-Trustless-Cross-chain-Bridges-Made-Practical"><a href="#zkBridge-Trustless-Cross-chain-Bridges-Made-Practical" class="headerlink" title="zkBridge: Trustless Cross-chain Bridges Made Practical"></a>zkBridge: Trustless Cross-chain Bridges Made Practical</h1><p>当今时间，多种多样的区块链出现在人们的视野。多链世界的核心挑战是如何实现安全的跨链桥接，使不同区块链上的应用可以通过这些桥接进行通信。</p><p>区块链$C_1$和$C_2$之间桥梁的核心功能是向$C_2$上的应用程序证明某个事件发生在$C_1$上，反之亦然。</p><p>问题所在，虽然在实践中已经建立了跨链桥，但现有的解决方案要么性能不佳，要么依赖于中心方。</p><p>桥的运行取决于两个链的共识协议。如果$C_1$运行的是工作证明（Proof-of-Work），具体来说，$C_2$上的智能合约（用$SC_2$表示）将跟踪$C_1$的区块头，根据这些区块头，可以用 Merkle 证明来验证交易的包含（和其他事件）。但是，这种方法会产生巨大的计算和存储开销，因为$SC_2$需要验证所有区块头，并保存一个不断增长的冗长列表。</p><p>作为一种高效的替代方案，许多桥接协议<br>(PolyNetwork、Wormhole、Ronin 等）都采用了基于信任中介（Trust In­ter­me­di­ary）的方法，所使用的技术包括侧链（PolyNetwork），跨链委员会（Ronin），预言机（LayerZero）</p><p>Wormhole：<a href="https://docs.wormhole.com/wormhole/explore-wormhole/security">https://docs.wormhole.com/wormhole/explore-wormhole/security</a></p><p>Poly Network：<a href="https://learnblockchain.cn/article/3300">https://learnblockchain.cn/article/3300</a></p><p>此类方式需要有比较强的信任假设，也即假设跨链桥的结点有至少 2/3 是可信的，委员会中有至少 2/3 是可信的。</p><p>但是这种方式容易遭受到恶意的攻击。</p><p>为了降低对中介的信任依赖，一个比较简单的方式是不让中介传输数据，而是让中介对数据进行签名，之后由接受数据的链对签名进行验证即可</p><p>这个思路有点类似于轻量级客户端验证，只要客户端验证并持续追踪验证状态即可</p><p>举个例子，Cos­mos IBC 是一个用于 Cos­mos 链的跨链协议，这个协议会验证来自其他链的数据的区块首部，从而完成跨链数据的验证，不过此类方式也存在缺点，需要跨链的接收方部署这个 IBC 协议来完成数据验证（比如以太坊没有部署这个东西，就无法支持跨链）</p><p>或者向 NEAR Rain­bow bridge 那样的做法，将其以智能合约的形式部署于以太坊来支持跨链，但是这会导致链上验证的开销非常大</p><p>为了在消除中介的同时提供足够强的安全性，这里可以引入 ZKP 技术，主要思想和很多去中心化的协议类似，将对可信机构的信任转移至对密码学假设的依赖。</p><p>zkBridge 可以实现高效的跨链桥接，而无需信任中央委员会。其主要思想是利用 zk-SNARK，即简洁的非交互式知识证明（论证）</p><p>zk-SNARK能让证明者有效地让$SC_2$相信，在$C_1$上发生了某种状态转换。为此，$SC_2$将跟踪$SC_1$最新提示的摘要$D$。要使$SC_2$与$C_1$中的新区块同步，任何人都可以生成并提交 zk-SNARK，向$SC_2$证明$C_1$的顶端已经从 $D$推进到$D^\prime$。</p><p>好处：</p><p>zk-SNARK 的健全性确保了桥梁的安全性。除了底层区块链的安全性外，我们不需要额外的安全性要求。</p><p>通过专门构建的 zk-SNARK，$C_2$可以验证$C_1$的状态转换，远比在$SC_2$中编码$C_1$的共识逻辑更有效。</p><p>要使用 zk-SNARK 证明给定计算结果的正确性，首先需要将计算表达为算术电路。</p><p>虽然 zk-SNARK 验证速度很快（与电路的大小成对数关系，甚至是常数），但证明生成时间至少是线性的，而且在实践中可能昂贵得令人望而却步。</p><p>此外，现实世界中区块链使用的组件并不容易用算术电路来表示。例如，广泛使用的 EdDSA 数字签名方案在 CPU 上的验证效率很高，但要用算术电路表示却很昂贵，需要 200 多万个门。在跨链桥中，根据链的不同，每个状态转换可能需要验证数百个签名，这使得生成所需的 zk-SNARK 证明的成本过高。</p><p>因此，为了使 zkBridge 实用化，我们必须缩短证明生成时间。</p><p>我们发现跨链桥所使用的电路是数据并行的，因为它们包含一个较小的子电路的多个相同副本。具体来说，用于验证$N$数字签名的电路包含签名验证子电路的$N$个副本。因此，本文提出一种基于Virgo的分布式协议，deVirgo，如果证明生成分布在$M$台机器上，生成时间可减少$M$倍。</p><p>虽然 deVirgo 大大缩短了证明生成时间，但在链上验证 deVirgo 证明（尤其是 zkBridge 中的十亿门电路）对于计算资源极其有限的智能合约来说可能是昂贵的。</p><p>为了压缩证明大小和验证成本，本文使用 Groth 提出的经典 zk-SNARK 递归证明（可能很大）deVirgo 证明的正确性，以下简称 Groth16。Groth16 校验器能输出恒定大小的证明，EVM 区块链上的智能合约可以快速验证这些证明。我们强调，不能使用 Groth16 生成整个 zkBridge 证明，因为 zkBridge 所需的电路对于 Groth16 验证器来说太大了。</p><p>相反，我们使用 Groth16 压缩 deVirgo 证明的方法却能提供两全其美的效果：快速的 deVirgo 并行证明器可生成大部分证明，而生成的证明则被压缩为简洁的 Groth16 证明，可快速验证。</p><p>为了证明zkBridge的实用性，我们在Cosmos和以太坊之间实现了zkBridge的端到端原型，包括deVirgo和递归验证协议，以及交易中继应用。</p><h1 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h1><p>$F$：有限域</p><p>$\lambda$：安全参数</p><p>$f(),h()$：多项式表达式</p><p>$x,y$：单一变量</p><p>$\vec{x},\vec{y}$：变量向量</p><p>$\vec{x}[i],\vec{x}[i:k]=(x<em>i,x</em>{i+1},…,x_k)$</p><p>Merkle Tree:</p><ul><li>$rt\leftarrow MT.Commit(\vec{x})$</li><li>$(\vec{x}[i],\pi_i)\leftarrow MT.Open(\vec{x},i)$</li><li>${1,0}\leftarrow MT.Verify(\pi_i,\vec{x}[i],rt)$</li></ul><p>$blk={blkh;trx_1,…,trx_t}$：区块</p><p>$LOG<em>r^i=[blk_1,…,blk_r]$：账本，$r$是高度，$blk</em>{k\cdot ptr}=blkH_{k-1}$</p><p>一致性：对于诚实的节点$i,j$，一定有$LOG_i^{r_0}$是$LOG_j^{r_1}$的前缀。</p><p>有效性：如果一个诚实节点在某一轮 $r$ 收到了某笔交易$trx$，那么$trx$最终会被包含到所有诚实节点的区块链中。</p><p>$LightCC(LCS<em>{r-1},blkH</em>{r-1},blkH<em>r)\rightarrow {true,false}$：轻客户端的区块验证规则，其中$blkH_r$表示新的区块头，$blkH</em>{r-1}$旧的区块头，$LCS_{r-1}$当前的状态</p><p><strong>零知识证明：</strong>当$\lambda$作为安全参数，$R$是一种$NP$关系，算法$(\mathcal{G,P,V})$对于$R$来说是零知识的，当其满足：</p><ul><li>Completeness：对于$\mathcal{G}(1^\lambda)$产生的参数$pp$，$(x;w)\in \mathcal{R},\pi\leftarrow \mathcal{P}(x,w,pp)$：</li></ul><script type="math/tex; mode=display">Pr[\mathcal{V}(x,\pi,pp)=1]=1</script><ul><li>Knowledge Soundness：对于PPT的证明者$\mathcal{P}^<em>$，存在一个PPT模拟器$\mathcal{E}$和辅助字符串$z$.$pp\leftarrow \mathcal{G}(1^\lambda),\pi^</em> \leftarrow P^<em>(x,z,pp),w,\mathcal{E}^{P^</em>(\cdot)}(x,z,pp)$：</li></ul><script type="math/tex; mode=display">Pr[(x;w)\notin R \and \mathcal{V}(x,\pi^*,pp)=1]\le negl(\lambda)</script><ul><li>Zero knowledge：存在一个PPT模拟器$S$对于PPT算法$\mathcal{V}^*$，$(x,w)\in \mathcal{R},pp\leftarrow \mathcal{G}(1^\lambda)$</li></ul><script type="math/tex; mode=display">View(\mathcal{V}^*(pp,x))\approx \mathcal{S}^{\mathcal{V}^*}(x)</script><p>我们说$(\mathcal{G,P,V})$是简洁的，当$\mathcal{P,V}$之间的总开销（证明大小）以及$\mathcal{V}$的运行时间，是$poly(\lambda,|x|,log|\mathcal{R}|)$的，其中$|R|$是电路的大小</p><h1 id="zkBridge"><a href="#zkBridge" class="headerlink" title="zkBridge"></a>zkBridge</h1><p>注意：zkBridge两个方向的操作是一致的。</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>为了让不同的应用程序都能轻松地与 zkBridge 集成，我们采用了模块化设计，将特定于应用程序的逻辑（如验证智能合约状态）与核心桥接功能（即转发区块头）分离开来。</p><p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202409141639416.png" alt="image-20240914163902252"></p><p>如图显示了zkBridge的架构和工作流程。核心桥接功能由一个<strong>区块头中继网络</strong>（仅在有效性方面受信任）提供，$\mathcal{C}_1$的中继块头提供正确性证明，$\mathcal{C}_2$的<strong>更新器合约</strong>验证和接收证明。</p><p>更新器合约维护最新的区块头列表，并在验证中继节点提交的证明后对其进行适当更新；它公开了一个简单且与应用程序无关的应用程序接口，应用程序智能合约可以从中获取发送方区块链的最新区块头，并在此基础上构建特定于应用程序的逻辑。</p><p>依赖于 zkBridge 的应用程序通常会在$\mathcal{C}_1$和$\mathcal{C}_2$上分别部署一对合约，即发送方合约和接收方合约。我们把它们统称为应用合约或依赖合约。接收者合约可以调用更新器合约来获取$\mathcal{C}_1$的块头，并在此基础上执行特定的应用任务。根据应用的不同，接收方合约可能还需要用户或第三方提供特定应用的证明，如智能合约状态的 Merkle 证明。</p><p>如图展示了跨链代币转移的工作流程。</p><p>假设用户$\mathcal{u}$想要在另一个区块链$\mathcal{C}_2$上的交易所交易她在$\mathcal{C}_1$的资产，即将资金从$\mathcal{C}_1$转移到$\mathcal{C}_2$上。</p><p>一对智能合约$SC<em>{lock}$和$SC</em>{mint}$分别部署在区块链$C_1$和$C_2$上。</p><p>为了转移资金，用户将 $v 代币锁定在$SC<em>{lock}$（图 1 中的步骤 1），然后请求$SC</em>{mint}$发行 $v 代币。</p><p>$SC<em>{mint}$只应在且仅在用户已锁定$C_1$上的代币时才发行新代币。这要求$SC</em>{mint}$从不同的区块链读取$SC_{lock}$的状态（$\mathcal{U}$的余额，在步骤 2 中更新），但它不能直接这样做。</p><p>zkBridge 通过将$C_1$的区块头和证明一起转发给$C_2$来实现这一点（步骤 3 和 4）。</p><p>$SC_{mint}$可以从智能合约前端（更新合约）获取区块头，检查用户$\mathcal{U}$的余额是否确实为 $v（步骤 5 ），然后能铸造 $v 代币（步骤 6 ）。</p><p>除了跨链代币转移，zkBridge 还能实现其他各种应用，如跨链抵押贷款、一般消息传递等。</p><h2 id="detail"><a href="#detail" class="headerlink" title="detail"></a>detail</h2><h3 id="security-and-system-model"><a href="#security-and-system-model" class="headerlink" title="security and system model"></a>security and system model</h3><p>为了建模桥，我们将区块链$\mathcal{C}$建模为区块编号索引的键值存储，表示为$\mathcal{C}[t]:\mathcal{K}\rightarrow \mathcal{V}$其中$t$是区块编号，$\mathcal{K}$和 $\mathcal{V}$分别是键和值空间。</p><p>例如，以太坊中，$\mathcal{V}={0,1}^{256}$（每个地址存储32字节的值），密钥是智能合约标识符$\mathcal{SC}$和每个智能合约存储地址$\mathcal{K}$的连接。对于一个给定的合约$\mathcal{SC}$，我们将存储在地址$\mathcal{K}$区块编号$t$的值记作$\mathcal{SC}[t,\mathcal{K}]$，将$\mathcal{SC}[t,\cdot]$叫做$\mathcal{SC}$在区块编号为$t$的状态</p><p>我们关注于从$\mathcal{SC}_1$到$\mathcal{SC}_2$，记作$\mathcal{BR}[\mathcal{SC}_1\rightarrow \mathcal{SC}_2]$</p><p><strong>Functional and security goals</strong></p><p>我们要求桥$\mathcal{BR}[\mathcal{SC}_1\rightarrow \mathcal{SC}_2]$正确及时地反映$\mathcal{SC}_1$的状态：</p><p>正确性： 对于所有$t,\mathcal{K}$，$\mathcal{SC}_2$接受错误状态$\mathcal{V}\ne \mathcal{SC}_1[t,\mathcal{K}]$的概率可忽略不计。</p><p>有效性： 假设$\mathcal{SC}_2$需要验证$SC_1$在$(t,K)$处的状态，桥最终会提供必要的信息。</p><p><strong>Security assumptions</strong></p><p>为了保证正确性，除了底层区块链的信任假设外，zkBridge 没有引入额外的信任假设。也就是说，我们假设发送方区块链和接收方区块链都是一致的和有效的（第 2 节），并且发送方链有一个轻客户端协议，可以快速验证区块头。对于这两个特性，我们假设中继网络中至少有一个诚实节点，并且所使用的 zk-SNARK 是可靠的。</p><h3 id="construction"><a href="#construction" class="headerlink" title="construction"></a>construction</h3><p>如第 3 节所述，桥接器$\mathcal{BR}[\mathcal{SC}_1\rightarrow \mathcal{SC}_2]$由三个部分组成：区块头中继网络、更新合约和一个或多个应用合约。下面我们将说明每个组件的协议。</p><p><strong>区块头中继网络：</strong></p><p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202409181843063.png" alt="img"></p><p>块标头中继网络中的节点以更新合约的当前状态（$LCS<em>{r-1},blkH</em>{r-1}$）为输入，运行 RelayNextHeader。</p><p>中继节点连接到$C<em>1$中的全节点，并获得继$blkH</em>{r-1}$之后的块头$blkH<em>r$。中继节点生成一个 ZKP $\pi$，显示$blkH_r$的正确性，主要证明$blkH_r$在块$blkH</em>{r-1}$之后被$C_1$的轻客户端接受。</p><p>它将 ($\pi,blkH_r$) 发送给$C_2$上的更新合约。</p><p>为了避免因碰撞而浪费证明时间（注意，当多个中继节点同时发送时，只能接受一个证明），中继节点可以使用标准技术进行协调（例如，以循环方式发送）。</p><p><strong>为了激励区块头中继节点，证明者可以在验证其证明后获得费用奖励。激励机制的设计留待今后研究。</strong></p><p>我们注意到，这种设计依赖于发送者链的轻客户端验证器的安全性。例如，轻客户端验证器必须拒绝最终可能成为孤儿且不属于发件人链的有效块头。</p><p><strong>更新者合约</strong></p><p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202409181900829.png" alt="image-20240918190006734"></p><p>更新器合约维护轻客户端的内部状态，包括 headerDAG 中$C<em>1$的区块头列表。它有两个公开暴露的函数。HeaderUpdate 函数可以可由任何区块头中继节点调用，并提供下一个区块头和一个证明作为输入。如果证明与当前轻客户端状态 $LCS$ 和 $blkH</em>{r-1}$ 一致，合约将对轻客户端进行进一步检查，然后相应地更新状态。由于该函数的调用者必须支付一定费用，因此自然可以防止$DoS$攻击。</p><p>接收合约可调用 GetHeader 函数来获取高度为 $t$ 的区块头。接收方合约可以使用获得的区块头完成特定应用验证，可能需要用户或第三方的帮助。</p><p>zkBridge 采用模块化设计，更新合约与应用程序无关。因此，在$\mathcal{BR}[\mathcal{SC}_1\rightarrow \mathcal{SC}_2]$中，由应用合约$SC_1$和$SC_2$决定桥接的信息是什么。一般来说，证明$SC_1[t,K]=V$的过程非常简单：$SC_2$可以请求获得与地址$K$对应的状态 Trie Tree 的叶子（位于区块编号 𝑡）的 Merkle 证明。接收方合约可以通过调用函数 $GetHeader(t)$，从更新方合约中获取$blkH_t$。然后，它可以根据$blkH_t$中的 Merkle 根验证$SC_1[t,K]=V$</p><p>下面的定理说明了 zkBridge 的安全性。<br>由协议 1 和 2 实现的桥$\mathcal{BR}[\mathcal{SC}_1\rightarrow \mathcal{SC}_2]$同时满足一致性和有效性，假设以下条件成立：</p><ol><li>在区块头中继网络中至少有一个诚实节点；</li><li>发送方链是一致和有效的；</li><li>发送方链有一个定义 2.1 中的轻客户端验证器；以及</li><li>简洁证明系统是健全的。</li></ol><h2 id="Application-cases"><a href="#Application-cases" class="headerlink" title="Application cases"></a>Application cases</h2><p><strong>Transaction inclusion: a building block</strong></p><p>跨链应用的一个常见构件是验证另一个区块链上的交易包含性。</p><p>具体来说，目的是使$C_2$上的接收方合约$SC_2$能够验证给定的交易$trx$已包含在高度为$t$的$C_1$上的区块$B_t$中。为此，接收方合约$SC_2$需要用户或第三方服务为$B_t$中的$trx$提供 Merkle 证明。然后，$SC_2$将调用更新器合约，检索高度为$t$的$C_1$的区块头，然后根据头中包含的 Merkle 根验证所提供的 Merkle 证明。</p><p><strong>消息传递和数据分享</strong></p><p>跨链消息传递是另一种常见的构建模块，可用于跨区块链共享链外数据等。消息传递可以通过在交易中嵌入消息，作为交易包含的简单扩展来实现。具体来说，要将$C_1$的消息$m$传递到$C_2$，用户可以将$m$嵌入事务$trx_m$，将$trx_m$发送到$C_1$，然后执行上述事务包含证明。</p><p><strong>跨链交换资产</strong></p><p>在此应用中，用户可以在发送方区块链$C_1$上注入一定数量的代币$T_A$，并在接收方区块链$C_2$上获得相同数量的代币$T_A$（如果符合条件，用于原生资产转移）或一定数量的价值大致相同的代币$T_B$（用于原生资产交换）。</p><p>首先，开发者会在$C<em>1$上部署一个锁合约$SC</em>{lock}$，在$SC$上部署一个合约$SC_{mint}$。如果用户想将$n_A$的代币$T_A$换成等值的代币$T_B$。</p><p>她将首先发送一个交易$trx<em>{lock}$，将$n_A$的代币$T_A$转移到$SC</em>{lock}$，同时发送一个地址$addr<em>{C_2}$，以便在$C_2$上接收代币$T_B$。在区块$B$中确认$trx</em>{lock}$后，用户将向$SC<em>{mint}$发送交易$trx</em>{mint}$，其中包括足够的信息来验证是否包含$trx<em>{lock}$。根据$trx</em>{mint}$中的信息，$SC<em>{mint}$将验证$C_1$上是否包含了$trx</em>{lock}$，并将相应的$T<em>B$代币转移到$trx</em>{lock}$中指定的地址$addr_{C_2}$上。</p><p>最后，$SC<em>{mint}$将标记$trx</em>{lock}$为铸币，以完成转账。</p><p><strong>NFT的互操作</strong></p><p>在不可兑换代币（NFT）的互操作应用中，用户总是在发送方区块链上锁定/标记 NFT，并在接收方区块链上获得铸币的 NFT 或 NFT 衍生物。通过设计 NFT 衍生物，跨链协议可以在两个区块链系统上分离 NFT 的所有权和效用，从而支持在发送方区块链上锁定 NFT 的所有权，在接收方区块链上获取效用。</p><h2 id="efficient-proof-systems-for-zkBridge"><a href="#efficient-proof-systems-for-zkBridge" class="headerlink" title="efficient proof systems for zkBridge"></a>efficient proof systems for zkBridge</h2><p>当发送链和接收链使用不同的加密实现时，开销的一个主要来源是不同椭圆曲线之间的字段转换，这在实践中很常见。</p><p>为了使 zkBridge 实用化，我们提出了两个想法。</p><p>利用 deVirgo 缩短证明时间。我们发现，用于验证多个签名的 ZKP 电路由一个子电路的多个副本组成。我们的第一个想法是利用这一特殊结构，在多个服务器之间分布式生成证明。我们提出了一种名为 deVirgo 的新型分布式 ZKP 协议。</p><p>通过递归验证降低链上成本。虽然在普通 CPU 上验证 deVirgo 证明非常高效，但链上验证的成本仍然很高。为了进一步降低链上验证成本（计算和存储），我们使用递归验证：证明者递归地证明正确的证明。<br>证明者使用对智能合约友好的零知识协议递归证明一个（可能很大的）Virgo 证明的正确性，从而得到一个小的、验证者效率高的证明。</p><h1 id="Distributed-Proof-Generation"><a href="#Distributed-Proof-Generation" class="headerlink" title="Distributed Proof Generation"></a>Distributed Proof Generation</h1><p>快速验证时间的机会来自于验证$N$签名的电路由相同子电路的$N$副本组成这一事实。这种电路被称为数据并行电路</p><p>我们选择 Virgo 作为底层 ZKP 协议有两个原因： </p><ul><li><p>Virgo 不需要可信设置，而且是可信的后量子安全协议。</p></li><li><p>Virgo 是最快的协议之一，验证时间简洁，证明规模简洁，可解决大规模问题。.</p></li></ul><p>我们为数据并行算术电路提出了一种新的分布式 Virgo 版本，它能在证明大小不增加任何开销的情况下实现最佳可扩展性。具体地说，在使用$N$台并行机器、具有$N$个副本的数据并行电路上，我们的 deVirgo 协议比原始 Virgo 快$N$倍，而证明大小保持不变。我们的方案具有独立的意义，可以用于其他基于 Virgo 的系统，以提高效率。</p><p>假设证明者总共有$N$台机器，标记范围从$P<em>0$到$P</em>{N-1}$。</p><p>假设$P_0$是主节点，其他机器是普通节点。假设$v$是验证器。</p><p>给定一个由$N$个相同结构组成的数据并行算术电路，分布式 Virgo 的简单算法是将每个子电路分配给一个单独的节点。然后，每个节点分别运行 Virgo 生成证明。𝑁 证明的合并即为最终证明。</p><p>遗憾的是，这种天真算法的证明大小与子电路的数量成线性关系，这对于具有许多子副本的数据并行电路来说，可能大得令人望而却步。</p><p>为了解决这个问题，我们的方法通过在分布式机器之间聚合信息和证明，消除了证明大小中的$N$附加因子。具体来说，Virgo 的原始协议由两个主要构件组成。一个是 GKR 协议 [53]，它由深度为$d$的电路的sumcheck 协议组成。另一个是多项式承诺（PC）方案。我们分别为求和检查和多项式承诺 (PC) 设计了分布式方案。</p><p>在我们的分布式 sumcheck 协议中，主节点$P_0$会汇总来自所有机器的信息，然后在每一轮将汇总后的信息发送给 $v$，而不是直接将来自所有机器的信息发送给 𝒱。我们的分布式 sumcheck 协议与原始 sumcheck 协议的证明大小完全相同，因此比原始分布式协议节省了$N$倍。此外，在我们的分布式 PC 协议中，我们优化了承诺阶段，让$P_0$将$N$个承诺聚合成一个，而不是直接将$N$个承诺发送给$v$。在开局阶段，证明也可以聚合在一起，这样就能以多项式大小的对数因子来改善证明的大小。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;



&lt;h1 id=&quot;zkBridge-Trustless-Cross-chain-Bridges-Made-Practical&quot;&gt;&lt;a href=&quot;#zkBridge-Trustless-</summary>
      
    
    
    
    <category term="论文阅读" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="cross-chain" scheme="http://example.com/tags/cross-chain/"/>
    
  </entry>
  
  <entry>
    <title>DaspTop10</title>
    <link href="http://example.com/posts/b537f0e7.html"/>
    <id>http://example.com/posts/b537f0e7.html</id>
    <published>2024-09-11T13:16:33.000Z</published>
    <updated>2024-10-21T01:13:35.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="DASP-TOP-10"><a href="#DASP-TOP-10" class="headerlink" title="DASP TOP 10"></a>DASP TOP 10</h1><p><a href="https://www.dasp.co/">https://www.dasp.co/</a></p><p>This project is an initiative of <a href="https://www.nccgroup.trust/">NCC Group</a>. It is an open and collaborative project to join efforts in discovering smart contract vulnerabilities within the security community. To get involved, <a href="https://github.com/CryptoServices/dasp">join the github page</a>.</p><h1 id="Reentrancy"><a href="#Reentrancy" class="headerlink" title="Reentrancy"></a>Reentrancy</h1><p>重入漏洞</p><p>也称为或与竞空、递归调用漏洞、调用未知相关</p><p>这个漏洞在审查中被许多不同的人漏掉了很多次：审查人员倾向于一次审查一个函数，并假定对安全子程序的调用会按预期安全运行。 -Phil Daian</p><p>重入攻击（Reentrancy attack）可能是最著名的以太坊漏洞，它首次被发现时让所有人都大吃一惊。它是在一次价值数百万美元的抢劫中首次被发现的，这次抢劫导致了以太坊的硬分叉。</p><p>当外部合约调用被允许在初始执行完成之前对调用合约进行新的调用时，就会出现重定向。对于函数来说，这意味着在执行过程中，由于调用了不受信任的合约或使用了带有外部地址的低级函数，合约状态可能会发生变化。</p><p><strong>损失</strong>：估计为 350 万个以太坊（当时约合 5000 万美元）</p><p><strong>Timeline of discovery</strong>:</p><div class="table-container"><table><thead><tr><th style="text-align:right">Date</th><th style="text-align:center">Event</th></tr></thead><tbody><tr><td style="text-align:right">Jun 5, 2016</td><td style="text-align:center"><a href="https://blog.ethereum.org/2016/06/10/smart-contract-security/">Christian Reitwiessner discovers an antipattern in solidity</a></td></tr><tr><td style="text-align:right">Jun 9, 2016</td><td style="text-align:center"><a href="http://vessenes.com/more-ethereum-attacks-race-to-empty-is-the-real-deal/">More Ethereum Attacks: Race-To-Empty is the Real Deal (vessenes.com)</a></td></tr><tr><td style="text-align:right">Jun 12, 2016</td><td style="text-align:center"><a href="https://blog.slock.it/no-dao-funds-at-risk-following-the-ethereum-smart-contract-recursive-call-bug-discovery-29f482d348b">No DAO funds at risk following the Ethereum smart contract ‘recursive call’ bug discovery (blog.slock.it)</a></td></tr><tr><td style="text-align:right">Jun 17, 2016</td><td style="text-align:center"><a href="https://www.reddit.com/r/ethereum/comments/4oi2ta/i_think_thedao_is_getting_drained_right_now/">I think TheDAO is getting drained right now (reddit.com)</a></td></tr><tr><td style="text-align:right">Aug 24, 2016</td><td style="text-align:center"><a href="https://blog.slock.it/the-history-of-the-dao-and-lessons-learned-d06740f8cfa5">The History of the DAO and Lessons Learned (blog.slock.it)</a></td></tr></tbody></table></div><p>著名事件</p><ul><li><a href="https://en.wikipedia.org/wiki/The_DAO_(organization">The DAO</a>)</li></ul><p><strong>举例说明：</strong></p><p>智能合约会跟踪多个外部地址的余额，并允许用户使用其公共 withdraw() 函数取回资金。<br>恶意智能合约使用 withdraw() 函数取回全部余额。<br>在更新恶意合约的余额之前，受害者合约会执行 call.value(amount)() 低级函数将以太币发送给恶意合约。<br>恶意合约有一个可支付的 fallback() 函数，用于接收资金，然后再调用受害者合约的 withdraw() 函数。<br>第二次执行会触发资金转移：请记住，恶意合约的余额仍未从第一次提款中更新。因此，恶意合约第二次成功提取了全部余额。</p><p><strong>代码示例：</strong></p><p>下面的函数包含一个容易受到重入攻击的函数。当低级 call() 函数向 msg.sender 地址发送以太坊时，该函数就会受到攻击；如果该地址是智能合约，支付就会使用剩余的交易气体触发回退函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function withdraw(uint _amount) &#123;</span><br><span class="line">require(balances[msg.sender] &gt;= _amount);</span><br><span class="line">msg.sender.call.value(_amount)();</span><br><span class="line">balances[msg.sender] -= _amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Access-Control"><a href="#Access-Control" class="headerlink" title="Access Control"></a>Access Control</h1><p>通过调用 initWallet 函数，可以将奇偶校验钱包库合约转化为普通的多重签名钱包，并成为其所有者</p><p>访问控制问题在所有程序中都很常见，不仅仅是智能合约。事实上，它在 OWASP Top 10 中排名第 5。人们通常通过合约的公共或外部函数访问合约的功能。虽然不安全的可见性设置让攻击者可以直接访问合约的私有值或逻辑，但访问控制绕过有时更为隐蔽。当合约使用已废弃的 tx.origin 来验证调用者、使用冗长的 require 来处理大型授权逻辑，以及在代理库或代理合约中肆意使用 delegatecall 时，就会出现这些漏洞。</p><p><strong>例子：</strong></p><p>智能合约指定初始化合约的地址为合约所有者。这是授予特殊权限（如提取合约资金的能力）的常见模式。<br>不幸的是，初始化函数可以被任何人调用—甚至在它已经被调用之后。这就允许任何人成为合约的所有者并提取其资金。</p><p><strong>代码例子：</strong></p><p>在下面的示例中，合约的初始化函数将函数的调用者设置为其所有者。然而，该逻辑与合约的构造函数是分离的，它不会跟踪它已被调用的事实。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function initContract() public &#123;</span><br><span class="line"><span class="code">owner = msg.sender;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure><p>在 Parity 多重签名钱包中，这个初始化函数脱离了钱包本身，而是定义在一个 “库 ”合约中。用户需要通过委托调用库函数来初始化自己的钱包。不幸的是，在我们的例子中，该函数并没有检查钱包是否已经初始化。更糟糕的是，由于库是一个智能合约，任何人都可以初始化库本身并调用销毁它。</p><h1 id="Arithmetic-Issues"><a href="#Arithmetic-Issues" class="headerlink" title="Arithmetic Issues"></a>Arithmetic Issues</h1><p>溢出条件会产生不正确的结果，尤其是在没有预料到这种可能性的情况下，会危及程序的可靠性和安全性。</p><p>整数溢出和下溢并不是一类新的漏洞，但它们在智能合约中尤其危险，因为智能合约中普遍存在无符号整数，而大多数开发人员习惯于使用简单的 int 类型（通常只是有符号整数）。如果出现溢出，许多看似无害的代码路径就会成为盗窃或拒绝服务的载体。</p><p><strong>例子：</strong></p><p>智能合约的 withdraw() 函数允许您取回捐赠给合约的以太币，只要您的余额在操作后仍为正数。<br>攻击者试图提取超过其当前余额的以太币。<br>withdraw() 函数的检查结果总是正数，允许攻击者提取超出允许范围的金额。由此产生的余额不足溢出，变得比应有余额大一个数量级。</p><p><strong>代码例子</strong></p><p>最直接的例子就是一个不检查整数下溢的函数，允许你提取无限量的代币：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function withdraw(uint _amount) &#123;</span><br><span class="line">require(balances[msg.sender] - _amount &gt; 0);</span><br><span class="line">msg.sender.transfer(_amount);</span><br><span class="line">balances[msg.sender] -= _amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个例子（在 “狡猾的 Solidity 编码竞赛 ”中发现的）是由于数组的长度用无符号整数表示而产生的偏差：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function popArrayOfThings() &#123;</span><br><span class="line">require(arrayOfThings.length &gt;= 0);</span><br><span class="line">arrayOfThings.length--; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三个例子是第一个例子的变种，即对两个无符号整数进行运算的结果是一个无符号整数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function votes(uint postId, uint upvote, uint downvotes) &#123;</span><br><span class="line">if (upvote - downvote &lt; 0) &#123;</span><br><span class="line">deletePost(postId)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四个示例使用了即将淘汰的 var 关键字。因为 var 将改变自身为包含赋值所需的最小类型，所以它将变成 uint8 来保存值 0。如果循环要遍历 255 次以上，它将永远不会达到这个数字，并会在执行耗尽时停止：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; somethingLarge; i ++) &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Unchecked-Return-Values-For-Low-Level-Calls"><a href="#Unchecked-Return-Values-For-Low-Level-Calls" class="headerlink" title="Unchecked Return Values For Low Level Calls"></a>Unchecked Return Values For Low Level Calls</h1><p>应尽可能避免使用低级 “调用”。如果返回值处理不当，可能会导致意想不到的行为。</p><p>底层函数 call()、callcode()、delegatecall() 和 send() 是 Solidity 的深层特性之一。它们在处理错误时的行为与其他 Solidity 函数截然不同，因为它们不会传播（或冒泡），也不会导致当前执行的完全回退。相反，它们会返回一个设置为 false 的布尔值，代码将继续运行。这可能会让开发人员大吃一惊，而且如果不检查此类低级调用的返回值，可能会导致失败打开和其他不必要的结果。请记住，发送可能会失败！</p><p><strong>代码例子</strong></p><p>下面的代码就是一个例子，说明如果忘记检查 send() 的返回值可能会出现什么问题。如果调用 send() 函数向一个不接受以太币的智能合约发送以太币（例如，因为该合约没有可支付的回退函数），那么 EVM 就会将其返回值替换为 false。由于在我们的示例中没有检查返回值，因此函数对合约状态的更改将不会被还原，etherLeft 变量最终将跟踪一个不正确的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function withdraw(uint256 _amount) public &#123;</span><br><span class="line">require(balances[msg.sender] &gt;= _amount);</span><br><span class="line">balances[msg.sender] -= _amount;</span><br><span class="line">etherLeft -= _amount;</span><br><span class="line">msg.sender.send(_amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Denial-of-Service"><a href="#Denial-of-Service" class="headerlink" title="Denial of Service"></a>Denial of Service</h1><p>在以太坊的世界里，拒绝服务是致命的：其他类型的应用程序最终可以恢复，而智能合约却可能因为一次这样的攻击而永远离线。导致拒绝服务的方式有很多，包括作为交易接收方时的恶意行为、人为增加计算函数所需的气体、滥用访问控制访问智能合约的私有组件、利用混淆和疏忽等。这类攻击包括许多不同的变种，在未来几年可能会有很大的发展。</p><p><strong>例子：</strong></p><ul><li>拍卖合约允许用户竞拍不同的资产。</li><li>要出价，用户必须调用 bid(uint object) 函数，并输入所需的以太币金额。拍卖合约会将以太币存入托管账户，直到对象的所有者接受竞价或初始竞价者取消竞价为止。这就意味着拍卖合约的余额中必须包含所有未竞价的以太币。</li><li>拍卖合约还包含一个 withdraw(uint amount) 函数，允许管理员从合约中提取资金。由于该函数会将金额发送到一个硬编码地址，因此开发者决定公开该函数。</li><li>攻击者看到了潜在的攻击机会，于是调用了该函数，将合约的所有资金都转给了管理员。这就破坏了托管承诺，并阻止了所有待定投标。</li><li>虽然管理员可能会将托管资金返还给合约，但攻击者只需再次提取资金就能继续攻击。</li></ul><p><strong>代码例子：</strong></p><p>在下面的例子中（灵感来自《以太之王》），如果公开贿赂前任总统，游戏合约的一个功能就可以让你成为总统。不幸的是，如果上一任总统是一个智能合约，并在付款时导致还原，那么权力转移就会失败，恶意智能合约将永远担任总统。听起来像是独裁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function becomePresident() payable &#123;</span><br><span class="line">    require(msg.value &gt;= price); // must pay the price to become president</span><br><span class="line">    president.transfer(price);   // we pay the previous president</span><br><span class="line">    president = msg.sender;      // we crown the new president</span><br><span class="line">    price = price * 2;           // we double the price to become president</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第二个例子中，调用者可以决定下一次函数调用将奖励给谁。由于 for 循环中的指令很昂贵，攻击者可以引入一个大到无法迭代的数字（由于以太坊中的气体块限制），这将有效阻止函数的运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function selectNextWinners(uint256 _largestWinner) &#123;</span><br><span class="line">for(uint256 i = 0; i &lt; largestWinner, i++) &#123;</span><br><span class="line">// heavy code</span><br><span class="line">&#125;</span><br><span class="line">largestWinner = _largestWinner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Bad-Randomness"><a href="#Bad-Randomness" class="headerlink" title="Bad Randomness"></a>Bad Randomness</h1><p>该合约对区块.编号年龄的验证不足，导致 400 ETH 被一名未知玩家抢走，该玩家在等待了 256 个区块后才揭晓了可预测的中奖号码。</p><p>随机性在以太坊中很难实现。虽然 Solidity 提供的函数和变量可以访问明显难以预测的值，但它们通常要么比看上去更公开，要么受到矿工的影响。由于这些随机性来源在一定程度上是可预测的，恶意用户一般可以复制它，并依靠其不可预测性攻击函数。</p><p><strong>例子：</strong></p><ul><li>智能合约使用区块号作为游戏的随机性来源。</li><li>攻击者会创建一个恶意合约，检查当前区块编号是否是赢家。如果是，它就会调用第一个智能合约来获胜；由于调用是同一交易的一部分，因此两个合约上的区块链号码将保持不变。</li><li>攻击者只需调用她的恶意合约，直到它获胜为止。</li></ul><p><strong>代码例子：</strong></p><p>在第一个例子中，私人种子与迭代次数和 keccak256 哈希函数结合使用，以确定调用者是否获胜。尽管种子是私有的，但它一定是在某个时间点通过交易设置的，因此在区块链上是可见的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint256 private seed;</span><br><span class="line"></span><br><span class="line">function play() public payable &#123;</span><br><span class="line">require(msg.value &gt;= 1 ether);</span><br><span class="line">iteration++;</span><br><span class="line">uint randomNumber = uint(keccak256(seed + iteration));</span><br><span class="line">if (randomNumber % 2 == 0) &#123;</span><br><span class="line">msg.sender.transfer(this.balance);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第二个示例中，block.blockhash 被用来生成一个随机数。如果 blockNumber 被设置为当前的 block.number，那么这个哈希值就是未知的（原因显而易见），因此会被设置为 0。如果 blockNumber 被设置为过去 256 个以上的区块，那么它将始终为 0。最后，如果它被设置为一个不算太旧的前一个区块编号，另一个智能合约就可以访问相同的编号，并调用游戏合约作为同一交易的一部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function play() public payable &#123;</span><br><span class="line">require(msg.value &gt;= 1 ether);</span><br><span class="line">if (block.blockhash(blockNumber) % 2 == 0) &#123;</span><br><span class="line">msg.sender.transfer(this.balance);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Front-Running"><a href="#Front-Running" class="headerlink" title="Front-Running"></a>Front-Running</h1><p>事实证明，只需大约 150 行 Python 代码，就能获得一个有效的前端运行算法。</p><p>由于矿工代表外部拥有的地址（EOA）运行代码总能通过气体费获得奖励，因此用户可以指定更高的费用，让自己的交易更快被挖掘出来。由于以太坊区块链是公开的，因此每个人都可以看到其他人的待处理交易内容。这就意味着，如果某个用户透露了谜题的答案或其他有价值的秘密，恶意用户就可以窃取答案，并以更高的费用复制他们的交易，抢占原始答案的先机。如果智能合约的开发者稍有不慎，这种情况就会导致实际的破坏性前置攻击。</p><p><strong>例子：</strong></p><ul><li>智能合约发布一个 RSA 数字（N = prime1 x prime2）。</li><li>调用其带有正确质数 1 和质数 2 的 submitSolution() 公共函数，就能获得奖励。</li><li>爱丽丝成功计算出 RSA 数字并提交了解决方案。</li><li>网络上有人看到 Alice 的交易（包含解决方案）正在等待挖矿，于是以更高的天然气价格提交了该交易。</li><li>由于支付的费用较高，第二笔交易首先被矿工选中。攻击者赢得了奖金。</li></ul><h1 id="Time-manipulation"><a href="#Time-manipulation" class="headerlink" title="Time manipulation"></a>Time manipulation</h1><p>如果矿工持有合约的股份，他就可以通过为正在开采的区块选择合适的时间戳来获得优势。</p><p>从锁定代币销售到在游戏的特定时间解锁资金，合约有时需要依赖当前时间。在 Solidity 中，这通常是通过 block.timestamp 或其别名来实现的。但这个值从何而来？来自矿工！由于交易的矿工在报告挖矿发生的时间上有一定的回旋余地，因此好的智能合约会避免强烈依赖所公布的时间。请注意，block.timestamp 有时也会被（误）用于生成随机数，这在 #6 中讨论过。随机性差。</p><p><strong>例子：</strong></p><ul><li>一个游戏在今天午夜向第一个玩家支付奖金。</li><li>一个恶意矿工试图赢得游戏，并将时间戳设置为午夜。</li><li>在午夜前一点，矿工最终挖出了区块。真实的当前时间与午夜（当前设置的区块时间戳）“足够接近”，网络上的其他节点决定接受该区块。</li></ul><p><strong>代码例子：</strong></p><p>以下函数只接受特定日期之后的调用。由于矿工可以影响其区块的时间戳（在一定程度上），他们可以尝试挖掘一个包含其交易的区块，并将区块时间戳设置在未来。如果时间足够接近，就会被网络接受，在其他玩家试图赢得游戏之前，这笔交易就会给矿工以太币：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function play() public &#123;</span><br><span class="line">require(now &gt; 1521763200 &amp;&amp; neverPlayed == true);</span><br><span class="line">neverPlayed = false;</span><br><span class="line">msg.sender.transfer(1500 ether);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Short-Address-Attack"><a href="#Short-Address-Attack" class="headerlink" title="Short Address Attack"></a>Short Address Attack</h1><p>为令牌传输准备数据的服务部门假定用户将输入 20 字节长的地址，但实际上并没有检查地址的长度。</p><p>短地址攻击是 EVM 本身接受错误填充参数的副作用。攻击者可以利用这一点，使用特制的地址使编码不良的客户端在将参数纳入事务之前对参数进行错误编码。这是 EVM 的问题还是客户端的问题？是否应该在智能合约中解决？虽然每个人都有不同的看法，但事实是，大量以太币可能会受到这个问题的直接影响。虽然这个漏洞尚未被广泛利用，但它很好地展示了客户端与以太坊区块链之间的交互所产生的问题。还存在其他链外问题：其中一个重要问题是以太坊生态系统对特定 Javascript 前端、浏览器插件和公共节点的深度信任。Coindash ICO 遭黑客攻击时使用了一个臭名昭著的链外漏洞，该漏洞修改了该公司网页上的以太坊地址，诱骗参与者向攻击者的地址发送以太坊。</p><p><strong>例子：</strong></p><ul><li>一个交易所应用程序接口（API）有一个交易函数，它接收一个收件人地址和一个金额。</li><li>然后，API 与智能合约 transfer(address _to, uint256 _amount)函数交互，并填充参数：在地址（预期长度为 20 字节）前加上 12 个 0 字节，使其长度达到 32 字节。</li><li>鲍勃（0x3bdde1e9fbaef2579dd63e2abbf0be445ab93f00）要求爱丽丝给他转 20 个代币。他恶意地将自己的地址截短，去掉了尾部的 0。</li><li>Alice 使用交换 API 获取了 Bob 较短的 19 字节地址（0x3bdde1e9fbaef2579dd63e2abbf0be445ab93f）。</li><li>API 在地址中填充了 12 个零字节，使地址从 32 字节变为 31 字节。这实际上是从下面的 _amount 参数中窃取了一个字节。</li><li>最终，执行智能合约代码的 EVM 会指出数据未正确填充，并在 _amount 参数末尾添加丢失的字节。这样，转移的代币数量实际上比想象的多 256 倍。</li></ul><h1 id="Unknown-Unknowns"><a href="#Unknown-Unknowns" class="headerlink" title="Unknown Unknowns"></a>Unknown Unknowns</h1><p>我们认为，更多的安全审计或更多的测试不会有什么影响。主要问题是审查人员不知道应该注意什么。</p><p>以太坊仍处于起步阶段。用于开发智能合约的主要语言 Solidity 还未达到稳定版本，生态系统的工具仍处于试验阶段。一些最具破坏性的智能合约漏洞让所有人都大吃一惊，没有理由相信不会再出现同样出人意料或同样具有破坏性的漏洞。只要投资者决定将大量资金投入到复杂但未经严格审核的代码上，我们就会不断看到新的发现，从而导致可怕的后果。对智能合约进行正式验证的方法尚未成熟，但它们似乎大有希望摆脱目前摇摇欲坠的现状。随着新的漏洞不断被发现，开发人员需要保持警惕，并开发新的工具，在坏人发现之前找到它们。在智能合约开发达到稳定和成熟的状态之前，这十大漏洞可能会迅速演变。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;



&lt;h1 id=&quot;DASP-TOP-10&quot;&gt;&lt;a href=&quot;#DASP-TOP-10&quot; class=&quot;headerlink&quot; title=&quot;DASP TOP 10&quot;&gt;&lt;/a&gt;DASP </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ERC20笔记</title>
    <link href="http://example.com/posts/294d1009.html"/>
    <id>http://example.com/posts/294d1009.html</id>
    <published>2024-09-10T03:02:49.000Z</published>
    <updated>2024-09-11T13:21:17.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="ERC-20"><a href="#ERC-20" class="headerlink" title="ERC-20"></a>ERC-20</h1><p>ERC20是以太坊上的一种代币，它定义了一组接口（方法和事件），使得代币可以在不同的应用程序，钱包和交易所之间进行互操作。</p><p><strong>原生币和代币</strong></p><p>原生币（ETH）是以太坊区块链的原生加密货币。它直接由区块链协议生成和管理。主要用于支付网络上的交易费用（Gas）以及奖励矿工（现在是验证者）。原生币的交易是直接在区块链上进行的，不需要任何智能合约。以太币的交易地址是由以太坊协议生成的。</p><p>代币（例如ERC20）是通过智能合约创建和管理的加密货币。它们不是区块链的原生币，而是构建在区块链之上的。可以代表各种资产或功能，如稳定币、权益证明、治理代币等。ERC20 代币遵循以太坊改进提案 20（EIP-20）的标准，实现了一组基本的接口和功能，使其能够在去中心化应用（DApps）之间互操作。ERC20 代币的合约地址是由智能合约生成的。</p><h1 id="ERC-20标准"><a href="#ERC-20标准" class="headerlink" title="ERC-20标准"></a>ERC-20标准</h1><p>标准规定：6个函数，2个事件，3个变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract ERC20Interface &#123;</span><br><span class="line">  function totalSupply() public view returns (uint256);</span><br><span class="line">  function balanceOf(address _owner) public view returns (uint256 balance);</span><br><span class="line">  function transfer(address _to, uint256 _value) public returns (bool success);</span><br><span class="line">  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);</span><br><span class="line">  function approve(address _spender, uint256 _value) public returns (bool success);</span><br><span class="line">  function allowance(address _owner, address _spender) public view returns (uint256 remaining);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  event Transfer(address indexed from, address indexed to, uint tokens);  </span><br><span class="line">  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);</span><br><span class="line"></span><br><span class="line">    string public constant name = &quot;&quot;;</span><br><span class="line">    string public constant symbol = &quot;&quot;;</span><br><span class="line">    uint8 public constant decimals = ;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">totalSupply()</span><br></pre></td></tr></table></figure><p>返回代币的总量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">balanceOf()</span><br></pre></td></tr></table></figure><p>查询某个账户的代币余额</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transfer()</span><br></pre></td></tr></table></figure><p>从当前的自己账户，实现代币的交易</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transferFrom()</span><br></pre></td></tr></table></figure><p>实现用户之间的代币交易（非自己账户）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">approve()</span><br></pre></td></tr></table></figure><p>设置允许某个账户spender从此地址可使用的代币数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allowance()</span><br></pre></td></tr></table></figure><p>查询某个账户可转账金额，用于控制代币的交易</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event Transfer(address indexed from, address indexed to, uint tokens)</span><br></pre></td></tr></table></figure><p>当代币被交易时会触发此函数</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event Approval(address indexed tokenOwner, address indexed spender, uint tokens)</span><br></pre></td></tr></table></figure><p>当成功调用approve函数时会触发此函数</p><p><strong>name</strong></p><p>代币名称</p><p><strong>symbol</strong></p><p>代币简称</p><p><strong>decimals</strong></p><p>返回token使用的小数点后几位。比如如果设置为3，就是支持0.001表示。一般为18位。</p><h1 id="变量及函数定义"><a href="#变量及函数定义" class="headerlink" title="变量及函数定义"></a><strong>变量及函数定义</strong></h1><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>一般会定义几个映射变量</p><p><strong>mapping (address =&gt; uint256) public balances</strong></p><p>保存着每个地址对应的余额。</p><p><strong>mapping (address =&gt; mapping (address =&gt; uint256)) public allowed</strong></p><p>两层映射。保存着某个地址A允许另一个地址B可操作的金额。最外层映射为某个地址A，<a href="https://zhida.zhihu.com/search?q=内层映射&amp;zhida_source=entity&amp;is_preview=1">内层映射</a>为另一个地址B，值为可操作（发起交易）金额总量。</p><h2 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a><strong>函数实现</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function balanceOf(address tokenOwner) public constant returns (uint balance) &#123;</span><br><span class="line">       return balances[tokenOwner];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从映射变量balances中取出某个地址的余额。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address to, uint tokens) public returns (bool success) &#123;</span><br><span class="line">    balances[msg.sender] = balances[msg.sender].sub(tokens);</span><br><span class="line">    balances[to] = balances[to].add(tokens);</span><br><span class="line">    Transfer(msg.sender, to, tokens);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前账户转账操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function transferFrom(address from, address to, uint tokens) public returns (bool success)&#123;</span><br><span class="line">        balances[from] = balances[from].sub(tokens);</span><br><span class="line">        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);</span><br><span class="line">        balances[to] = balances[to].add(tokens);</span><br><span class="line">        Transfer(from, to, tokens);</span><br><span class="line">        return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>用户之间转账操作，由from地址发起转账交易。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function approve(address spender, uint tokens) public returns (bool success) &#123;</span><br><span class="line">        allowed[msg.sender][spender] = tokens;</span><br><span class="line">        Approval(msg.sender, spender, tokens);</span><br><span class="line">        return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>设置某账户spender可操控msg.sender的代币数</p><h1 id="ERC20高级功能"><a href="#ERC20高级功能" class="headerlink" title="ERC20高级功能"></a>ERC20高级功能</h1><p>高级功能：代币管理，代币增发，空投代币，代币冻结，销毁代币，代币兑换</p><h2 id="代币管理"><a href="#代币管理" class="headerlink" title="代币管理"></a>代币管理</h2><p>有时代币需要有一个管理者功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract Owned &#123;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferOwnership(address newOwner) onlyOwner public &#123;</span><br><span class="line">        owner = newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是 owner 调用这个函数，则函数会被执行，否则会抛出异常。</p><h2 id="代币增发"><a href="#代币增发" class="headerlink" title="代币增发"></a>代币增发</h2><p>代币增发可使代币总供应量增加，可以指定某个账户的代币增加，同时总供应量也随之增加。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function mintToken(address target, uint256 mintedAmount) onlyOwner public &#123;</span><br><span class="line">       balances[target] += mintedAmount;</span><br><span class="line">       _totalSupply += mintedAmount;</span><br><span class="line">       emit Transfer(address(0), address(this), mintedAmount);</span><br><span class="line">       emit Transfer(address(this), target, mintedAmount);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="代币销毁"><a href="#代币销毁" class="headerlink" title="代币销毁"></a>代币销毁</h2><p>管理者代币销毁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function burn(uint256 _value) onlyOwner public returns (bool success) &#123;</span><br><span class="line">       require(balances[owner] &gt;= _value);</span><br><span class="line">       balances[owner] -= _value;</span><br><span class="line">       _totalSupply -= _value;</span><br><span class="line">       emit Burn(owner, _value);</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>用户代币销毁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success) &#123;</span><br><span class="line">        require(balances[_from] &gt;= _value);</span><br><span class="line">        require(_value &lt;= allowed[_from][owner]);</span><br><span class="line">        balances[_from] -= _value;</span><br><span class="line">        allowed[_from][owner] -= _value;</span><br><span class="line">        _totalSupply -= _value;</span><br><span class="line">        emit Burn(_from, _value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;ERC-20&quot;&gt;&lt;a href=&quot;#ERC-20&quot; class=&quot;headerlink&quot; title=&quot;ERC-20&quot;&gt;&lt;/a&gt;ERC-20&lt;/h1&gt;&lt;p&gt;ERC20是以太</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>zkp2</title>
    <link href="http://example.com/posts/86ac9353.html"/>
    <id>http://example.com/posts/86ac9353.html</id>
    <published>2024-07-29T09:27:06.000Z</published>
    <updated>2024-07-31T09:46:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ZKP2-ZK-Whiteboard"><a href="#ZKP2-ZK-Whiteboard" class="headerlink" title="ZKP2-ZK Whiteboard"></a>ZKP2-ZK Whiteboard</h1><h1 id="What-is-a-SANRK"><a href="#What-is-a-SANRK" class="headerlink" title="What is a SANRK"></a>What is a SANRK</h1><p><strong>SNARK</strong>: a succinct proof that a certain statrment is true</p><p>many blockchain applications:</p><p><strong>Private Tx on a public blockchain</strong>:</p><ul><li>Tornadao cash, Zcash. IronFish</li><li>Private Dapps: Aleo</li></ul><p><strong>Compliance</strong>:</p><ul><li>private proofs of solvency and compliance</li><li>Zero-knowledge taxes</li></ul><p><strong>Scalability</strong>:</p><p>Rollup systems with validity proofs</p><h1 id="Cryptographic-Background"><a href="#Cryptographic-Background" class="headerlink" title="Cryptographic Background"></a>Cryptographic Background</h1><h2 id="arithmetic-circuits"><a href="#arithmetic-circuits" class="headerlink" title="arithmetic circuits"></a>arithmetic circuits</h2><ul><li>Fix a finite field $F={0,…,p-1}$ for some prime $p &gt; 2$</li></ul><p>Arithmetic circuit: $C:F^n\rightarrow F$</p><ul><li><p>directed acyclic graph (DAG) where internal nodes are labeled $+,-,\times$<br>inputs are labeled $1,x_1,…,x_n$</p></li><li><p>defines an n-variate polynomial with an evaluation recipe</p></li></ul><h2 id="Argument-systems"><a href="#Argument-systems" class="headerlink" title="Argument systems"></a>Argument systems</h2><p>public arithmetic circuit $C(x,w)\rightarrow F$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ZKP2-ZK-Whiteboard&quot;&gt;&lt;a href=&quot;#ZKP2-ZK-Whiteboard&quot; class=&quot;headerlink&quot; title=&quot;ZKP2-ZK Whiteboard&quot;&gt;&lt;/a&gt;ZKP2-ZK Whiteboard&lt;/h1&gt;&lt;h1 id=&quot;W</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>simulationPart3</title>
    <link href="http://example.com/posts/4630a136.html"/>
    <id>http://example.com/posts/4630a136.html</id>
    <published>2024-07-20T11:36:31.000Z</published>
    <updated>2024-07-25T09:42:22.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><strong>How To Simulate It – A Tutorial on the Simulation Proof Technique-Part3</strong></p><h1 id="Defining-Security-for-Malicious-Adversaries"><a href="#Defining-Security-for-Malicious-Adversaries" class="headerlink" title="Defining Security for Malicious Adversaries"></a>Defining Security for Malicious Adversaries</h1><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>相比半诚实敌手下的安全性定义，恶意敌手会更难一些，因为恶意敌手可能会做出任何偏离协议规定的行为，只要求存在一个模拟器，能根据其规定的输入和输出生成被破坏方的视图就足够了。</p><p>但是，相较于之前的敌手，攻击者可能不使用给定的输入去输出，此外，除了要考虑到攻击者会从中获取额外的信息以外，还应当考虑到攻击者对于输出所带来的影响。</p><p>我们在分析协议的安全性时，会将对手在协议中能做的事情与在理想情况下能做的事情进行比较，而理想情况下的协议根据定义是安全的。此外，我们会设计一个不可篡改的可信第三方，各方将其输入发送给该第三方。受信任方计算输入的功能，并向各方返回各自的输出。</p><p>我们假设总是有一方被破坏。</p><h2 id="The-Definition"><a href="#The-Definition" class="headerlink" title="The Definition"></a>The Definition</h2><p>理想模型允许理想执行中的对手中止执行或在诚实方未获得输出的情况下获得输出。</p><p>参与方$P_1,P_2$，敌手$\mathcal{A}$，函数$f:{0,1}^<em>\times {0,1}^</em> \rightarrow {0,1}^<em>\times {0,1}^</em>$的理想执行如下：</p><p>输入：$x(P_1),y(P_2),z(\mathcal{A})$，安全参数$1^n$</p><p>向可信方发送输入：诚实参与方$P_j$直接发送既定的输入给可信第三方。恶意参与方$P_i$可能会发送abort（通过发送一个$abort_i$的特殊消息）、发送既定的输入、发送等长的其他输入。这个决定由攻击者决定，可能是由$P_i$的输入值和辅助值$z$所影响的。定义发送给可信第三方的输入对为$(x^\prime,y^\prime)$。</p><p>提前终止选项：如果可信第三方收到了输入$abort_i$，那么可信第三方发送$abort_i$给$P_j$并结束执行。</p><p>可信方发送输出给攻击者：此时可信第三方计算得到$f_1(x^\prime,y^\prime),f_2(x^\prime,y^\prime)$然后发送$f_i(x^\prime,y^\prime),$给恶意参与方$P_i$</p><p>攻击者命令可信方继续或中止： 攻击者$\mathcal{A}$发送$comtinue$或者$abort_i$给可信第三方。如果发送的是$continue$，那么可信第三方把$f_j(x^\prime.y^\prime)$发送给诚实参与方$P_j$。如果攻击者$\mathcal{A}$发送的是$abort_i$，那么可信第三方发送$abort_i$给诚实参与方$P_j$。</p><p>输出：诚实参与方直接输出他从可信第三方中得到的输出值。恶意参与方什么都不输出。攻击者$\mathcal{A}$根据恶意参与方的既定输入值、攻击者的辅助值、从可信第三方得到的输出$f_j(x^\prime,y^\prime)$，输出任意的结果。</p><p>因此，一个理想执行的输出表示为$IDEAL_{f,\mathcal{A}(z)}$</p><p>在真实模型中的执行中，不存在可信的第三方，对手$\mathcal{A}$代替被破坏的一方发送所有信息，并且可以遵循任意多项式时间策略。与此相反，诚实的一方遵循协议$\pi$的指令</p><p>真实协议的执行被记作$REAL_{\pi,\mathcal{A}(z),i}(x,y,n)$</p><p>其中，$\pi$是协议，当 P1 和 P2 都诚实时，两方在分别输入 x 和 y 的情况下执行 $\pi$ 后分别输出 $f_1(x,y)$ 和 $f_2(x,y)$，安全参数是$n$，辅助输入是$z$</p><p><strong>形式化定义</strong></p><p>令 $f$ 是一个两方的functionality，令 $\pi$ 是一个两方的协议用于计算$f$。如果对于现实模型下的所有的non-uniform概率多项式时间攻击者 $\mathcal{A}$ ，都存在一个对于理想模型下的non-uniform概率多项式时间的攻击者 $S$ ，满足对于 $i \in {1,2}$</p><script type="math/tex; mode=display">\{IDEAL_{f,S(z),i}(x,y,n\}_{x,y,z,n}\stackrel{c}{\equiv}\{REAL_{\pi,\mathcal{A}(z),i}(x,y,n\}_{x,y,z,n}</script><p>其中$x,y\in{0,1}^<em>.|x|=|y|,z\in {0,1}^</em>,n\in N$</p><p>那么则认为协议 $\pi$ 能够<strong>securely compute</strong> $f$ <strong>with abort in the presence of static malicious adversaries。</strong></p><p>在本教程中，我们只考虑中止的安全性。因此，在后文中，当我们说 “安全地计算 ”时，其意图始终是终止计算。</p><p>请注意，上述式子包含了正确性和隐私性，因为理想分布和真实分布都包含了被破坏方和诚实方的输出。</p><h2 id="Modular-Sequential-Composition"><a href="#Modular-Sequential-Composition" class="headerlink" title="Modular Sequential Composition"></a>Modular Sequential Composition</h2><p>只要执行是按顺序进行的（即每次执行结束后才开始下一次执行），在顺序组合下安全的协议在多次运行时仍能保持其安全性。</p><p><strong>模块化顺序组合</strong>：模块化顺序组合定理表述的基本思想是证明可以设计一个将理想功能作为子程序的协议，然后分析受信任方计算该功能时协议的安全性。</p><p><strong>混合模型</strong>：双方运行一个协议$\pi$，该协议包含对可信方的 “理想调用”，该调用计算一些功能 $f<em>1,…,f</em>{p(n)}$。这些理想调用只是向可信方发送输入的指令。收到受信任方的输出后，协议$\pi$继续执行。协议$\pi$规定，每$i$次调用$f<em>i$之前都要调用$f</em>{i+1}$。诚实方在同一轮中向可信方发送其输入，在收到其输出之前不会发送其他信息。</p><p>协议$\pi$的hybrid执行被记作</p><p>$HYBRID<em>{\pi,\mathcal{A}(z),i}^{f_1,…,f</em>{p(n)}}(x,y,n)$</p><p>其中，x，y是输入，x是辅助输入</p><p>设$p(n)$为多项式，设$f<em>1、…、f</em>{p(n)}$为双方概率多项式时间功能，设$\rho$为协议，使得每个$\rho<em>i$都能在存在恶意对手的情况下安全地计算$f_i$。让$g$是一个双方功能，让$\pi$是一个在$f_1,…,f</em>{p(n)}$混合模型中，在存在恶意对手的情况下安全计算$g$的协议。那么，$\pi<em>{\rho_1,…,\rho</em>{p(n)}}$就能在存在恶意对手的情况下安全地计算 $g$。</p><h1 id="Advanced-Topics"><a href="#Advanced-Topics" class="headerlink" title="Advanced Topics"></a>Advanced Topics</h1><h2 id="Composition-and-Universal-Composability"><a href="#Composition-and-Universal-Composability" class="headerlink" title="Composition and Universal Composability"></a>Composition and Universal Composability</h2><p>在现实世界中，许多安全和不安全的协议都是并发运行的，因此我们希望在这种情况下也能保证安全性。最流行的定义是通用可组合性（UC）</p><p>这个定义扩展了之前的定义，增加了一个环境机，它本质上是一个交互式区分器。环境机将输入写入各方的输入磁带，并读取它们的输出。此外，在整个执行过程中，它还与对手进行外部交互。环境的 “目标 ”是区分真实协议执行和理想执行。这一定义的一个非常重要的缺陷是，模拟器不能再在模拟中倒退对手。这是因为真正的对手实际上什么也做不了，只能执行环境的指令。现在，由于环境是真实对手和理想对手相互作用的外部机器，这意味着模拟器必须为外部对手进行模拟。由此可见，如果没有一个诚实的多数人，就不可能在没有任何可信设置的情况下安全地计算 UC 框架中的一大类功能。</p><p>一般 UC 框架相当复杂，因为它几乎可以为任何任务和任何环境建模。</p><h2 id="Proofs-in-the-Random-Oracle-Model"><a href="#Proofs-in-the-Random-Oracle-Model" class="headerlink" title="Proofs in the Random Oracle Model"></a>Proofs in the Random Oracle Model</h2><p>在许多情况下，随机Oracle模型被用来获得更高的效率或其他无法获得的特性。其中一个问题是，区分者是否能获得随机Oracle，如果能，又是如何获得的。在 UC 框架中，随机Oracle可以建模为计算随机函数的理想功能。</p><h2 id="Adaptive-Security"><a href="#Adaptive-Security" class="headerlink" title="Adaptive Security"></a>Adaptive Security</h2><p>在本教程中，我们只考虑了静态对手的情况，即被破坏方的子集在协议执行开始前就已固定。与此相反，自适应对手可以根据所查看的信息，在整个协议过程中选择破坏哪一方。</p><p>对于适应性对手的情况，人们主要考虑了两种模型。第一种模式假定各方无法安全地删除数据，这被称为无删除模式。因此，一旦数据被擦除，敌方就会获得对方的全部信息—其输入、随机磁带和传入信息。</p><p>自适应安全性的一个较弱模型是假定各方可以安全地擦除数据；这被称为擦除模型。在这种情况下，各方有可能擦除部分数据。这使得模拟更容易，因为不需要生成整个视图，而只需要生成当前状态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;strong&gt;How To Simulate It – A Tutorial on the Simulation Proof Technique-Part3&lt;/strong&gt;&lt;/p</summary>
      
    
    
    
    <category term="密码学基础" scheme="http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="密码学基础" scheme="http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>zkp入门</title>
    <link href="http://example.com/posts/e769b1ef.html"/>
    <id>http://example.com/posts/e769b1ef.html</id>
    <published>2024-07-20T08:38:10.000Z</published>
    <updated>2024-08-19T06:05:31.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="ZKP入门"><a href="#ZKP入门" class="headerlink" title="ZKP入门"></a>ZKP入门</h1><p>交互式证明是可验证计算概念的核心概念。最重要的是，交互式证明理论为非交互式零知识证明 (NIZK)、简洁非交互式知识论证 (SNARK) 或简洁透明知识论证 (STARK) 奠定了基础。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="什么是证明系统"><a href="#什么是证明系统" class="headerlink" title="什么是证明系统"></a>什么是证明系统</h2><p>交互式证明系统是一种抽象的机器，它将通过计算建模为双方之间交换信息，分别称为证明者$P$和验证者$V$。</p><p>证明者无所不能，拥有无限的计算资源，但不可信任。</p><p>验证者的计算能力有限。</p><p>验证者和证明者之间会不断发送消息，直到验证者能够验证或伪造某个陈述。</p><p>所有交互式证明系统都具有两个关键属性：</p><p>完整性：当陈述是真实的，诚实的验证者可以通过诚实的证明者确认这一事实。</p><p>健全性：当陈述是错误的，除去可忽略不计的概率，没有恶意的证明者可以欺骗验证者。</p><h2 id="零知识保护隐私"><a href="#零知识保护隐私" class="headerlink" title="零知识保护隐私"></a>零知识保护隐私</h2><p>证明系统的第三个属性：</p><p><strong>零知识：</strong>如果陈述为真，那么没有任何作弊验证者会了解除此事实之外的任何其他信息。</p><p>零知识的阿里巴巴洞穴：</p><p>有一个洞穴，它的路径一分为二。这两条路径由一扇门连接，这扇门只能用密码打开。一个人叫爱丽丝，想向另一个人鲍勃证明她知道密码，而不会泄露它。为此，双方首先将自己置于洞穴的入口处。然后爱丽丝进入洞穴，沿着两条路径中的一条走——这取决于她自己。鲍勃从入口无法判断爱丽丝选择了哪条路。</p><p>然后鲍勃进入洞穴，跑到岔路口。他选择两条路径中的一条，并称这条路径进入洞穴。爱丽丝的任务是通过这条路径找到鲍勃。如果她成功了，她就离向鲍勃证明她知道秘密单词的目标更近了一步。</p><p>如果 Alice 选择了 Bob 选择的路径，她就不需要密码。只有当她选择相反的路径时，她才必须通过门才能走上正确的路径。这意味着，一个心怀恶意的 Alice（她不知道密码）在一次运行该协议时只能说服 Bob 50%。（这就是为什么 Alice 和 Bob 必须重复执行该协议以降低健全性错误概率的原因。）该协议是一个零知识证明，因为无论 Alice 和 Bob 重复该过程多少次，如果 Alice 知道密码，她将始终遵循 Bob 选择的路径。与此同时，Bob 对秘密一无所知。</p><h2 id="识别方案"><a href="#识别方案" class="headerlink" title="识别方案"></a>识别方案</h2><p>身份识别方案的根本思想是，Alice 知道一些秘密（与她的身份直接相关），并且她向 Bob 证明自己知道这些秘密。为了防止将来有恶意的 Bob 冒充 Alice，协议要求 Bob 不得了解有关 Alice 秘密的任何部分信息。反之亦然。</p><h1 id="正式定义"><a href="#正式定义" class="headerlink" title="正式定义"></a>正式定义</h1><p>我们用图灵机来正式定义这个证明系统。</p><h2 id="交互式图灵机"><a href="#交互式图灵机" class="headerlink" title="交互式图灵机"></a>交互式图灵机</h2><p>交互式图灵机 (ITM) 是一种（确定性）多磁带图灵机。</p><p>磁带包括一盘只读输入磁带、一盘只读随机磁带、一盘读写工作磁带、一盘只写输出磁带、一对通信磁带，以及由单个单元组成的读写切换磁带。一盘通信磁带是只读的，另一盘是只写的。</p><p>输入磁带的内容称为输入，随机磁带的内容称为随机输入，终止时输出磁带的内容称为输出。</p><p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202407201717286.png" alt="image-20240720171729240"></p><center>两台交互式图灵机</center><p>我们称交互式图灵机$M_1$为证明者$P$，$M_2$为验证者$V$，所使用的语言为$L$。</p><p>正确陈述：$(x,w)\in L$，错误陈述：$(x,w)\notin L$</p><p>其中，值$x$是公开的，$P,V$都知道，参数$w$（见证）是私有的，只有证明者知道。</p><p>语言$L$被定义为某个有限字母表上的一组字符串，并根据一组特定的规则形成。</p><p>例如$\Sigma={0,1,2,-,=}$上的语言$L$具有以下语法：</p><ul><li>所有不包含-和=且不以0开头的非空字符串都在$L$</li><li>包含“=”的字符串在$L$中当且仅当存在一个“=”，并且它将<strong>L中的两个有效字符串分隔开</strong></li></ul><h2 id="交互式证明系统"><a href="#交互式证明系统" class="headerlink" title="交互式证明系统"></a>交互式证明系统</h2><p>一对交互式图灵机$(P,V)$被称为语言$L$的交互式证明系统，应当满足以下条件：</p><ul><li>完整性：对于语言$L,(x,w)$，证明者$P$能够说服验证者$V$的概率十分大：</li></ul><script type="math/tex; mode=display">\forall (x,w)\in L,Pr[<P(x,w).V(x)>=1] \le 1-negl</script><ul><li>健全性，对于所有不属于语言$L,(x,w)$，证明者$P^\prime$通过作弊的手段说服验证者$V$的概率可以忽略不计。</li></ul><script type="math/tex; mode=display">forall (x,w)\notin L, Pr[<P^\prime(x),V(x)>=1] \le negl</script><ul><li>特殊健全性，对于$L,(x,w)$，都能在一个多项式时间算法$E$，使得可以从$P,V$的有效对话中提取出证据$w$</li></ul><script type="math/tex; mode=display">\forall (x,w)\in L, \exist E:Pr[E<P(x,w),V(x)>=w]\le 1-negl</script><ul><li>零知识：对于$L,(x,w)$，对于所有验证者，都存在一个模拟器$S$，使得没有多项式时间区分器$D$可以区分模拟协议的执行与$P,V$之间的真实交互的执行。</li></ul><script type="math/tex; mode=display">forall (x,w)\in L, \forall V \exist S,Pr[D(P(x,w),V(x))=1]-Pr[D(S(x))=]</script><h1 id="Schnorr协议"><a href="#Schnorr协议" class="headerlink" title="Schnorr协议"></a>Schnorr协议</h1><p>Schnorr协议有三轮，定义在$q$阶循环群$G$上，生成器$g$，语言$L={(x,w):x=g^w}$</p><p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202407221721144.png" alt="image-20240722172124050"></p><center>Schnorr协议</center><p><strong>Setting</strong></p><ul><li>$P$有秘密输入$w$和公开输入$x=g^w$</li><li>$V$只有公开输入$x=g^w$</li><li>$P,V$都有公共参数$g,q$</li></ul><p><strong>Protocol</strong></p><ul><li>$P$生成一个随机群元素$h$并且采样一个随机数$r$，然后发送$a=g^r$给$V$</li><li>$V$选择一个随机挑战$e\in {0,…,q-1}$并发送给$P$</li><li>$P$回应挑战$z=r+ew$</li><li>当且仅当$g^z=ax^e$，$V$才接收响应。</li></ul><h2 id="安全性分析"><a href="#安全性分析" class="headerlink" title="安全性分析"></a>安全性分析</h2><p><strong>完整性</strong></p><script type="math/tex; mode=display">\forall r,e: g^z=g^{x+ew}=g^zg^{we}=a</script>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;ZKP入门&quot;&gt;&lt;a href=&quot;#ZKP入门&quot; class=&quot;headerlink&quot; title=&quot;ZKP入门&quot;&gt;&lt;/a&gt;ZKP入门&lt;/h1&gt;&lt;p&gt;交互式证明是可验证计算概</summary>
      
    
    
    
    <category term="密码学基础" scheme="http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="密码学基础" scheme="http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>精通以太坊</title>
    <link href="http://example.com/posts/de8726eb.html"/>
    <id>http://example.com/posts/de8726eb.html</id>
    <published>2024-07-18T03:09:18.000Z</published>
    <updated>2024-07-31T11:32:21.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h1><h2 id="以太坊开发主要有四个阶段"><a href="#以太坊开发主要有四个阶段" class="headerlink" title="以太坊开发主要有四个阶段"></a>以太坊开发主要有四个阶段</h2><p>四个主要的发展阶段代号为前沿（Frontier），家园（Homestead），大都会（Metropolis）和宁静（Serenity）。中间的硬分叉代号为“冰河时代（Ice Age）”，“DAO”，“蜜桔前哨（Tangerine Whistle）”，“假龙（Spurious Dragon）”，“拜占庭（Byzantium）”和“君士坦丁堡（Constantinople）”。它们在下面列出，以及硬分叉发生的块号：</p><h4 id="之前的过渡"><a href="#之前的过渡" class="headerlink" title="之前的过渡"></a>之前的过渡</h4><ul><li><p>Block #0</p><p><strong>“Frontier”</strong> - 以太坊的初始阶段, 从2015年7月30日持续到2016年3月。</p></li><li><p>Block #200,000</p><p>“Ice Age” - 引入指数级难度增长的一个难题，激励了到权益证明的过渡。</p></li><li><p>Block #1,150,000</p><p><strong>“Homestead”</strong> - 以太坊的第二阶段，2016年3月启动。</p></li><li><p>Block #1,192,000</p><p>“DAO” - 恢复被破坏的DAO合约的硬分叉，导致以太坊和以太坊经典分成两个竞争系统。</p></li><li><p>Block #2,463,000</p><p>“Tangerine Whistle” - 改变某些IO密集操作的燃气计算方法和清除拒绝服务攻击（利用这些操作的低燃气成本）累积状态的硬分叉。</p></li><li><p>Block #2,675,000</p><p>“Spurious Dragon” - 解决更多拒绝服务攻击向量和另一种状态清除的硬分叉，还包括转播攻击保护机制。</p></li></ul><h2 id="以太坊和图灵完整性"><a href="#以太坊和图灵完整性" class="headerlink" title="以太坊和图灵完整性"></a>以太坊和图灵完整性</h2><p>术语“图灵完全”是以英国数学家阿兰图灵（Alan Turing）的名字命名的，他被认为是计算机科学之父。1936年，他创建了一个计算机的数学模型，该计算机由一个状态机构成，该状态机通过读写顺序存储器（类似于无限长度的磁带）来操纵符号。通过这个构造，Alan Turing继续提供了一个来回答（否定的）关于 <em>通用可计算性</em>（是否可以解决所有问题）问题的数学基础。他证明了存在一些不可计算的问题。具体来说，他证明 <em>停机问题</em> <em>Halting Problem</em>（试图评估程序是否最终会停止运行）是不可解决的。</p><p>以太坊的突破性创新是将存储程序计算机的通用计算架构与去中心化区块链相结合，从而创建分布式单状态（单例）世界计算机。以太坊程序“到处”运行，但却产生了共识规则所保证的共同（共识）状态。</p><h2 id="从通用区块链到去中心化应用-DApps"><a href="#从通用区块链到去中心化应用-DApps" class="headerlink" title="从通用区块链到去中心化应用 (DApps)"></a>从通用区块链到去中心化应用 (DApps)</h2><p>以太坊扩展为编程去中心化应用（DApps）的平台。DApps至少是一个智能合约和一个web用户界面。</p><p>以太坊的开发文化：速度和创新</p><h2 id="以太坊基础"><a href="#以太坊基础" class="headerlink" title="以太坊基础"></a>以太坊基础</h2><h3 id="控制和责任"><a href="#控制和责任" class="headerlink" title="控制和责任"></a>控制和责任</h3><p>因为去中心化，以太坊的每位用户都应该学会保存自己的密钥，这些密钥可以控制对资金和合约的访问。如果你丢失了密钥，你将无法获得资金和合约，你的资金将永远锁定。</p><h3 id="以太坊货币单位"><a href="#以太坊货币单位" class="headerlink" title="以太坊货币单位"></a>以太坊货币单位</h3><p>以太坊货币单位称为 <em>以太</em>，ETH</p><p>$1ETH=10^{18}wei$</p><h3 id="以太坊钱包"><a href="#以太坊钱包" class="headerlink" title="以太坊钱包"></a>以太坊钱包</h3><p>推荐使用MetaMask</p><h2 id="密钥，地址"><a href="#密钥，地址" class="headerlink" title="密钥，地址"></a>密钥，地址</h2><p>以太坊有两种不同类型的账户，可以拥有和控制ether：<em>外部所有账户</em>（EOA）和<em>合同</em>。</p><p>EOAs中以太的所有权通过 <em>数字密钥</em> <em>digital keys</em>，<em>以太坊地址<em>和</em>数字签名</em> 建立 。</p><h2 id="钱包"><a href="#钱包" class="headerlink" title="钱包"></a>钱包</h2><p>钱包是作为主要用户界面的应用程序。钱包控制对用户资金的访问，管理密钥和地址，追踪余额以及创建和签署交易。另外，一些以太坊钱包还可以与合约（如代币）进行交互。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;



&lt;h1 id=&quot;Chapter-1&quot;&gt;&lt;a href=&quot;#Chapter-1&quot; class=&quot;headerlink&quot; title=&quot;Chapter 1&quot;&gt;&lt;/a&gt;Chapter 1&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>simulationPart2</title>
    <link href="http://example.com/posts/313791a0.html"/>
    <id>http://example.com/posts/313791a0.html</id>
    <published>2024-05-27T03:10:37.000Z</published>
    <updated>2024-09-10T03:03:46.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><strong>How To Simulate It – A Tutorial on the Simulation Proof Technique-Part2</strong></p><h1 id="Simulating-the-View-of-Malicious-Adversaries–-Zero-Knowledge"><a href="#Simulating-the-View-of-Malicious-Adversaries–-Zero-Knowledge" class="headerlink" title="Simulating the View of Malicious Adversaries– Zero Knowledge"></a>Simulating the View of Malicious Adversaries– Zero Knowledge</h1><p>零知识仿真考虑的是恶意对手（尤其是恶意验证者），他们的行为可能是任意的，不一定符合协议规范。零知识中没有私人输入或输出，模拟器需要在证明中生成验证者的观点，而不需要考虑输入和输出的额外复杂性。</p><p><strong>恶意的验证者</strong>：在零知识证明系统中，确实主要考虑的是恶意的验证者，而不是恶意的证明者。这是因为零知识证明的目标是让证明者向验证者证明某件事情，而不泄露任何额外的信息。因此，系统需要确保即使验证者是恶意的，也无法从证明中获取任何额外的信息。证明者通常被假设为诚实的，因为如果证明者是恶意的，他们可以随意伪造证明，这样整个系统就失去了意义。</p><p><strong>模拟器需要生成验证者在证明中的视图</strong>：这句话的意思是，模拟器需要生成一个与验证者在实际证明过程中看到的内容相同的视图。具体来说，模拟器需要生成验证者在与证明者交互时所看到的所有消息和数据，但不依赖于任何实际的秘密信息。这是为了证明即使验证者是恶意的，他们也无法从证明中获取任何额外的信息，因为模拟器可以在没有任何秘密信息的情况下生成相同的视图。</p><h2 id="Defining-Zero-Knowledge"><a href="#Defining-Zero-Knowledge" class="headerlink" title="Defining Zero Knowledge"></a>Defining Zero Knowledge</h2><p><strong>Notation</strong></p><p>$A$：概率多项式时间机器</p><p>$A(x,y,r)$：机器A在输入$x$，辅助输入$y$和随即磁带$r$上的输出。</p><p>$n=|x|$：语句$x$的长度</p><p>$output_B(A(x,y,r_A),B(x,y,r_B))$：表示乙方在公共输入$x$上与甲方交互执行的输出，其中甲方有辅助输入$y$和随机磁带$r_A$，乙方有辅助输入$z$和随机磁带$r_B$</p><p>$output_B(A(x,y),B(x,z)),output_B(A(x,y,U_m),B(x,z,U_m^\prime))$</p><p>$m$：是 A（或B）在大小为$|x|$的输入上使用的随机比特数。</p><p><strong>The definition</strong></p><p>语言$L$的交互式证明系统包括一个证明者$P$和一个验证者$V$，在共同输入$x$时，证明者$P$试图让验证者$V$相信$x \in L$。这样的证明系统具有以下两个特性：</p><ol><li>完备性：这说明，当诚实的$P$和$V$就共同输入$x\in L$进行交互时，那么$V$确信$x\in L$这一语句的正确性（但最多可忽略的概率除外）。</li><li>健全性：这说明当$V$在共同输入$x \in L$上与任何（作弊的）证明者$P$交互时，$V$将以最多可忽略的概率被说服。(因此，$V$不可能被骗去接受一个错误的陈述）。</li></ol><p>如果存在一个模拟器，可以仅从语句生成验证者的观点，那么这个证明就是零知识。我们要指出的是，被破坏的验证者可以输出任何它想输出的东西，包括它的观点。</p><p>在本文定义中，我们仅考虑黑盒情况和$NP$语言情况</p><p>Definition 5.1 Let $(P,V)$ be an interactive proof system for an $NP-language L$, and let $R_L$ be the associated $NP-relation$. We say that $(P,V)$is black-box computational zero knowledge if there exists a probabilistic-polynomial time oracle machine $S$ such that for every non-uniform probabilisticpolynomial time algorithm $V^*$ it holds that:</p><script type="math/tex; mode=display">\{output_{V^*}(P(x,w),V^*(x,z))\}_{(x,w)\in R_L, z\in \{0,1\}^*}\stackrel{c}{\equiv} \{S^{V^*(x,z,r,\cdot)} \}(x)_{x\in L,z \in \{0,1\}^*}</script><p>where $r$ is uniformly distributed, and where $V^<em>(x,z,r\cdot)$ denotes the next-message function of the interactive machine $V^</em>$ when the common input $x$, auxiliary input $z$ and random-tape $r$ are fixed (i.e., the next message function of $V^*$ receives a message history $m^\prime$ and outputs $V^∗(x,z,r,m^\prime))$.</p><p><strong>定义5.1</strong>：设 $(P,V)$ 是一个 $NP$ 语言 $L$ 的交互式证明系统，$R_L$ 是相关的 $NP$ 关系。如果存在一个概率多项式时间的预言机器 $S$，使得对于每一个非一致的概率多项式时间算法 $V^*$，都有以下等价关系成立：</p><script type="math/tex; mode=display">\{output_{V^*}(P(x,w),V^*(x,z))\}_{(x,w)\in R_L, z\in \{0,1\}^*}\stackrel{c}{\equiv} \{S^{V^*(x,z,r,\cdot)} \}(x)_{x\in L,z \in \{0,1\}^*}</script><p>其中 $r$ 是均匀分布的，$V^<em>(x,z,r\cdot)$ 表示当公共输入 $x$、辅助输入 $z$ 和随机带 $r$ 固定时，交互式机器 $V^</em>$ 的下一条消息函数（即 $V^*$ 的下一条消息函数接收一个消息历史 $m^\prime$ 并输出 $V^∗(x,z,r,m^\prime)$）。</p><p>这段话的意思是，对于一个 $NP$ 语言的交互式证明系统 $(P,V)$，我们称它为黑盒计算零知识，如果存在一个概率多项式时间的预言机器 $S$，使得对于任何非一致的概率多项式时间算法 $V^*$，系统的输出与 $S$ 机器的输出在计算上是不可区分的。这里的 “不可区分” 指的是，即使有一个强大的对手，也无法有效地区分两个输出集合的差异。</p><p>在这个定义中，$P$ 是证明者，$V$ 是验证者，$V^<em>$ 是一个可能的恶意验证者。$x$ 是公共输入，$w$ 是证明者的私有见证，$z$ 是辅助输入，$r$ 是随机带。预言机器 $S$ 被用来模拟证明者 $P$ 的行为，以产生一个与实际交互过程中验证者 $V^</em>$ 观察到的输出在计算上不可区分的输出。</p><p>简而言之，这个定义说明了一个交互式证明系统是零知识的，如果存在一个模拟器 $S$，它可以在不知道证明者私有见证 $w$ 的情况下，仅仅通过与恶意验证者 $V^<em>$ 的交互，生成一个与真实交互过程中 $V^</em>$ 观察到的输出在计算上不可区分的输出。这保证了即使验证者尝试作弊，也无法获得关于证明者私有见证的任何信息。</p><h2 id="Preliminaries–-Commitment-Schemes"><a href="#Preliminaries–-Commitment-Schemes" class="headerlink" title="Preliminaries– Commitment Schemes"></a>Preliminaries– Commitment Schemes</h2><p>$c=Com_n(x;r)$：通过使用随机字符串$r$和安全参数$n$对$x$的承诺</p><p>$if\ c=Com_n(x;r), decom(c)=(x,r)$</p><p><strong>perfect binding</strong> 是一个重要的概念，它确保了一个承诺方案（commitment scheme）的安全性。承诺方案允许一个人承诺一个值而不立即透露它，同时确保该值在未来可以被验证。</p><p>$for\ all\ x<em>1 \ne x_2, C</em>{x<em>1}\cap C</em>{x<em>2}, where\ C</em>{x<em>1}={c|\exist r:c=Com(x_1;r},C</em>{x_2}={c|\exist r:c=Com(x_2;r}$</p><p><strong>Computational hiding</strong>对于任何有限计算能力的攻击者来说，对不同字符串的承诺在计算上是无法区分的。换句话说，即使攻击者使用所有可用的计算资源，他们也无法确定承诺是对哪个字符串做出的。</p><p>$C<em>0\stackrel{c}{\equiv}C_1, C_b={Com(b;U_n}</em>{n\in N}$</p><p><strong>LR-security of commitments</strong></p><p>$LR-oracle$（$Left\ or\ Right\ oracle$）的定义是通过向对手提供一个甲骨文来实现的，这个预言机接收两个等长输入，要么总是返回对第一个（左）输入的承诺，要么总是返回对第二个（右）输入的承诺。对手的任务就是确定它收到的是左承诺还是右承诺。</p><p>我们将其定义为</p><script type="math/tex; mode=display">LR_{Com}^b(x_0,x_1)=\{Com(x_b), if |x_0|=|x_1|\\ \{\perp, otherwise</script><p>其中敌手$\mathcal{A}$要么被给予$LR<em>{Com}^0$要么被给予$LR</em>{Com}^1$并且要尝试能够区分这两个。</p><p><strong>Experiement</strong> $LR-commit_{Com,\mathcal{A}}(1^n)$</p><ol><li>Choose a random $b\leftarrow {0,1}$</li><li>Set $b^\prime \leftarrow \mathcal{A}^{LR_{Com}^b(\cdot,\cdot)}(1^n)$</li><li>Output 1 if and only $b^\prime=b$</li></ol><p>如果$Com$是一个非交互式完全约束承诺方案，对非均匀对手具有安全性，那么对于每个非均匀概率-多项式时间对手$\mathcal{A}$，都存在一个可忽略的函数$\mu$，使得</p><script type="math/tex; mode=display">Pr[LR-commit_{Com,\mathcal{A}}(1^n)=1]\le \frac{1}{2}+\mu(n)</script><p>我们将在下文中指出，非均匀安全性是必需的。</p><h2 id="Non-Constant-Round-Zero-Knowledge"><a href="#Non-Constant-Round-Zero-Knowledge" class="headerlink" title="Non-Constant Round Zero Knowledge"></a>Non-Constant Round Zero Knowledge</h2><p>考虑零知识证明中的三着色问题和汉密尔顿性。</p><p>这类协议通常包含着三部分：</p><ol><li>$P$发送承诺（commitment）</li><li>$V$发送挑战（challenge），并要求$P$打开承诺</li><li>$P$发送合适的回应（decommitment）</li></ol><p>考虑三色问题，这类问题要求证明，在一个图$G$中，要求为$G$中每一个顶点涂色，使得相邻两个顶点的颜色不同。证明者承诺一个随机的有效着色，验证者要求打开与一条边相关的颜色。图中必须至少有一条边能为证明者承诺着色的边的两个端点分配相同的颜色。如果验证者要求打开这条边的颜色，那么证明者就会被发现作弊。因此，证明者作弊的概率最多为$\frac{1}{|E|}$，其中$E$是边的合集</p><p>通过重复证明 $n\cdot |E|$次（其中$n$是图的个数），我们可以得出证明者作弊的概率最多$(1-\frac{1}{|E|})^{n\cdot |E|} &lt; e^{-n}$可以忽略不计。因此，这个证明是正确的。</p><p>对于这个问题的模拟器证明思路，如果模拟器提前知道要查询的边，那么它就可以在该边的端点上随机承诺不同的颜色，而在其他地方承诺垃圾颜色。根据承诺方案的隐藏特性，这将是无法区分的。我们将看到，模拟器只需重复猜测要提前查询的边，直到猜对为止。</p><p><strong>The rewinding technique (with commitments as envelopes)</strong></p><p>首先，我们将描述如何构建一个模拟器，当我们把承诺建模为完美的信封时，信封在打开之前什么也不会显示。</p><p>构建模拟器的关键工具是重绕（rewind）。</p><p>模拟器调用验证器，并猜测一条随机边$e=(v_i,v_j)\in_R E$，希望验证器能查询这条边。</p><p>然后，模拟器会向验证者发送着色承诺。</p><p>如果验证者回复边$e^\prime=e$，那么模拟器就为$e$中的节点打开信封，本次迭代的模拟就完成了。否则，模拟器会将验证器倒退到迭代的起点并再次尝试，这次选择一条新的随机边。如此反复，直到$e^\prime = e$，模拟器就成功了。</p><p>这种倒退不同于一般的倒退，它存在一定的失忆性，也就是不会记录失败的情形，就如同虚拟机的快照功能，可以快速回到某个时刻的某种状态。不失一般性的情况下，模拟器选择边的概率是$\frac{1}{|E|}$，期望次数为$|E|$，当执行超过$n\cdot|E|$次rewinding后，能够确保模拟器以极大的概率最终通过挑战。</p><p>这种设计下，验证者在模拟中的视图分布与其在实际执行中的视图分布完全相同。两者之间的区别在于，在真实证明中没有rewinding。</p><p><strong>模拟器是如何实现rewind功能的</strong></p><p>具体来说，模拟器可以从Oracle中获取验证者的下一个信息函数$V^<em>(x,z,r,\cdot)$。这意味着，它提供了一份传入信息的副本$\vec{m}=(m_1,m_2,…)$，并在$V^</em>$具有输入$x$、辅助输入$z$、随机磁带$r$和传入信息$\vec{m}$时，接收回发送的下一条信息。现在，倒带实质上就是$S$用$(r,(m_1,m_2,m_3))$调用其甲骨文，然后再用$(r,(m_1,m_2,\vec{m}))$调用，以此类推。</p><p><strong>零知识属性与健全性不矛盾</strong></p><p>模拟器可以在不知道证明者的情况下证明定理，作弊者不可以，因为模拟器拥有证明者所不具备的额外能力，rewind。</p><p>上述承诺模型过于简单，我们还需要证明：</p><p>首先，必须证明验证者的视图在模拟和实际执行中是不可分的。</p><p>需要证明模拟在$n|E|$次尝试内成功停止，除非概率可以忽略不计。</p><p><strong>关于中止情况的处理</strong></p><p>在模拟阶段，如果$V^*$没有返回某条有效的边，可以让真正的验证者将任何无效回复解释为默认边。</p><p><strong>Theorem</strong>：Let $Com$ be a perfectly-binding commitment scheme with security for non-uniform adversaries. Then, the 3-coloring protocol of is black-box $computational\ zero\ knowledge$.</p><p><strong>Proof</strong>：</p><p>$S$是一个模拟器，给定一个图$G=(V,E),V={v_1,…,v_n}$，以及对某个个概率多项式时间$V^*(x,z,r,\cdot)$的访问</p><p>工作原理如下：</p><p>1.$S$将消息历史副本$\vec{m}$初始化为空字符串$\lambda$</p><p>2.以下步骤重复$n\cdot |E|$次</p><p>（a）$S$设置$j=1$</p><p>（b）$S$随机选择一条边$(v_k,v_l)\in_RE$并给两个点不同颜色。形式上，$S$选择$\phi(k)\in_R{1,2,3}$并且$\phi(v_l)\in_R{1,2,3} \textbackslash {\phi(v_k)}$。对于其余的$v_i \in V \textbackslash {v_k,v_l}$，$S$设置$\phi(v_i)=0$</p><p>（c）对于$i=1,…,n$，$S$计算$c_i=Com(\phi(v_i))$</p><p>（d）$S$发送$(c_1,…,c_n)$给$V^*$。形式上，$S$查询与该向量连接的$\vec{m}$，并让$e\in E$作为回复</p><p>（e）如果$e=(v_k,v_l)$，那么$S$将承诺$(c_1,…,c_n)$和$(decom(c_k),decom(c_l))$发送给$\vec{m}$。形式上，$S$更新字符串$\vec{m}\leftarrow (\vec{m},(c_1,…,c_n),(decom(c_k),decom(c_l)))$</p><p>（f）如果$e \ne (v_k,v_l)$，那么$S$设置$j \leftarrow j+1$。如果$j = n\cdot |E|$，则$S$输出失败符号$\perp$，否则返回第2b步。</p><p>3.$S$输出$V^*$的任何结果。</p><p>为了证明模拟器$S$，我们构建一个新的模拟器$S^\prime$，它每次都知道正确的着色方法。</p><p>我们强调$S^\prime$并不是一个有效的模拟器，因为它得到的是$\phi$。相反，它是用于证明的思想实验。</p><p>现在，$S^\prime$的工作方式与$S$完全相同，只是在每次迭代中，它都会在${1,2,3}$上随机选择一个置换$\pi$，设置$\phi(v) = \pi(\phi(v))$，并对所有$i$计算$c_i = Com(\phi(v_i))$，这与真正的证明者完全相同。</p><p>我们要首先证明，模拟器$S^\prime$和$V^<em>$的输出是一致的，即对于每个$V^</em>,(G,\phi)\in R_L,z\in {0,1}^*$：</p><script type="math/tex; mode=display">\{output_{V^*}(P(G,\phi),V^*(G,z))\}\equiv \{S^{\prime V^*\{G,z,r,\cdot\}}(G,\phi)|S^{\prime V^*\{G,z,r,\cdot\}} (G,\phi)\ne \perp\}</script><p>由于二者都是对有效着色的随机排列的承诺，因此两者的分布是相同的。唯一不同的是，$S^\prime$提前选择了一条边$e$，并且只有当$V^\prime$发送的查询等与$e$时才结束迭代。</p><p>接下来证明，$S^\prime$最多以可忽略的概率输出$\perp$。在一次循环中，$n\cdot |E|$次都没选中$e$的概率是</p><p>$(1-\frac{1}{|E|})^{n\cdot |E|} &lt; e^{-n}$，对于$n\cdot|E|$轮循环中，概率不会超过$n\cdot|E|\cdot e^{-n}$，也就满足</p><script type="math/tex; mode=display">\{S^{\prime V^*(G,z,r,\cdot)}(G,\phi)|S^{\prime V^*(G,z,r,\cdot)}(G,\phi)\ne \perp\}\equiv \{S^{\prime V^*(G,z,r,\cdot)}(G,\phi)\}</script><p>最终，我们得到$S$和$S^\prime$是不可区分的：</p><script type="math/tex; mode=display">\{S^{\prime V^*(G,z,r,\cdot)}(G,\phi)\} \stackrel{c}{\equiv} \{S^{ V^*(G,z,r,\cdot)}(G,\phi)\}</script><p>假设存在一个概率多项式时间验证器$V^<em>$、一个概率多项式时间区分器$D$和一个多项式$p(\cdot)$，对于一个无限序列$(G,\phi,z),(G,\phi)\in R,z\in{0,1}^</em>$ </p><script type="math/tex; mode=display">|Pr[D(G,\phi,z,S^{\prime V^*(G,z,r,\cdot)}(G,\phi))=1]-Pr[D(G,\phi,z,S^{ V^*(G,z,r,\cdot)}(G,\phi))=1]| \ge \frac{1}{p(n)}</script><p>我们利用$LR-commit$实验作为证明方法，攻击者$\mathcal{A}$接收$(G,\phi,z)$作为辅助输入</p><p>1.$\mathcal{A}$输入$G,z,r$，初始化$V^*$</p><p>2.然后$\mathcal{A}$输入$(G,\phi),V^*(x,z,r;\cdot)$，但算法$\mathcal{A}$需要一些改动</p><p>（1）对于随机选择的边$e=(v_k,v_l)$，生成承诺$c_k=Com(\phi(v_k)),c_l=Com(\phi(v_l))$</p><p>（2）对于其他的所有点，攻击者以$(0,\phi(i))$来询问$LR-oracle$，用$c_i$作为返回值</p><p>3.当算法$S^\prime$结束后，算法$\mathcal{A}$调用区分器$D$并把$S^\prime$的输出作为区分器的输入，区分器输出什么，算法$\mathcal{A}$输出什么</p><p>此时我们发现，当$LR-oracle$随机选择bit是1的时候，承诺与$S^\prime$相同，0的时候，与$S$相同。</p><script type="math/tex; mode=display">Pr[LR-commit_{Com,\mathcal{A}}(1^n)=1|b=1]=Pr[D(G,z,S^{\prime V^*(G,z,r,\cdot)}(G,\phi))=1]</script><script type="math/tex; mode=display">Pr[LR-commit_{Com,\mathcal{A}}(1^n)=1|b=0]=Pr[D(G,z,S^{\prime V^*(G,z,r,\cdot)}(G,\phi))=0]</script><p>于是我们有：</p><script type="math/tex; mode=display">Pr[LR-commit_{Com,\mathcal{A}}(1^n)=1]\ge \frac{1}{2}+\frac{1}{2p(n)}</script><p>最终，我们得到：</p><script type="math/tex; mode=display">\{output_{V^*}P(G,\phi),V^*(G,z)\} \stackrel{c}{\equiv} \{S^{V*(G,z,r,\cdot)}(G)\}</script><p><strong>关于证明技巧的讨论。</strong></p><p>首先够造模拟器，然后找到模拟器与现实证明者之间的区别，如果这些区别能够一次证明不可区分，那就一步即可证明，如果不能的话，就将这些区别划分成多个能够证明的不可区分。然后逐步调整不同点，从模拟器到真实情况一点一点地变换过去。这种技术也被称为混合论证（hybrid argument）。除了模拟证明以外，还有一种经典的证明方式是游戏证明（game-based proof）。模拟证明与游戏证明的区别在于，模拟证明是从先构造模拟器，然后从理想情况一点点转移到真实情况中，而游戏证明是从真实情况一点点转移到一个理想的情况中。</p><h2 id="Constant-Round-Zero-Knowledge"><a href="#Constant-Round-Zero-Knowledge" class="headerlink" title="Constant-Round Zero-Knowledge"></a>Constant-Round Zero-Knowledge</h2><p>我们将三着色问题进行修改，将其变成一个常数轮的协议。</p><p>当我们简单地考虑并行运行$n\cdot |E|$轮协议的时候，但我们根本无法证明这仍然是零知识。</p><p>当并行时，证明者一次性发送$n\cdot |E|$份承诺，验证者一次性向证明者发送$n\cdot |E|$条随机的边，但此时rewind不再适用，在并行下，模拟器一次想要猜对的概率是$|E|^{-n|E|}$。因此，对于这种没有合适的证明方法的方案，可以通过修改协议来使得能够证明成功。这也是一种设计密码学方案的小技巧，有的时候可以通过一些小改变来使得一个方案满足可证明安全。</p><p>修改后的协议具体细节如下：</p><p>1.证明者选定相关perfectly-hiding承诺的信息并发送给验证者，用$Com_h$表示</p><p>2.$V$选择$N=n\cdot |E|$条随机的边，$e_1,…,e_N\in_RE$，$q=(e_1,…,e_N)$是query字符串，$V$用$Com_h$来隐藏$q$</p><p>3.$P$准备$N$份像非常数论的协议的承诺，$Com$发送给$P$</p><p>4.$V$decommit $q$</p><p>5.如果验证者的decommit是无效的，那么证明者直接abort。否则证明者对于query的每一条边都decommit。</p><p>6.验证者当且仅当所有的检查都通过的时候，输出1。</p><p>其中值得注意的是，验证者发给证明者的承诺是perfectly hiding的，而证明者发给验证者的承诺是perfectly binding的。</p><p>经过这样修改的协议可以确保验证者在承诺后是无法更改选择的边的，于是模拟器在验证者decommit字符串$q$后就会知道所有挑战值，然后rewind到验证者发完承诺的时候，此时模拟器就相当于提前知道了所有的挑战值，于是模拟器就可以很容易通过挑战了。</p><p>但是除此以外还有一些细节需要说明，也就是对于发生中止的情况要单独考虑进来。首先要考虑的就是验证者在decommit字符串$q$的时候是无效的，所以会发生abort。这存在的问题是，验证者的decommit阶段是在rewind之后，那么可能会出现，验证者第一次decommit是正常的，模拟器也从中获得了所有挑战值，但是在模拟器rewind以后，第二次验证者decommit无效导致模拟器中止。看似这种情况并不会对协议产生影响，但是这样会导致模拟器产生abort的概率与真实情况下产生abort的概率不同（因为模拟器需要两次都通过才能不abort），那么势必会导致产生的分布是可区分的。更糟糕的是，无法像非常数轮那样，即使验证者发送的decommit无效，证明者也继续运行，并将无效的边视为某一条默认的边。因为如果这样做的话，如果验证者decommit无效，模拟器就没有办法准备正确的挑战边，那么一次rewind将无法保证能够顺利通过挑战。因此，解决这个问题的方法是如果第一次abort了，那模拟器就直接abort，如果第一次没abort，那么无论接下来就不去理会验证者发来的commitment是否能够decommit成功（如果decommit不成功就继续循环直到成功），因为此时已经知道了对应的挑战值。</p><p>剩下的需要关注的点在于，verifier使用的commitment scheme是perfectly hiding的，所以最多只能是computationally binding，也就意味着$V^*$有可能decommit出有效的值$q^\prime=q$，但此时simulation就失效了。因此需要把这部分情况考虑进来，用归约的方式把这部分证明。</p><p>另一个需要注意的问题在于，模拟器的运行时间可能并不是期望多项式时间的。假设验证者$V^*$不abort的概率为$\epsilon$，那么我们可以估算出模拟器的运行时间大概为$poly(n)\cdot(1-\epsilon(n)+\epsilon(n)\cdot\frac{1}{\epsilon(n)})$ ，但实际上需要考虑到commitment并不是perfectly hiding的，所以一旦恶意验证者是可以区分commitment的话，那么验证者可以只要判断收到的是garbage commitment就可以一直abort，令模拟器永远无法通过挑战。所以真正计算运算时间的时候应该把这部分概率考虑进去，即$poly(n)\cdot(1-\epsilon(n)+\epsilon(n)\cdot\frac{1}{\epsilon(n)-\mu(n)})$ 。看似这个式子仍然可以满足期望多项式时间，但如果$\epsilon(n)$的概率值与$\mu(n)$的概率过于接近的话，运行时间将可能会是指数级别的。有关运行时间的问题是一个共性问题，一旦rewind前后的分布是不同的（即使不可区分），而且想要整个模拟继续运行下去需要攻击者达到某种条件（比如，攻击者不能abort），那么就都可能会面临这个问题。</p><p><strong>安全性证明</strong></p><p>令$Com_h$是一个perfectly-hiding承诺机制， $Com$是一个perfectly- binding 承诺机制，它们都具有对于non-uniform概率多项式时间攻击者算法下的安全性。那么上述常数轮的协议满足黑盒计算零知识安全性（模拟器的运行时间是期望多项式时间）</p><p>证明：</p><p>我们给出模拟器的构造</p><ol><li><p>模拟器$S$调用$V^*$并选定相关承诺的信息输入进去。</p></li><li><p>模拟器$S$得到验证者$V^*$的commitment$c$。</p></li><li><p>模拟器$S$发送给$V^<em>$garbage commitments然后获得$V^</em>$的decommitment输出。</p></li><li><p>如果decommitment是无效的，那么直接中止。否则，把decommited的字符串表示为$q=(e_1,…e_n)$，并执行以下步骤。</p></li><li><p>模拟器 $S$ rewind到最开始并获得了commitment $c$ （因为 𝑉∗ 的random tape是固定的，所以 $c$ 是一样的，那么就能确保 $q$ 是一致的）：</p></li><li><ol><li>模拟器 $S$ 生成 $N$ 个承诺向量 $\vec{c_1},…,\vec{c_N}$ 。选择验证者挑战的边设置为不同的着色，其余的着色均是0（garbage值）。模拟器将承诺向量发送给验证者$V^*$，并得到回复。</li><li>如果 $V^*$ 没有生成有效的decommitment，那么模拟器 $S$ 回退到前一步（用新的随机性）。</li><li>如果 $V^<em>$ 生成有效的decommitment但是 $q^\prime \ne q$ ，那么模拟器 $S$ 输出<em>*ambiguous</em></em>并中止。</li><li>否则，$V^*$ 退出循环并进行到下一步。</li></ol></li><li><p>模拟器 $S$ 向 $V^<em>$ 继续发送对应点的decommitment，然后输出 $V^</em>$ 的输出。</p></li></ol><p>然而目前的模拟器构造还不够，因为还没有解决运行时间超过期望多项式时间的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;strong&gt;How To Simulate It – A Tutorial on the Simulation Proof Technique-Part2&lt;/strong&gt;&lt;/p</summary>
      
    
    
    
    <category term="密码学基础" scheme="http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="密码学基础" scheme="http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>浙大暑期课程</title>
    <link href="http://example.com/posts/e97ac66e.html"/>
    <id>http://example.com/posts/e97ac66e.html</id>
    <published>2024-05-14T13:05:00.000Z</published>
    <updated>2024-05-29T08:49:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Provable-Security-Basics"><a href="#Provable-Security-Basics" class="headerlink" title="Provable Security Basics"></a>Provable Security Basics</h1><p>Modern Cryptography: </p><ul><li>Confidentiality</li><li>Integrity</li><li>Authentication</li></ul><p>Provable Security:</p><ul><li>Precisely specify threat model</li><li>Propose a construction</li><li>Write a formal proof(reduction)</li></ul><p>One-way function:</p><p>f(x) is polynomial-time computable for all x</p><p>For all PPT algorithm $\mathcal{A}$</p><p>$Pr[Invert_{\mathcal{A},f}(n)=1]\le \epsilon(n)$</p><p>Discrete Logarithm Problem</p><p>Let $\mathcal{G}$ be a neneric, polynomial-time, group generation algorithm</p><p>Input $1^n$, output $G,q,g\in G$</p><p>$DLog_{\mathcal{A,G}}(n)$</p><p>1.Generate $(G,q,g)\leftarrow \mathcal{G}(1^n)$</p><p>2.Choose a uniform $h\leftarrow G$</p><p>3.Obtain $x\leftarrow \mathcal{A}(G,q,g,h)$</p><p>4.Return 1 iff $g^x=h$</p><p>CDH vs DL</p><p>Theorem: if the CDH problem is hard relative to $\mathcal{G}$ then discrete logarithm problem is also hard relative to $\mathcal{G}$</p><p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202405151620728.png" alt="image-20240515162032528"></p><h1 id="MPC"><a href="#MPC" class="headerlink" title="MPC"></a>MPC</h1><p>安全多方计算</p><p>安全多方计算的分类</p><p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202405291627264.png" alt="image-20240529162700168"></p><p>2-move Two-party Computation</p><ol><li>Encode a by using pk</li><li>Compute f(a,b) over encoded inputs</li><li>Decode c by using sk, botain f(a,b)</li></ol><p>Elgamal is IND-CPA Secure</p><p>If the DDH problem is hard relative to $\mathcal{G}$,then the Elgamal encryption scheme is IND-CPA secure</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Provable-Security-Basics&quot;&gt;&lt;a href=&quot;#Provable-Security-Basics&quot; class=&quot;headerlink&quot; title=&quot;Provable Security Basics&quot;&gt;&lt;/a&gt;Provable Secur</summary>
      
    
    
    
    <category term="密码学基础" scheme="http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="密码学基础" scheme="http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>simulation</title>
    <link href="http://example.com/posts/cbda467b.html"/>
    <id>http://example.com/posts/cbda467b.html</id>
    <published>2024-05-13T08:14:37.000Z</published>
    <updated>2024-08-05T01:34:47.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><strong>How To Simulate It – A Tutorial on the Simulation Proof Technique</strong></p><p>本文将介绍如何通过模拟的思想去证明一个密码学系统的安全性。</p><p>文档原文：<a href="https://eprint.iacr.org/2016/046.pdf">https://eprint.iacr.org/2016/046.pdf</a></p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>首先，我们需要理解什么是模拟—simulation。</p><p>原文是这样描述的：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Simulation is a way of comparing what happens in the “real world” to what happens in an “ideal world” where the primitive in question is secure by definition. </span><br></pre></td></tr></table></figure><p>也就是说，模拟是一种比较方式，将ideal world和real world进行比较。</p><p>所谓的<strong>理想世界 (ideal world)</strong> 是一个理论模型，用于描述一个安全协议在理想条件下的行为。在这个模型中，存在一个被称为<strong>理想函数</strong>的抽象实体，它能够完美地执行协议应有的功能，而不会泄露任何额外的信息。同时，还有一个<strong>模拟器 (simulator)</strong>，它尝试模拟真实世界中敌手可能观察到的行为，但又不会使用任何真实的秘密信息。</p><p><strong>现实世界（real world）</strong>就是指我们设计和实施密码学协议的环境。现实世界中，协议需要与潜在的攻击者（Adversary）进行交互。</p><p>这两个概念出现在UC（Universally Composable）安全框架中。在UC框架中，如果现实世界的协议能够被证明与理想世界中的理想功能等效，那么我们就可以说该协议是安全的。这意味着，即使在面对现实世界中的攻击者时，协议也能保持与理想功能相同的安全性。</p><p>在理想世界中，既然对手什么也学不到，这就意味着在现实世界中，当对手收到密文时，也什么也学不到。</p><p>原文提到了模拟器必须做的三个任务：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span>It must generate a view for the real adversary that is indistinguishable from its real view;</span><br><span class="line"><span class="bullet">2.</span>It must extract the effective inputs used by the adversary in the execution; and</span><br><span class="line"><span class="bullet">3.</span>It must make the view generated be consistent with the output that is based on this input.</span><br></pre></td></tr></table></figure><p>我们逐个分析一下：</p><ol><li>它必须为真实对手生成一个与其真实视图无法区分的视图。</li></ol><p>这里的“对手的视图”指的是对手通过分析交互过程中获得的信息所构建的关于系统状态的认知。简而言之，就是对手能够观察到的所有信息的集合。</p><ol><li>它必须提取对手在执行过程中使用的有效输入。</li></ol><p>有效输入是指对手为了达到其目的而输入到系统中的数据，这些数据可能会影响系统的行为或输出。</p><ol><li>必须使生成的视图与基于该输入的输出保持一致。</li></ol><p>这意味着模拟器生成的对手视图必须与对手在真实世界中根据其输入所期望的输出相匹配。</p><h1 id="Preliminaries-and-Notation"><a href="#Preliminaries-and-Notation" class="headerlink" title="Preliminaries and Notation"></a>Preliminaries and Notation</h1><p>$S\subseteq {0,1}^<em>$：有限集合 $S$，表示集合S是由0和1组成的所有可能字符串的子集。如果我们有一个集合S，它包含的元素是由0和1组成的字符串，那么这个集合S就可以被认为是${0,1}^</em>$的子集。这里的“有限集合”意味着集合中的元素数量是可数的，也就是说，我们可以数出集合中有多少个元素。</p><p>举几个例子：</p><ul><li>S = {0, 1}：这个集合包含两个元素，分别是字符串”0”和”1”。</li><li>S = {00, 01, 10, 11}：这个集合包含所有长度为2的由0和1组成的字符串。</li><li>S = {ε, 0, 01, 110, 1110}：这个集合包含空字符串ε（表示没有任何字符），以及其他几个由0和1组成的字符串。</li></ul><p>$x\in_R S$：表示 x 在集合 S 上均匀分布。</p><p>具体来说，对于 <strong>{0,1}ⁿ</strong>，这个集合包含了所有可能的长度为 <strong>n</strong> 的二进制字符串。如果我们从这个集合中随机选择一个字符串，每个字符串被选中的概率都是 <strong>1/2ⁿ</strong>，因为总共有 <strong>2ⁿ</strong> 个可能的字符串。</p><p>例如，如果 <strong>n=2</strong>，那么集合 <strong>{0,1}²</strong> 包含以下四个字符串：<strong>00</strong>、<strong>01</strong>、<strong>10</strong> 和 <strong>11</strong>。在均匀分布 <strong>U₂</strong> 下，选择这四个字符串中的任何一个的概率都是相同的，即 <strong>1/4</strong>。</p><p>再比如，如果 <strong>n=3</strong>，那么集合 <strong>{0,1}³</strong> 就包含以下八个字符串：<strong>000</strong>、<strong>001</strong>、<strong>010</strong>、<strong>011</strong>、<strong>100</strong>、<strong>101</strong>、<strong>110</strong> 和 <strong>111</strong>。在均匀分布 <strong>U₃</strong> 下，选择这八个字符串中的任何一个的概率都是相同的，即 <strong>1/8</strong>。</p><p>$\mu(\cdot)$：一个表示概率上可忽略函数</p><p>$p(\cdot)$：正多项式</p><p>$\lambda$：空字符串</p><p><strong>计算不可区分性</strong>（Computational Indistinguishability）：</p><p>概率集合$X={X(a,n)}_{a\in{0,1};n\in N}$是以$a\in{0,1}^*$和$n\in N$为索引的随机变量的无限序列。$a$代表各方的输入，$n$代表安全参数。</p><p>有点抽象，举两个例子：</p><p>假设我们有一个概率实验，它可以产生一个二进制字符串，比如抛硬币序列。对于每个二进制字符串 </p><script type="math/tex; mode=display">a</script><p> 和每个自然数 </p><script type="math/tex; mode=display">n</script><p>，我们定义一个随机变量 </p><script type="math/tex; mode=display">X(a,n)</script><p>它可能代表在这个实验中得到字符串</p><script type="math/tex; mode=display">a</script><p>的概率，或者在</p><script type="math/tex; mode=display">n</script><p>次实验中得到字符串</p><script type="math/tex; mode=display">a</script><p>的次数。</p><p>例如，如果我们抛一枚硬币两次，可能得到的二进制字符串有 </p><script type="math/tex; mode=display">00,01,10,11</script><p>对于每个字符串和每个自然数 </p><script type="math/tex; mode=display">n</script><p>我们可以定义一个随机变量来表示在 </p><script type="math/tex; mode=display">n</script><p> 次实验中得到该字符串的次数。所以，如果我们把 </p><script type="math/tex; mode=display">n</script><p> 设为2，那么 </p><script type="math/tex; mode=display">X(00,2)</script><p> 可能表示在两次实验中都得到正面的次数，</p><script type="math/tex; mode=display">X(01,2)</script><p> 表示得到一次正面一次反面的次数，以此类推。</p><p>让我们考虑一个与天气相关的概率集合的例子。</p><p>假设我们有一个随机变量 $X(a,n)$，其中$a$是一个描述特定天气状况的字符串（例如 “晴天”、“雨天”、“多云” 等），而$n$是一个自然数，表示我们观察这种天气状况的天数。例如，如果我们关注的是 “晴天”，那么$a$就是 “晴天”，而$n$可以是任何自然数，比如 30。那么$X(‘Sunny’,30)$就代表在观察的 30 天内，出现 “晴天” 的天数。这个概率集合$X$就包含了所有这些随机变量的无限序列，每个序列都与一个特定的天气状况和观察天数索引相关联。</p><p>假设有两个这样的概率集合：</p><p>$X={X(a,n)}_{a\in{0,1};n\in N}$</p><p>$Y={Y(a,n)}_{a\in{0,1};n\in N}$</p><p>如果对于每一个非统一多项式时间算法$D$，存在一个可忽略的函数$\mu(\cdot)$，使得对于每一个$a∈{0,1}^*$和每一个$n∈N$，都可以说$X\stackrel{c}{\equiv}Y$在计算上是无差别的，用$X\stackrel{c}{\equiv}Y$表示：</p><script type="math/tex; mode=display">|Pr[D(X(a,n))=1]-Pr[D(Y(a,n))=1] \le \mu(n)|</script><p>原文中强调了：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">All parties are assumed to run in time that is polynomial in the security parameter.</span><br></pre></td></tr></table></figure><p>这段话强调了在设计密码学算法时，需要考虑算法的效率和安全性，确保算法在可接受的时间内运行，同时保持足够的安全性。</p><p><strong>非均匀性（Non-uniformity）</strong>：</p><p>如果对于每一个非均匀多项式时间算法$D$和每一个多项式$p(\cdot)$都存在一个$\N\in N$，使得对于每一个$n &gt; N$ 和每一个$a\in{0,1}^*$都存在一个$\N\in N$，那么$X\stackrel{c}{\equiv}Y$</p><script type="math/tex; mode=display">|Pr[D(X(a,n))=1]-Pr[D(Y(a,n))=1]|<\frac{1}{p(n)}</script><p>在计算机科学和密码学中，<strong>非均匀性</strong>（non-uniformity）指的是算法或计算模型可以访问与输入大小相关的额外信息或建议。这些额外信息通常以“建议字符串”（advice strings）的形式存在，它们不是由算法本身生成的，而是由外部提供。</p><p>非均匀性意味着即使是非均匀的多项式时间算法（也就是可以访问建议字符串的算法），也不能有效地区分两个分布集合。</p><p>这是一种更加强大条件的计算不可区分性。</p><p>此外，原文还给出了另一个极端条件下的式子：</p><p>存在一个$D$和一个多项式$p(\cdot)$，对于无限多个$n$，存在一个$a\in {0,1}^∗$ ，其中</p><script type="math/tex; mode=display">|Pr[D(X(a,n))=1]-Pr[D(Y(a,n))=1]|\ge \frac{1}{p(n)}</script><p>这两个定义看似矛盾，实际上描述了两种极端情况。第一个定义描述了当两个分布是计算不可区分的时候的情况，即没有算法能够有效地区分它们。第二个定义描述了当两个分布是可区分的时候的情况，即存在至少一个算法能够有效地区分它们。这两个定义之间的矛盾表明，计算不可区分性是一个非常强的属性，它要求对于几乎所有的输入大小和建议字符串，都没有算法能够区分两个分布。</p><p>非均匀性算法的例子：</p><p>一个典型的例子是在密码学中的<strong>非一致性敌手模型</strong>（non-uniform adversary model）。在这个模型中，敌手（即攻击者）可以利用一些额外的信息来增强其攻击能力。这些额外的信息可能是之前的攻击经验、特定的密码学结构的弱点，或者是通过某些方式预先计算出的有用信息。</p><p>例如，考虑一个简单的加密方案，其中使用了一个伪随机函数（PRF）来生成密钥。在一个均匀的敌手模型中，敌手只能使用多项式时间的算法来尝试破解密钥。然而，在一个非一致性敌手模型中，敌手可能拥有一个与输入大小相关的建议字符串，这个字符串可能包含了一些关于伪随机函数内部结构的信息，从而使得敌手能够更有效地破解密钥。</p><p>另一个例子是彩虹表攻击（rainbow table attack）。彩虹表是一种预先计算出的数据结构，它可以用来逆向工程哈希函数的输出。在一个非一致性敌手模型中，敌手可以使用彩虹表作为建议字符串，这样他们就可以快速地找到哈希函数的输入，即使哈希函数设计为均匀的算法也无法防止这种攻击。</p><p>虽然非均匀性定义了一个更强大的安全模型，但在实际应用中，密码学算法和协议一般都是均匀性的，以确保它们在广泛的环境和条件下都能安全有效地工作。</p><p>最后一段话还强调了在定义计算不可区分性时，量词的顺序非常重要。正确的定义要求对于所有的$a$，存在一个统一的可以忽略的函数，而不是对于每个$a$都有一个可能不同的可以忽略的函数。这保证了计算不可区分性的定义在密码学中的实用性和强度。</p><h1 id="The-Basic-Paradigm-–-Semantic-Security"><a href="#The-Basic-Paradigm-–-Semantic-Security" class="headerlink" title="The Basic Paradigm – Semantic Security"></a>The Basic Paradigm – Semantic Security</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Nothing is learned about the plaintext from the ciphertext.</span><br></pre></td></tr></table></figure><p>这句话很难形式化，但也是接下来的工作。</p><p>首先，语义安全的定义允许明文的长度取决于安全参数，并允许明文的任意分布，此外，还允许信息的辅助函数$h$存在。</p><p>对手的目的是从密文和所提供的辅助信息中学习明文的某个函数$f$。</p><p>根据该定义，仅从辅助信息（以及明文的长度）而不从密文中学习相同的信息应该是可能的。</p><p>一个私钥加密方案$(G,E,D)$的安全性， 如果对于每个非统一概率多项式时间算法$\mathcal{A}$，存在一个非统一概率多项式时间算法$\mathcal{A}^\prime$，使得对于每个概率集合${X<em>n}</em>{n\in N}$，$|Xn| ≤ poly(n)$，每一对多项式有界函数$f,h ： {0,1}*→{0,1}^∗$，每个正多项式$p(\cdot)$和所有足够大的$n$：</p><script type="math/tex; mode=display">\underset{k\leftarrow G(1^n)}{Pr}[\mathcal{A}(1^n,E_k(X_n),1^{|X_n|},h(1^n,X_n))=f(1^n,X_n)]\lt Pr [\mathcal{A}(1^n,1^{|X_n|},h(1^n,X_n))=f(1^n,X_n)] + \frac{1}{p_n}</script><p>这一段话其实阐明了一个道理：$\mathcal{A}$（在给定密文的情况下）可以知道的任何信息都可以被$\mathcal{A}^\prime$（在不给定密文的情况下）知道。</p><p>从模拟的角度来说，$\mathcal{A}^\prime$就是处在一个理想的世界，因为它所学到的任何东西都只来自辅助信息和明文长度，但是根据定义，我们知道$\mathcal{A}^\prime$和$\mathcal{A}$能学习的东西一样多。</p><p>这里提供了一个基于模拟器的证明过程：</p><p>$Simulator\ \mathcal{A}^\prime$：输入$1^n,1^{|X_n|},h=h(1^n,X_n)$，算法$\mathcal{A}^\prime$如下运行：</p><ol><li>$\mathcal{A}^\prime$运行$G(1^n)$得到密钥$k$</li><li>$\mathcal{A}^\prime$计算$c=E_k(0^{|X_n|})$作为加密垃圾</li><li>$\mathcal{A}^\prime$运行$\mathcal{A}(1^n,c,1^{|X_n|},h)$并且输出$\mathcal{A}$输出的。</li></ol><p>在这个模拟证明中，“垃圾”加密的定义是指一个看起来像有效加密的数据，但实际上是无意义的。这种加密的目的是测试算法 ($\mathcal{A}$) 是否能够区分真正的加密和无意义的加密。如果 ($\mathcal{A}$) 不能区分这两者，那么我们可以说加密算法是安全的，因为即使攻击者得到了加密数据，他们也无法确定它是否包含有用的信息。</p><h1 id="Secure-Computation-–-Simulation-for-Semi-Honest-Adversaries"><a href="#Secure-Computation-–-Simulation-for-Semi-Honest-Adversaries" class="headerlink" title="Secure Computation – Simulation for Semi-Honest Adversaries"></a>Secure Computation – Simulation for Semi-Honest Adversaries</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>在密码学中，<strong>半诚实的敌手</strong>（也称为被动敌手或静态敌手）是指在两方计算中，控制一方的攻击者。这种敌手遵循协议的规定执行所有步骤，但会尝试通过分析它接收到的消息记录和内部状态来获取更多信息。这是一个相对较弱的敌手模型，因为它不会主动破坏协议，只是被动地收集信息。</p><p>半诚实的敌手模型的特点包括：</p><ul><li><strong>静态</strong>：敌手在计算开始时就确定，并且在整个计算过程中控制同一方。</li><li><strong>遵循协议</strong>：敌手精确地按照协议规定的步骤执行，不会做出任何违反规定的行为。</li><li><strong>信息收集</strong>：敌手的目标是通过观察通信过程中的消息来学习额外的信息，而不是直接破坏协议。</li></ul><p>尽管这是一个弱敌手模型，但如果协议能在半诚实敌手的存在下保证安全，那么它至少可以保证没有无意的信息泄露。这种安全性对于那些基本信任对方但又想确保自己的输入不会被记录的场景是足够的。此外，为半诚实敌手设计的安全协议通常是构建更强安全性协议的第一步。</p><h2 id="Defining-Security-for-Semi-Honest-Adversaries"><a href="#Defining-Security-for-Semi-Honest-Adversaries" class="headerlink" title="Defining Security for Semi-Honest Adversaries"></a>Defining Security for Semi-Honest Adversaries</h2><p><strong>两方计算</strong></p><p>两方计算允许两个参与方（通常称为Alice和Bob）协作计算某个函数，而无需泄露各自的输入信息。</p><p>原文这样定义了两方计算：</p><script type="math/tex; mode=display">f:\{0,1\}^* \times \{0,1\}^* \rightarrow \{0,1\}^* \times \{0,1\}^*, where\ f = (f_1, f_2), x,y \in \{0,1\}^n</script><p>其中一方输入$x$，输出$f_1(x,y)$</p><p>另一方输入$y$，输出$f_2(x,y)$</p><p><strong>隐私通过模拟（Privacy by Simulation）</strong></p><p>如果参与协议的一方可以计算的任何内容都只能根据协议的输入和输出来计算，那么该协议就是安全的。</p><p>在这个定义中，模拟器将会被给予参与方一方的输入与输出（之所以是输入与输出，而不仅仅是输入，是因为，我们想要证明的是即使在协议执行过程中，参与方也无法学到任何超出其输入和预定输出之外的信息。为了做到这一点，模拟器需要重现参与方在协议执行中的视图，这包括了它们的输入和它们从协议中获得的输出。）</p><p>值得注意的是，参与计算的双方都是半诚实的。在半诚实模型中，因为参与方遵循协议并使用他们的真实输入，所以输出 ( $f(x,y)$ ) 是可以预先定义的。这意味着模拟器可以被给予 ( $f(x,y)$ ) 这个值来生成参与方的视图，而不需要考虑对手可能的行为。</p><p>与此相反的是，<strong>恶意敌手（malicious adversaries）</strong>。半诚实参与方和恶意敌手的主要区别在于他们对协议的遵守程度。半诚实参与方会遵循协议规则，使用真实的输入，这使得输出是可预测和明确定义的。而恶意敌手可能会违反规则，使用不同的输入，这使得输出不再是固定的，而是取决于敌手的选择。</p><p><strong>Definition of security</strong></p><ul><li>函数$f=(f_1,f_2)$，双方协议$\pi$</li><li>$view_i^\pi(x,y,n)$表示第$i$方执行协议$\pi$的视图，参数为(x,y,n)，其等同于$(w,r^i;m_1^i,…,m_t^i)$，$w\in{x,y}$，$r^i$代表第$i$方的磁带，$m_j^i$代表其收到的第$j$条消息</li><li>第$i$方的输出表示为$output_i^\pi(x,y,n)$，两方的联合输出表示为$output^\pi(x,y,n)=(output_1^\pi(x,y,n),output_2^\pi(x,y,n))$</li></ul><p><strong>Definition 4.1</strong>: $f=(f_1,f_2)$，如果存在概率多项式时间算法$S_1$和$S_2$，我们说协议$\pi$能够安全计算$f$，即使在静态半诚实敌手的情况下：</p><script type="math/tex; mode=display">\{(S_1(1^n,x,f_1(x,y)),f(x,y))\}_{x,y,n}\stackrel{c}{\equiv} \{(view_1^\pi(x,y,n),output^\pi(x,y,n))\}_{x,y,n}\\\{(S_2(1^n,y,f_2(x,y)),f(x,y))\}_{x,y,n}\stackrel{c}{\equiv} \{(view_2^\pi(x,y,n),output^\pi(x,y,n))\}_{x,y,n}</script><p>其中$x,y\in{0,1}^*,|x|=|y|,n\in N$</p><p>模拟器的输出和功能输出$f(x,y) = (f_1(x,y),f_2(x,y))$的联合分布必须与$(view_i^\pi(x,y,n),output^\pi(x,y,n))$不可区分</p><p>现在，我们来考虑一个更简单的安全定义，它只将模拟器生成的分布与对手的观点（而不是联合分布）进行比较：</p><script type="math/tex; mode=display">\{(S_1(1^n,x,f_1(x,y))\}_{x,y,n}\stackrel{c}{\equiv} \{(view_1^\pi(x,y,n)\}_{x,y,n}\\\{(S_2(1^n,x,f_2(x,y))\}_{x,y,n}\stackrel{c}{\equiv} \{(view_2^\pi(x,y,n)\}_{x,y,n}\\</script><p>根据这一定义，上述安全计算双方相同输出的协议是安全的。这是因为每一方的视图都是由$x\bigcup y$的随机样本组成的，而这个视图是可以模拟的。</p><p><strong>A simpler formulation for deterministic functionalities</strong>：</p><p>该定义有两个要求：(a) 正确性，即各方的输出都是正确的；</p><p>(b) 私密性，即各方的观点都可以（单独）模拟。</p><p>从形式上看，正确性要求存在一个可忽略的函数$\mu$，使得对于每个$x,y\in {0,1}^*$和每个$n$，</p><script type="math/tex; mode=display">Pr[output^\pi(x,y,n)\ne f(x,y)]\le \mu(n)</script><p>隐私性要求，存在概率多项式时间算法$S_1,S_2$</p><script type="math/tex; mode=display">\{(S_1(1^n,x,f_1(x,y))\}_{x,y\in\{0,1\}^*;n\in N}\stackrel{c}{\equiv} \{(view_1^\pi(x,y,n)\}_{x,y\in\{0,1\}^*;n\in N}\\\{(S_2(1^n,x,f_2(x,y))\}_{x,y\in\{0,1\}^*;n\in N}\stackrel{c}{\equiv} \{(view_2^\pi(x,y,n)\}_{x,y\in\{0,1\}^*;n\in N}\\</script><p>区分者为了得到集合的索引$x,y$，可以自己计算$f(x,y)$，从而有</p><script type="math/tex; mode=display">\{(S_1(1^n,x,f_1(x,y))\}_{x,y\in\{0,1\}^*;n\in N}\stackrel{c}{\equiv} \{(view_1^\pi(x,y,n)\}_{x,y\in\{0,1\}^*;n\in N}\\\{(S_1(1^n,x,f_1(x,y)),f(x,y))\}_{x,y\in\{0,1\}^*;n\in N}\stackrel{c}{\equiv} \{(view_1^\pi(x,y,n),f(x,y))\}_{x,y\in\{0,1\}^*;n\in N}\\</script><p>正确性要求保证输出$output^\pi(x,y,n)$与$f(x,y)$在计算上无差别，这意味着</p><script type="math/tex; mode=display">\{(view_1^\pi(x,y,n),f(x,y))\}_{x,y\in\{0,1\}^*;n\in N}\stackrel{c}{\equiv} \{(view_1^\pi(x,y,n),output^\pi(x,y,n\}_{x,y\in\{0,1\}^*;n\in N}\\</script><p>因此，我们有：</p><script type="math/tex; mode=display">\{(S_1(1^n,x,f_1(x,y)),f(x,y))\}_{x,y\in\{0,1\}^*;n\in N}\stackrel{c}{\equiv} \{(view_1^\pi(x,y,n),output^\pi(x,y,n\}_{x,y\in\{0,1\}^*;n\in N}\\</script><p><strong>Triviality for semi-honest adversaries</strong></p><p>我们注意到，在半诚信对手的情况下，许多问题都变得微不足道。例如，零知识，“承诺”，抛掷硬币问题</p><p><strong>Auxiliary information</strong></p><p>辅助输入在定义中是隐含的，因为针对非均匀对手的计算不可区分性是必需的，运行协议的对手无需提供任何辅助信息，因为它是半诚实的，因此无论有无辅助输入，都会遵循完全相同的指令。</p><h2 id="Oblivious-Transfer-for-Semi-Honest-Adversaries"><a href="#Oblivious-Transfer-for-Semi-Honest-Adversaries" class="headerlink" title="Oblivious Transfer for Semi-Honest Adversaries"></a>Oblivious Transfer for Semi-Honest Adversaries</h2><p>不经意传输（OT, oblivious transfer）</p><script type="math/tex; mode=display">f((b_0,b_1),\sigma)=(\lambda,b_{\sigma}),where\ b_0,b_1,\sigma\in\{0,1\}</script><p>P1：$(b_0,b_1)$，没有任何输出</p><p>P2：$\sigma$</p><p>抽象地讲，就是A给B发消息，A却不知道B收到的是啥，一般的思路就是A要多发一些消息然后让B去选择有需要的，如果是这样的话，同时还应该保证B不会多知道他本不应该知道的消息。</p><p>增强型陷门排列（enhanced trapdoor permutations）：一种特殊的双射函数，随机取样的函数很难在随机取样值上反转，然而存在一个陷门，可以在给定情况下有效反转。</p><p>陷门排列集合是${f<em>\alpha}</em>\alpha$的集合，包括四个概率多项式函数$I,S,F,F^{-1}$</p><p>$I(1^n)$：随机选取n比特下标为$\alpha$的排列$f_\alpha$</p><p>$I(1^n)$ selects a random n-bit index $\alpha$ of a permutation $f_\alpha$ along with a corresponding trap door $\tau$. Denote by $I_1(1^n)$ the $\alpha$-part of the output.</p><p>$S(\alpha)$：随机采样$S(\alpha;r)$</p><p>$F(\alpha,x)=f_\alpha(x)$</p><p>$F^{-1}(\tau,y)=f_\alpha^{-1}(y)$</p><p>加强陷门排列：</p><script type="math/tex; mode=display">Pr[\mathcal{A}(1^n,\alpha,r)=f_\alpha^{-1}(S(\alpha;r))]\le \mu(n)</script><p>敌手$\mathcal{A}$将拥有$\alpha,r$，可以计算$y=S(\alpha;r)$，其主要目的是反转$y$</p><p>硬核谓词$B$</p><script type="math/tex; mode=display">Pr[\mathcal{A}(1^n,\alpha,r)=B(\alpha,f_\alpha^{-1}(S(\alpha;r)))]\le \frac{1}{2}+\mu(n)</script><p>前一个公式表示敌手逆转的可能微乎其微，后一个公式表示敌手逆转后，判断自己的结果是否正确与猜测（$\frac{1}{2}$）无异</p><p>Then, the family is a collection of enhanced trapdoor permutations if for every non-uniform probabilistic polynomial time adversary $\mathcal{A}$ there exists a negligible function $\mu$ such that for every $n$</p><p>$Pr[\mathcal{A}(1^n,\alpha,r)=f_\alpha^{-1}(S(\alpha;r))]\le \mu(n)$</p><p>where $\alpha \leftarrow I_1(1^n)$ and $r\in_R{0,1}^n$ is random. Observe that given $\alpha$ and $r$, A can compute $y=S(\alpha,r)$. Thus, $\mathcal{A}$’s task is to invert $y$, when it is also given the random coins used by $S$ to sample $y$.</p><p>We will also refer to a hard-core predicate $B$ of a family of enhanced trapdoor permutations. We say that $B$ is a hard-core predicate of $(I,S,F,F^{-1})$ if for every non-uniform probabilistic-polynomial time adversary $\mathcal{A}$ there exists a negligible function $\mu$ such that for every $n$:</p><p>$Pr[\mathcal{A}(1^n,\alpha,r)=B(\alpha,f_\alpha^{-1}(S(\alpha;r)))]\le \frac{1}{2}+\mu(n)$</p><p>所谓的predicate，就是一个值域为${0,1}$的函数</p><p>不经意传输的步骤：</p><p><strong>Inputs:</strong>$P_1:b_0,b_1\in{0,1};P_2:\sigma \in{0,1},(I,S,F,F^{-1})$</p><p><strong>Protocol:</strong></p><ol><li>$P_1$运行$I(1^n)$得到$(\alpha,\tau)$，把$\alpha$发送给$P_2$</li><li>$P<em>2$运行$S(\alpha)$两次，得到$x</em>\sigma,y<em>{1-\sigma}$，计算$y</em>\sigma=F(\alpha,x<em>\sigma)=f</em>{\alpha}(x_\sigma)$，发送$y_0,y_1$给$P_1$</li><li>$P<em>1$计算$x_0=F^{-1}(\alpha,y_0)=f</em>{\alpha}^{-1}(y<em>0),x_1=F^{-1}(\alpha,y_1)=f</em>\alpha^{-1}(y_1)$</li></ol><p>计算掩码$\beta_0=B(\alpha,x_0)\oplus b_0,\beta_1=B(\alpha,x_1)\oplus b_1$</p><p>$P_1$发送$(\beta_0,\beta_1)$给$P_2$</p><ol><li>$P<em>2$计算$b</em>\sigma=B(\alpha,x<em>\sigma)\oplus\beta</em>\sigma$</li></ol><p><strong>Theorem</strong></p><p>Assume that $(I,S,F,F^{-1})$ constitutes a family of enhanced trapdoor permutations with a hard-core predicate $B$. Then, Protocol  securely computes the functionality $f((b<em>0,b_1),σ) = (λ,b</em>σ)$ in the presence of static semi-honest adversaries.</p><p><strong>Proof</strong></p><p>模拟器：$S_1,S_2$</p><p>首先考虑 P1 被破坏的情况。</p><p>$P_1$没有输出，因此我们只需要证明模拟器可以生成$P_1$收到的传入信息的视图。协议中，$P_1$输入$(y_0,y_1)$，$S_1$输入$(b_0,b_1,1^n)$并按照以下步骤工作：</p><ol><li>$S_1$为$P_1$选择一个均匀分布的随机磁带$r$（比特序列）</li><li>$S_1$运行$(\alpha,\tau)\leftarrow I(1^n;r)$</li><li>$S_1$运行$S(\alpha)$两次，采样值分别为$y_0,_1$</li><li>$S_1$输出$((b_0,b_1),r;(y_0,y_1))$</li></ol><p>由于$S_1$不知道$P_2$的输入$\sigma$，因此无法像诚实的$P_2$那样对$y_0,y_1$进行采样。尽管如此，根据陷阱门排列集合的定义，$S(\alpha)$输出的值几乎均匀分布在$f(\alpha)$的域（域等于范围，因为它是排列）中。根据定义，$F(α,S(α))$ 的分布在统计上接近于 $S(α)$ 的分布。这意味着：</p><script type="math/tex; mode=display">{(F(\alpha,x_0),y_1)}\stackrel{c}{\equiv}{(y_0,y_1)}\stackrel{c}{\equiv}{(y_0,F(\alpha,x_1))}</script><p>其中 $a \in I$，$x_0,x_1,y_0,y_1$都是$S(\alpha)$的采样</p><p>当$P_2$的输入为$\sigma = 0$时，$P_1$看到的正是一对$(F(\alpha,x_0),y_1)$</p><p>$(y_0,y_1)$是模拟器生成的视图</p><p>当$P_2$的输入为$\sigma = 1$时，$P_1$看到的正是一对$(y_0,F(\alpha,x_1))$</p><p>因此，对于每一个$\sigma \in {0,1}$</p><script type="math/tex; mode=display">\{S_1(1^n,(b_0,b_1))\}\stackrel{c}{\equiv}\{view_1^\pi((b_0,b_1),\sigma)\}</script><p>接下来，我们讨论$P_2$被破坏的情况。</p><p>我们需要构建一个视图，使该视图定义的输出等同于协议的真实输出。$S<em>2$接收$P_2$的输入和输出，因此能够实现上述功能。在本协议中，实现这一点的方法是让 S2 设置$\beta</em>\sigma=B(\alpha,x<em>\sigma)\oplus b</em>\sigma$，就像真正的$P<em>1$一样。相比之下，$S_2$无法正确计算 $\beta</em>{1-\sigma}$</p><p>$S<em>2$的输入包括$1^n$和$P_2$的输入和输出$(\sigma,b</em>\sigma)$</p><ol><li>为保证随机性，$S_2$ 运行$S(\alpha)$两次</li><li>$S_2$运行$I(1^n)$得到$(\alpha,\tau)$</li><li>$S<em>2$计算$s</em>\sigma=S(\alpha;r<em>\sigma),y</em>{1-\sigma}=S(\alpha;r<em>{1-\sigma}),x</em>{1-\sigma}=F^{-1}(\tau,y_{1-\sigma})$</li><li>$S<em>2$计算$\beta</em>\sigma=B(\alpha,x<em>\sigma)\oplus b</em>\sigma$，其中$b_\sigma$来自于$P_2$的输出</li><li>$S<em>2$计算$\beta</em>{1-\sigma}=B(\alpha,x_{1-\sigma})$</li><li>$S_2$输出$(\sigma,r_0,r_1;\alpha,(\beta_0,\beta_1))$</li></ol><p>如果把$\sigma$放在第一位，那么$P_2$的视图可以写作：</p><script type="math/tex; mode=display">view_2^\pi((b_0,b_1),\sigma)= (\sigma,r_0,r_1;\alpha,(B(\alpha,x_{1-\sigma})\oplus b_{1-\sigma}))</script><p>模拟器的输出会被写作：</p><script type="math/tex; mode=display">S_2(1^n,\sigma,b_{\sigma})=(\sigma,r_0,r_1;\alpha,(B(\alpha,x_\sigma)\oplus b_\sigma,B(\alpha,x_{1-\sigma})))</script><p>当$b<em>{1-\sigma}=0$时，对于每一个$\sigma,b</em>\sigma \in{0,1}$和每一个$n$：</p><script type="math/tex; mode=display">S_2(1^n,\sigma,b_{\sigma}) \equiv \{view_2^\pi((b_0,b_1),\sigma)\}</script><p>因此，我么们只需要证明在$b<em>{1-\sigma}=1$的情况下，$view$是不可区分的，二者的唯一区别在于$\beta</em>{1-\sigma}=B(\alpha,x<em>{1-\sigma})$, or $\beta</em>{1-\sigma}=B(\alpha,x<em>{1-\sigma})\oplus 1$，因此，我们需要证明$\sigma, b</em>\sigma\in{0,1}$：</p><script type="math/tex; mode=display">\{(\sigma,r_0,r_1;\alpha,(B(\alpha,x_\sigma)\oplus b_\sigma,B(\alpha,x_{1-\sigma})))\} \stackrel{c}{\equiv} \\\{(\sigma,r_0,r_1;\alpha,(B(\alpha,x_\sigma)\oplus b_\sigma,B(\alpha,x_{1-\sigma})\oplus 1))\}</script><p>这个式子的左边是$S<em>2$生成的分布，式子的右边是$b</em>{1-\sigma}$所处的真实世界。</p><p>假设存在一个非统一概率多项式时间区分器$D$、一个多项式$p(\cdot)$和一个无穷序列的元组$(\sigma,b_\sigma,n)$，使得</p><script type="math/tex; mode=display">Pr[D(\sigma,r_0,r_1;\alpha,(B(\alpha,x_\sigma)\oplus b_\sigma,B(\alpha,x_{1-\sigma})))=1]\\-Pr[D(\sigma,r_0,r_1;\alpha,(B(\alpha,x_\sigma)\oplus b_\sigma,B(\alpha,x_{1-\sigma})\oplus 1))=1]\\\ge \frac{1}{p(n)}</script><p>在不失一般性的前提下，我们假设对于无穷多个$n$，$D$在接收到$B(\alpha,x_1-\sigma)$时输出 1 的概率大于或等于接收到$B(\alpha,x_1-\sigma)\oplus 1$时输出 1 的概率</p><p>我们构建一个算法$\mathcal{A}$</p><p>$\mathcal{A}$的输入包括$\sigma,b<em>\sigma,(1^n,\alpha,r)$，其目标是猜出$B(\alpha,f</em>\alpha^{-1}(S(\alpha;r)))$</p><p>首先通过设置$r<em>{1-\alpha}=r$，计算出$x</em>{1-\alpha}=f_\alpha^{-1}(S(\alpha;r))$</p><p>接下来$\mathcal{A}$选取一个随机值$r<em>\sigma$并且计算$x</em>\sigma=S(\alpha;r<em>\sigma),\beta</em>\sigma=B(\alpha,x<em>\sigma)\oplus b</em>\sigma$</p><p>最后$\mathcal{A}$选取随机值$\beta<em>{1-\sigma}$，输入$(\sigma,r_0,r_1;\alpha,(\beta</em>\sigma,\beta<em>{1-\sigma}))$进算法$D$中，并且输出$\beta</em>{1-\sigma}$如果$D$输出1，否则输出$1-\beta_{1-\sigma}$</p><p>观察到，如果$\mathcal{A}$正确地猜出$\beta<em>{1-\sigma}$，那么就会在$D$上输入$(\sigma,r_0,r_1;\alpha,(B(\alpha,x</em>\sigma)\oplus b<em>\sigma,B(\alpha,x</em>{1-\sigma})))$，否则会在$D$上输入$(\sigma,r<em>0,r_1;\alpha,(B(\alpha,x</em>\sigma)\oplus b<em>\sigma,B(\alpha,x</em>{1-\sigma})\oplus 1))$</p><p>因此，如果$\mathcal{D}$输出1，可以认为$\mathcal{A}$猜对了$\beta_{1-\sigma}$</p><p> Algorithm $\mathcal{A}$ is given $\sigma,b<em>\sigma$ on its advice tape, and receives $(1^n,\alpha,r)$ for input. $\mathcal{A}$’s aim is to guess $B(\alpha,f</em>\alpha^{-1}(S(\alpha;r)))$. In order to do this, implicitly and without knowing its actual value,  $\mathcal{A}$ sets $x<em>{1-\alpha}=f</em>\alpha^{-1}(S(\alpha;r))$ by setting $r<em>{1-\alpha}=r$ (from its input).  Next, algorithm $\mathcal{A}$ chooses a random $r</em>\sigma$, and computes $x<em>\sigma=S(\alpha;r</em>\sigma),\beta<em>\sigma=B(\alpha,x</em>\sigma)\oplus b<em>\sigma$. Finally $\mathcal{A}$ chooses a random $\beta</em>{1-\sigma}$, invokes $D$ on input $(\sigma,r<em>0,r_1;\alpha,(\beta</em>\sigma,\beta<em>{1-\sigma}))$ and outputs $\beta</em>{1-\sigma}$ if $D$ outputs 1, otherwise outputs $1-\beta<em>{1-\sigma}$. Observe that if $\mathcal{A}$ correctly guesses $\beta</em>{1-\sigma}$, then it invokes $D$ on $(\sigma,r<em>0,r_1;\alpha,(B(\alpha,x</em>\sigma)\oplus b<em>\sigma,B(\alpha,x</em>{1-\sigma}))$, otherwise it invokes $D$ on $(\sigma,r<em>0,r_1;\alpha,(B(\alpha,x</em>\sigma)\oplus b<em>\sigma,B(\alpha,x</em>{1-\sigma})\oplus 1))$ . Thus, if $D$ outputs 1, then $\mathcal{A}$ assumes that it guessed β1−σ correctly </p><p>设置$x=x_{1-\sigma}$，我们有：</p><script type="math/tex; mode=display">Pr[\mathcal{A}(1^n,\alpha,r)=B(\alpha,x)] \\=\frac{1}{2}\cdot Pr[\mathcal{A}(1^n,\alpha,r)=B(\alpha,x) | \beta_{1-\sigma}=B(\alpha,x)]\\+ \frac{1}{2}\cdot Pr[\mathcal{A}(1^n,\alpha,r)=B(\alpha,x) | \beta_{1-\sigma}\ne B(\alpha,x)]\\=\frac{1}{2}\cdot Pr[D(\sigma,r_0,r_1;\alpha,(B(\alpha,x_\sigma)\oplus b_\sigma,B(\alpha,x_{1-\sigma})))=1]\\+ \frac{1}{2}\cdot Pr[D(\sigma,r_0,r_1;\alpha,(B(\alpha,x_\sigma)\oplus b_\sigma,B(\alpha,x_{1-\sigma})\oplus 1))=0] \\= \frac{1}{2}\cdot Pr[D(\sigma,r_0,r_1;\alpha,(B(\alpha,x_\sigma)\oplus b_\sigma,B(\alpha,x_{1-\sigma})))=1] \\+ \frac{1}{2}\cdot (1-Pr[D(\sigma,r_0,r_1;\alpha,(B(\alpha,x_\sigma)\oplus b_\sigma,B(\alpha,x_{1-\sigma})\oplus 1))=1])\\=\frac{1}{2} + \frac{1}{2}\cdot Pr[D(\sigma,r_0,r_1;\alpha,(B(\alpha,x_\sigma)\oplus b_\sigma,B(\alpha,x_{1-\sigma})))=1]\\-\frac{1}{2}\cdot Pr[D(\sigma,r_0,r_1;\alpha,(B(\alpha,x_\sigma)\oplus b_\sigma,B(\alpha,x_{1-\sigma})\oplus 1))=1]\\\ge \frac{1}{2} + \frac{1}{2p(n)}</script><p>因此，可以说$S_2$的输出与$P_2$在实际执行中的视图在计算上是无差别的。</p><p><strong>Discussion</strong>这个协议是一个很好的例子，说明了在半诚实对手存在的情况下，如果被破坏的一方行为不完全诚实，那么安全性就得不到任何保证。如果$P_2$通过选择$x_0,x_1$并计算$y_0 = F(\alpha,x_0), y_1 = F(\alpha,x_1)$来生成 $y_0,y_1$，那么它将同时学习到$b0,b1$。$P_1$根本无法检测到这一点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;strong&gt;How To Simulate It – A Tutorial on the Simulation Proof Technique&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本</summary>
      
    
    
    
    <category term="密码学基础" scheme="http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="密码学基础" scheme="http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>随机数</title>
    <link href="http://example.com/posts/7c9eec8d.html"/>
    <id>http://example.com/posts/7c9eec8d.html</id>
    <published>2023-10-20T08:28:28.000Z</published>
    <updated>2024-05-13T08:15:09.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="安全随机数生成"><a href="#安全随机数生成" class="headerlink" title="安全随机数生成"></a>安全随机数生成</h1><p>在密码学中，随机性是不可或缺的一个角色。许多密码学算法都要求使用一个不可预测的随机数，只有在生成的随机数不可预测时，这些算法才可以保证足够的安全性。例如MAC 算法中的 key，ElGamal，ECC算法的k。</p><p>另外许多高性能算法如快速排序，布隆过滤器都依赖于随机性，如果随机性可以被预测，或者能够找到特定的输入值使这些算法变慢，那么黑客就有攻击可循。</p><h1 id="python随机数"><a href="#python随机数" class="headerlink" title="python随机数"></a>python随机数</h1><p>在python中最简单方便的是使用random生成随机数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#需要的库</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="comment">#random.randint(a,b) 在[a,b]内生成随机数</span></span><br><span class="line">random.randint(<span class="number">1</span>,<span class="number">50</span>)<span class="comment">#随机生成最小值为1，最大值为50的整数（可以等于上下限）</span></span><br><span class="line">random.randint(<span class="number">20</span>, <span class="number">20</span>)  <span class="comment">#上下限一样时结果永远是20 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#random.randrange(a, b), random.randrange([start], stop[, step]), [a,b)</span></span><br><span class="line">random.randrange(<span class="number">0</span>, <span class="number">101</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#0-1之间的随机浮点数</span></span><br><span class="line">random.random() <span class="comment">#用于生成一个0到1的随机符点数: 0 &lt;= n &lt; 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#随机浮点数：random.uniform(a, b)</span></span><br><span class="line">random.uniform(<span class="number">1</span>, <span class="number">10</span>)  <span class="comment">#随机生成1到10之间的浮点数，可等于1或10</span></span><br><span class="line">random.uniform(<span class="number">10</span>, <span class="number">1</span>)  <span class="comment">#随机生成1到10之间的浮点数，可等于1或10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但很显然，这种随机数生成的方式并不安全。</p><h1 id="PRNG-伪随机数生成器"><a href="#PRNG-伪随机数生成器" class="headerlink" title="PRNG 伪随机数生成器"></a>PRNG 伪随机数生成器</h1><p>Pseudo-Random Number Generators(PRNG) 是一种数字序列的生成算法，它生成出的数字序列的统计学属性跟真正的随机数序列非常相似，但它生成的伪随机数序列并不是真正的随机数序列！因为该序列完全依赖于提供给 PRNG 的初始值，这个值被称为 PRNG 的种子。</p><p>PRNG的算法流程如下，每次迭代都会生成一个新的伪随机数。</p><p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202310201730008.png" alt="image-20231020173009855"></p><p>实际上目前也有所谓的「硬件随机数生成器 TRNG」能生成出真正的随机数，但是因为 PRNG 的高速、低成本、可复现等原因，它仍然被大量使用在现代软件开发中。</p><p>PRNG 的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hmac, hashlib</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">random_number_generator</span>(<span class="params">seed: <span class="built_in">bytes</span>, max_num: <span class="built_in">int</span></span>):</span><br><span class="line">  state = seed</span><br><span class="line">  counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    state = hmac.new(state, <span class="built_in">bytes</span>(counter), hashlib.sha1).digest()    </span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里取余实际上是压缩了信息，某种程度上说，这可以保证内部的真实状态 state 不被逆向出来</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">int</span>.from_bytes(state, byteorder=<span class="string">&quot;big&quot;</span>) % max_num</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试下，计算 20 个 100 以内的随机数</span></span><br><span class="line">gen = random_number_generator(<span class="string">b&quot;abc&quot;</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>([<span class="built_in">next</span>(gen) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)])</span><br></pre></td></tr></table></figure><p>如果初始的 PRNG 种子是完全不可预测的，PRNG 就能保证整个随机序列都不可预测。</p><p>因此在 PRNG 中，生成出一个足够随机的种子，就变得非常重要了。</p><h1 id="CSPRNG"><a href="#CSPRNG" class="headerlink" title="CSPRNG"></a>CSPRNG</h1><p>Cryptography Secure Random Number Generators(CSPRNG) 是一种适用于密码学领域的 PRNG，一个 PRNG 如果能够具备如下两个条件，它就是一个 CSPRNG:</p><ul><li>能通过「下一比特测试 next-bit test」：即使有人获知了该 PRNG 的 k 位，他也无法使用合理的资源预测第 k+1 位的值</li><li>如果攻击者猜出了 PRNG 的内部状态或该状态因某种原因而泄漏，攻击者也无法重建出内部状态泄漏之前生成的所有随机数</li></ul><p>有许多的设计都被证明可以用于构造一个 CSPRNG:</p><ul><li>基于计数器(CTR)模式下的<strong>安全<a href="https://zh.wikipedia.org/wiki/分组密码">分组密码</a></strong>、<strong><a href="https://zh.wikipedia.org/wiki/流密码">流密码</a>\</strong>或*<em>安全散列函数*</em>的 CSPRNG</li><li>基于数论设计的 CSPRNG，它依靠整数分解问题（IFP）、离散对数问题（DLP）或椭圆曲线离散对数问题（ECDLP）的高难度来确保安全性</li><li>CSPRNG 基于加密安全随机性的特殊设计，例如 Yarrow algorithm 和 Fortuna，这俩分别被用于 MacOS 和 FreeBSD.</li></ul><p>大多数的 CSPRNG 结合使用来自 OS 的熵与高质量的 PRNG，并且一旦系统生成了新的熵（这可能来自用户输入、磁盘 IO、系统中断、或者硬件 RNG），CSPRNG 会立即使用新的熵来作为 PRNG 新的种子。 这种不断重置 PRNG 种子的行为，使随机数变得非常难以预测。</p><p>python中可以使用secrets模块来实现CSPRNG</p><p>secrets模块：</p><p>python的<code>secrets</code>库是在Python 3.6中引入的，它提供了生成加密安全随机数的函数。其中包括下面的几个函数：</p><ul><li><code>secrets.token_bytes(nbytes=None)</code>：返回一个指定长度的随机字节数组。</li><li><code>secrets.token_hex(nbytes=None)</code>：返回一个指定长度的随机十六进制数字符串。</li><li><code>secrets.token_urlsafe(nbytes=None)</code>：返回一个指定长度的随机URL安全的Base64编码字符串，去掉了’=’字符。</li></ul><p>这些函数的实现使用的是安全的随机数发生器，因此生成的随机数可以用于密码学应用程序等需要高安全性的场合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成一个指定长度的随机十六进制数字符串</span></span><br><span class="line"><span class="keyword">import</span> secrets</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(secrets.token_hex(<span class="number">16</span>))  <span class="comment"># 生成一个16字节的随机十六进制数字符串</span></span><br></pre></td></tr></table></figure><p>使用 Python 实现一个简单但足够安全的随机密码生成器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> secrets</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义密码生成函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_password</span>(<span class="params">length: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="comment"># 定义所有可用的字符集合</span></span><br><span class="line">    alphabet = string.ascii_letters + string.digits + string.punctuation</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 secrets 模块生成随机密码</span></span><br><span class="line">    password = <span class="string">&#x27;&#x27;</span>.join(secrets.choice(alphabet) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> password</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数生成密码</span></span><br><span class="line">password = generate_password(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(password)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;安全随机数生成&quot;&gt;&lt;a href=&quot;#安全随机数生成&quot; class=&quot;headerlink&quot; title=&quot;安全随机数生成&quot;&gt;&lt;/a&gt;安全随机数生成&lt;/h1&gt;&lt;p&gt;在密码学</summary>
      
    
    
    
    <category term="密码学基础" scheme="http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="密码学基础" scheme="http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>拜占庭将军问题</title>
    <link href="http://example.com/posts/5e173025.html"/>
    <id>http://example.com/posts/5e173025.html</id>
    <published>2023-10-16T11:28:04.000Z</published>
    <updated>2023-12-06T07:07:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>拜占庭将军问题(The Byzantine Generals Problem)提供了对<strong>分布式共识问题</strong>的一种情景化描述, 由Leslie Lamport等人在1982年首次发表。</p><p><strong>问题描述</strong></p><p>拜占庭将军问题是一个协议问题，<a href="https://baike.baidu.com/item/拜占庭帝国/475514?fromModule=lemma_inlink">拜占庭帝国</a>军队的将军们必须全体一致的决定是否攻击某一支敌军。问题是这些将军在地理上是分隔开来的，并且将军中存在叛徒。叛徒可以任意行动以达到以下目标：欺骗某些将军采取进攻行动；促成一个不是所有将军都同意的决定，如当将军们不希望进攻时促成进攻行动；或者迷惑某些将军，使他们无法做出决定。如果叛徒达到了这些目的之一，则任何攻击行动的结果都是注定要失败的，只有完全达成一致的努力才能获得胜利。</p><p>内涵：在缺少可信任的中央节点和可信任的通道的情况下，分布在网络中的各个节点应如何达成共识。</p><p>当前研究的结论是：<strong>如果叛徒的数量大于或等于1/3，拜占庭问题不可解。</strong></p><p><strong>2个将军的情况</strong></p><p>当两个将军在攻击同一个敌人的时候，一个人被认为是领导，而另一个被认为是跟随着。单一的将军无法打败敌人，因此，两人必须要合作。</p><p>为了两军的沟通和决定作战时间，将军1号必须要派遣一个信使穿过敌人的营地去把攻击时间告诉将军2号。但是，信使可能会被敌人抓住因而信息无法传到友军。那会导致将军1号发起攻击时，将军2号和他的军队还呆在原地。</p><p>即使2号收到了信息，也需要派遣一个信使回去告诉1号，这可能重复被抓的情况。这样有可能无限延伸ACK，两位将军无法达成一致。</p><p>事实上，两个将军问题已被证实无解。<a href="https://en.wikipedia.org/wiki/Two_Generals%27_Problem#Proof">https://en.wikipedia.org/wiki/Two_Generals%27_Problem#Proof</a></p><p><strong>4个将军的情况</strong></p><p>假设4个将军（ABCD）中最多只有1个背叛者。</p><p>（1）假设A将军分别告诉B、C、D将军，下午1点发起进攻。假设B、C、D中有一人是叛徒。那么，到了下午1点，将有三个将军发起进攻，同时他们能发现发现没有参与进攻的将军是叛徒。在这种情况中，对任务执行没有影响。</p><p>（2）假设如果A是背叛的，A分别告诉B、C、D将军在下午1点、2点、3点发起进攻。于是，到了下午，B、C、D三个将军分别去进攻，都失败了。这种情况下，对任务是毁灭性打击。</p><p>为了防止毁灭性失败的情况，1999年，出现了著名的PBFT算法，拜占庭容错算法，提出：对于每一个收到命令的将军，都要去询问其他人，他们收到的命令是什么。</p><p>对于第（1）种情况，假设B,C,D中只有一个叛徒（因为叛徒的数量不能大于1/3），假设B是叛徒。在A告诉B,C,D下午1点的进攻时间后，BCD中会再次有信息交互，将各自收到的信息告诉另外两人。此时不管B发出的时间是多少，C和D两人之中都会得到至少两个是1点的消息。管怎么样，C和D都能放心执行1点进攻的命令。</p><p>对于第（2）种情况，A是背叛者的情况，在A告诉B、C、D三个不同的时间之后，B、C、D三人之间会有一次信息交互，它们会分别把自己收到的信息告诉给另外两人。</p><p>B会收到【1点（来自A），2点（来自C），3点（来自D）】三个不同的时间</p><p>C同样会收到三个不同的时间【1点（来自B），2点（来自A），3点（来自D）】</p><p>以及D会收到【1点（来自B），2点（来自C），3点（来自A）】。</p><p>此时，叛徒数量不超过1/3，可以判断A是叛徒。</p><p><strong>3个将军的情况</strong></p><p>此时叛徒数量达到1/3，3个将军A、B、C，其中一人是叛徒。假设将军A发出进攻命令“下午1点进攻”，B或C其中一人是叛徒。假设B是叛徒，他可能告诉C，他收到的是“下午两点进攻”的命令。这时C收到一个“下午一点进攻”，一个“下午两点进攻“，因此C不能判断谁是叛徒，也不能判断真正的进攻时间。 另一种情况是，如果A是叛徒，告诉B“在下午1点进攻”，告诉C“在下午2点进攻”。当B告诉C，他收到“在下午1点进攻”的命令时，C收到的是“在下午两点进攻”的命令，同样无法判断进攻的时间和真正的叛徒。 从上面的例子可以看出，在只有三个将军的系统中，只要有一个是叛徒，也即1/3，拜占庭问题便不可解。</p><p>针对拜占庭将军问题的解决办法包括：口头协议算法，书面协议算法</p><p>口头协议算法：要求每个被发送的消息都能被正确投递，信息接收者知道消息的发送者身份，知道缺少的消息信息。此时，若叛徒数少于1/3，则拜占庭将军问题可解。但该算法不可追根溯源。</p><p>书面协议算法：该算法要求签名不可伪造，一旦被篡改即可发现，同时任何人都可以验证签名的可靠性。该算法没有考虑信息传输时延，其签名体系难以实现且签名消息记录的保存难以摆脱中心化结构。</p><p><strong>区块链的一致性</strong></p><p>我们可以将每一个比特币交易账号看作一个将军，这些账号分布在世界各地，无法聚在一起，很可能会有恶意账号，账号之间的沟通也很可能因为机器坏了、网络断了、黑客攻击等受到破坏，并且有关账号是不是要支付、具体支付多少的讨论也会浪费很多时间。</p><p>为此，区块链引入POW共识算法，通过工作量证明，增加了发送信息的成本，降低节点发送消息速率，使得一次只有一个用户可以发出消息；同时在广播时会附上自己的签名。</p><p>A向BCD发起提议，BCD看到A签名后的提议书，在验证过后，就会同意进攻提议，而不会发起自己新的进攻提议；如果其中发现错误，才会发起自己的进攻提议。</p><p>从区块链的角度描述：当一个矿工打包出一个区块之后，其他节点会对这个区块进行验证。如果验证通过，则表明已经有节点发布新区块成功，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;拜占庭将军问题(The Byzantine Generals Problem)提供了对&lt;strong&gt;分布式共识问题&lt;/strong&gt;的一种情景化描述, 由Leslie Lamport等人在1982年首次发表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/p</summary>
      
    
    
    
    <category term="区块链" scheme="http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链" scheme="http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>智能设备配对</title>
    <link href="http://example.com/posts/642886bd.html"/>
    <id>http://example.com/posts/642886bd.html</id>
    <published>2023-10-16T10:58:02.000Z</published>
    <updated>2023-12-21T11:39:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们分别从熵源和所使用的加密基元两个方面来讨论智能物联网设备配对。</p><p><strong>熵源</strong> </p><p>考虑到熵源，目前人们最感兴趣的是加速和声音。</p><p>基于加速度的配对使用移动设备上的加速度传感器来检测两个设备之间的物理接触。有一些方案提出提取步态中的加速度作为上下文。步态是利用人体运动时的姿势和动作特征记录下来的。还有一些方案提出利用人体运动提取有效指纹，这些方案通常在可穿戴设备上实现。还有一些方案提出利用运动过程中的加速度（例如汽车内部环境）提取有效熵，有文章已经成功地在道路上行驶的汽车内通过传感器融合实现了设备配对。然而，这些方案要求设备处于移动环境中，这对配对条件的要求很高。</p><p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202312211935080.png" alt="image-20231221193530029"></p><p>声音在生活中无处不在，大多数智能设备都配备了麦克风和话筒，从而具备了播放和录制声音的能力。一些方案关注环境中的噪声并提取指纹序列，等方案提出录制自然噪声进行匹配，但环境声音的随机性在实际过程中带来了较长的匹配时间。随后，提出通过在法定边界内添加额外声源来增强环境声音，并给出了一种基于时域的音频指纹提取方法。近年来，也有人提出在智能家居环境中通过人声来实现智能设备的配对。提出麦克风可以很好地识别人声，并提到了人声的特征。</p><p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202312211938677.png" alt="image-20231221193847596"></p><p><strong>加密原语</strong></p><p>在以往的工作中，设备配对方案依赖于模糊承诺加密原语，在于从有限个正确点中恢复密钥。</p><p>具体来说，设备 ${D<em>i}$ 选择密钥 $K$ 和指纹 $f$，发送承诺 $c \xleftarrow{} ECC.encode(K) \oplus f$ 给 ${D</em>{1-i}}$。当指纹错误在纠错码（ECC）的纠错能力范围内时，$D_{1-i}$ 就能通过 $K \xleftarrow{}.ECC.decode(c\oplus f^\prime)$ 恢复密钥。提出了一种基于fPAKE协议的多传感器融合配对方案，在方案执行初期，需要重复运行PAKE至少$f$次，以放大指纹位熵，实现$f_i\xrightarrow{}K_i$ 并发送承诺 $com \xleftarrow{} ECC.encode(s)oplus K_i$。但这在初始阶段会耗费大量时间。</p><p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202312211939931.png" alt="image-20231221193905895"></p><p>为了克服这个缺点，FS2M 使用了一种叫做非对称模糊封装机制（Asymmetric Fuzzy Encapsulation Mechanism）的加密原语，并给出了一种基于椭圆曲线加密法（Elliptic Curve Cryptography）的方法。我们的协议发送一个模糊承诺 $Enc(Keygen(sk<em>i),s) \xrightarrow{} c$，持有相似指纹 $f</em>{1-i}(sk<em>{1-i})$ 的设备能够通过 $Dec(Keygen(sk</em>{1-i}),c) \xrightarrow{} s$ 正确解密这个承诺。这种应用于设备配对的协议是单轮高效且安全的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们分别从熵源和所使用的加密基元两个方面来讨论智能物联网设备配对。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;熵源&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;考虑到熵源，目前人们最感兴趣的是加速和声音。&lt;/p&gt;
&lt;p&gt;基于加速度的配对使用移动设备上的加速度传感器来检测两个设备之间的物理接触。有</summary>
      
    
    
    
    <category term="iot" scheme="http://example.com/categories/iot/"/>
    
    
    <category term="iot" scheme="http://example.com/tags/iot/"/>
    
  </entry>
  
  <entry>
    <title>关于评价指标</title>
    <link href="http://example.com/posts/58c2e786.html"/>
    <id>http://example.com/posts/58c2e786.html</id>
    <published>2023-10-10T11:09:13.000Z</published>
    <updated>2023-10-10T11:44:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于评价指标"><a href="#关于评价指标" class="headerlink" title="关于评价指标"></a>关于评价指标</h1><p>本文将介绍识别/匹配类论文中常出现的几种评价指标：TPR,FPR,TAR,FAR,FRR,ERR</p><p>TPR：True Positive Rate，真阳性，分类器正确分类且本身为正例</p><p>TNR：True Negative Rate，真阴性，分类器正确分类且本身为负例</p><p>FPR：False Positive Rate，假阳性，分类器错误分类本身为负例</p><p>FNR：False Negative Rate，假阴性，分类器错误分类本身为正例</p><p>TPR=TP/(TP+FN),即正确识别的正例数据占据总的正例数据的比例，为召回率；</p><p>FPR=FP/(FP+TN),即实际值为负例数据，将负例数据预测为正例的百分比；</p><p><strong>ROC</strong></p><p>ROC曲线（Receiver Operating Characteristic）：受试者工作特征曲线</p><p>在分类任务中，我们使用分类器对样本进行分类，分类器会给出样本为正例的概率，我们可以针对此来设定一个阈值，当某个sample被判断为正例的概率大于这个阈值时，认为该sample为正例，小于则为负例。根据阈值-正负例概率，我们可以得到若干个(TPR , FPR)对。</p><p>当阈值越大时，越多的样本被分为负例，而这些样本中其实也有正例的存在。这会导致TPR下降，FPR也下降（负类数据更不会被分为正例，但是影响要比TPR小，所以斜率呈上升趋势）。阈值越小时，越多的样本被分为正例，而这些样本中可能包含是正例，却被分为负例的样本以及是负例却被分为正例的样本，这样一来TPR上升（更多的正例样本被分为正例），FPR上升（更多的负例样本被分为正例，影响更大，所以斜率呈下降趋势）。</p><p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202310101937999.png" alt="image-20231010193729959"></p><p>TAR(True Accept Rate)表示正确接受比例，FAR(False Accept Rate)表示错误接受比例，所谓的接受比例可以表示说，在iot设备配对中，两个设备被认为是合法的配对。</p><p>False Accept Rate：通过给定一个阈值T，如果两台设备的相似度大于T，则被认为同一成功配对，反之则为失败配对。无论将T设置为任何值，均会出现FAR一定的错误接受比例。但是，FAR越小，说明系统的匹配精确度越高。</p><p>TAR：在比对设备匹配的时候，把相同环境/正确匹配识别正确的比例，即正确接受比例。相比于FAR相比，TAR越高意味着模型的鲁棒性越好。</p><p>FRR：错误拒绝率，FRR=1-TAR</p><p>EER：即等误率，即在某一值时，FRR=FAR</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于评价指标&quot;&gt;&lt;a href=&quot;#关于评价指标&quot; class=&quot;headerlink&quot; title=&quot;关于评价指标&quot;&gt;&lt;/a&gt;关于评价指标&lt;/h1&gt;&lt;p&gt;本文将介绍识别/匹配类论文中常出现的几种评价指标：TPR,FPR,TAR,FAR,FRR,ERR&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>KDF</title>
    <link href="http://example.com/posts/8824d597.html"/>
    <id>http://example.com/posts/8824d597.html</id>
    <published>2023-10-08T01:30:38.000Z</published>
    <updated>2023-11-19T08:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="KDF-密钥派生函数"><a href="#KDF-密钥派生函数" class="headerlink" title="KDF 密钥派生函数"></a>KDF 密钥派生函数</h1><p>在现实生活中，我们更倾向于使用密码来保护自己的数据，而不是二进制的密钥。因为相比于二进制复杂的密钥，字符形式（小写字母，大写字母，数字，特殊符号等的组合）才符合人类正常的思维。</p><p>可对计算机来说这相反，现代密码学的很多算法都要求输入是一个大的数字，二进制的密钥就是这样一个大的数字。 因此显然我们需要一个将字符密码（Password）转换成密钥（Key）的函数，这就是密钥派生函数 Key Derivation Function。</p><p>直接使用SHA-一类的哈希函数加密password是不可取的，因为password通常都包含着个人的情感元素，这是容易记忆但容易受到猜测的，通常密码不会很长，在10位左右。另外，有的人为了方便，还会选择一些常见的弱密码，比如123456，admin，个人生日等。这就导致如果直接使用SHA-类的算法，许多密码将很容易被暴力破解，字典攻击，彩虹表攻击等手段猜测出来。</p><p>KDF 目前主要从如下三个维度提升 hash 碰撞难度：</p><ol><li>时间复杂度：对应 CPU/GPU 计算资源</li><li>空间复杂度：对应 Memory 内存资源</li><li>并行维度：使用无法分解的算法，锁定只允许单线程运算</li></ol><p>主要手段是加盐，以及多次迭代。</p><p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202310080957476.webp" alt="img"></p><p>因为相比其他加密哈希算法，KDF 具有一个独特属性——计算速度很慢，而且从设计上就使其计算速度难以提升，所以 KDF 也被称作「慢哈希算法」。</p><p>目前比较著名的 KDF 算法主要有如下几个：</p><ol><li>PBKDF2：这是一个非常简单的加密 KDF 算法，目前已经不推荐使用。</li><li>Bcrypt：安全性在下降，用得越来越少了。不建议使用。</li><li>Scrypt：可以灵活地设定使用的内存大小，在 argon2 不可用时，可使用它。</li><li>Argon2：目前最强的密码 Hash 算法，在 2015 年赢得了密码 Hash 竞赛。</li></ol><h1 id="Scrypt"><a href="#Scrypt" class="headerlink" title="Scrypt"></a>Scrypt</h1><p>Scrypt 是一个强大的密钥派生函数，其通过内存密集的计算方式来抵抗 GPU、ASIC、FPGA 这类密码破解硬件的攻击。</p><p>Scrypt 接收多个输入参数，进行计算后输出密钥：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key = Scrypt(password, salt, N, r, p, derived-key-len)</span><br></pre></td></tr></table></figure><p>其中的参数被称为” Scrypt 配置参数”，说明如下：</p><ul><li><code>N</code> - 迭代次数，将影响 CPU 和内存用量，例：16384 、2048 ；</li><li><code>r</code> - 块大小，将影响 CPU 和内存用量，例：8 ；</li><li><code>p</code> - 并行因数 （并行运行的线程数，将影响 CPU 和内存用量），通常为 1 ；</li><li><code>password</code> - 输入的密码（推荐至少为 8 - 10 个字符）；</li><li><code>salt</code> - 安全产生的随机字节序列（最小为 64 位，推荐 128 位）；</li><li><code>derived-key-len</code> - 输出的密钥要有多少字节长，例如 32 （256 位）</li></ul><p>Scrypt 计算过程中的每一步都会 <strong>按照强相关的顺序</strong> 访问内存，这就让内存读写性能成为了算法速度的瓶颈。</p><p>具体怎么选择参数，要取决于我们能够等待的时间和所需的安全等级（即抗破解的能力）：</p><ul><li>用于交互式登录的示例参数：N=16384, r=8, p=1（RAM = 16MB）。交互式的登录一般耗时都要小于 0.5s ，所以必须快速完成计算。同样的，对于服务端而言，如果同时有很多用户登录，那么 Scrypt 的缓慢会拖慢整个系统；</li><li>用于文件加密的示例参数：N=1048576, r=8, p=1（RAM = 1GB）。当要加密硬盘时，通常不会频繁解密数据（一天可能只解密 2 ~ 3次），所以你可能会愿意多等 2 ~ 3 秒作为提升安全性的代价。</li></ul><p>在 MyEtherWallet 加密钱包应用中，默认的参数是 N=8192, r=8, p=1 。对于此类应用而言，该强度不够高，但可以通过要求用户输入又长又复杂的密码来对抗密码破解攻击。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> cryptography.hazmat.primitives.kdf.scrypt <span class="keyword">import</span> Scrypt</span><br><span class="line"></span><br><span class="line">salt = os.urandom(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># derive</span></span><br><span class="line">kdf = Scrypt(</span><br><span class="line">    salt=salt,</span><br><span class="line">    length=<span class="number">32</span>,</span><br><span class="line">    n=<span class="number">2</span>**<span class="number">14</span>,</span><br><span class="line">    r=<span class="number">8</span>,</span><br><span class="line">    p=<span class="number">1</span>,</span><br><span class="line">)</span><br><span class="line">key = kdf.derive(<span class="string">b&quot;password123&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># verify</span></span><br><span class="line">kdf = Scrypt(</span><br><span class="line">    salt=salt,</span><br><span class="line">    length=<span class="number">32</span>,</span><br><span class="line">    n=<span class="number">2</span>**<span class="number">14</span>,</span><br><span class="line">    r=<span class="number">8</span>,</span><br><span class="line">    p=<span class="number">1</span>,</span><br><span class="line">)</span><br><span class="line">kdf.verify(<span class="string">b&quot;password123&quot;</span>, key)</span><br></pre></td></tr></table></figure><p>在配置合适的前提下，Scrypt 被认为是高度安全的 KDF 函数，所以可以用在任何需要 KDF 的地方——加密钱包、文件、App 密码等场景都可以</p><h1 id="Bcrypt"><a href="#Bcrypt" class="headerlink" title="Bcrypt"></a>Bcrypt</h1><p>Bcrypt 也是一个 KDF ，问世时间早于 Scrypt ，对于 ASIC 、GPU 攻击的抗性相对弱一些。其虽然也可以配置迭代数，但由于对内存的压力较小，因此比较容易构建相应的硬件加速密码破解器。</p><p>在很多的应用、框架和工具中（比如 WordPress 站点的数据库），Bcrypt 加密后的密码都是和算法设置以及盐保存在一起的，体现为一个单一的字符串（字符串有着特定的格式）。这个字符串包含数个部分，以 <code>$</code> 符号分割</p><p>例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$2a$07$wHirdrK4OLB0vk9r3fiseeYjQaCZ0bIeKY9qLsNep/I2nZAXbOb7m</span><br><span class="line">$2a$12$UqBxs0PN/u106Fio1.FnDOhSRJztLz364AwpGemp1jt8OnJYNsr.e</span><br><span class="line">$2a$12$8Ov4lfmZZbv8O5YKrXXCu.mdH9Dq9r72C5GnhVZbGNsIzTr8dSUfm</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;KDF-密钥派生函数&quot;&gt;&lt;a href=&quot;#KDF-密钥派生函数&quot; class=&quot;headerlink&quot; title=&quot;KDF 密钥派生函数&quot;&gt;&lt;/a&gt;KDF 密钥派生函数</summary>
      
    
    
    
    <category term="密码学基础" scheme="http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="密码学基础" scheme="http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>区块链中的前沿技术</title>
    <link href="http://example.com/posts/64d2edde.html"/>
    <id>http://example.com/posts/64d2edde.html</id>
    <published>2023-08-13T11:59:09.000Z</published>
    <updated>2023-12-04T01:49:13.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="元宇宙"><a href="#元宇宙" class="headerlink" title="元宇宙"></a>元宇宙</h1><p><a href="https://www.bilibili.com/bangumi/play/ep682241?theme=movie&amp;spm_id_from=333.337.0.0">头号玩家：献给所有游戏玩家的一封情书</a></p><p>在头号玩家中，令人惊叹的“绿洲”让人向往，那么这一世界是怎么实现的呢？这就体现区块链技术在另一个方向的发展：元宇宙。</p><p>根据维基百科，Metaverse 被定义为“一个集体虚拟共享空间，由虚拟增强的物理现实和物理持久的虚拟空间融合而创造，包括所有虚拟世界、增强现实和互联网的总和。”</p><p><strong>这是另一个与我们物理世界平行的虚拟世界——一个我们可以通过互联网和兼容的硬件设备自由访问的世界，并在其中进行互动。</strong></p><p><strong>元宇宙是真实和虚拟之间的桥梁，可以扩展我们的视觉、声音和触觉，将数字物品融入物理世界，让我们随时进入完全沉浸式的3D 环境。</strong></p><p>元宇宙虽然不像科幻小说和影视作品中描绘的那样奇幻，但却有可能成为新的计算平台和内容媒体，产生数万亿美元的价值。元宇宙确实可以作为网络功能的“继承者”——覆盖范围更大、花费的时间更长、商业活动更多——经济优势也有可能更大。</p><p>更广泛地说，元宇宙<strong>将改变现代资源的分配和货币化方式。</strong>在元宇宙的模式下，居住在“一线发达市区”以外的潜在劳动力将通过虚拟劳动参与“高价值”经济。作为极具生命力的新事物，元宇宙源源不断地创造着新就业机会。</p><p>元宇宙的应用和赛道实在是太多太多，目前主要存在四个大赛道：</p><ul><li>VR/AR等硬件设备</li><li>游戏</li><li>3D渲染等技术</li><li>虚拟人</li></ul><p>发展挑战：</p><ul><li>知识产权，在某种程度上，元宇宙将颠覆原有的产权问题，随之而来的是一些新问题，比如信息景观和虚拟创造物是否有资格获得法律保护和所有权；建立在第三方信息底层的内容是否属于用户作品等。</li><li>法律概念：元宇宙会带来对传统法律概念的改变。通过消除现实世界的物理性，元宇宙将我们人类社会从几个长期持有的法律概念中转移出来</li></ul><h1 id="NFT"><a href="#NFT" class="headerlink" title="NFT"></a>NFT</h1><p>一个非常有意思的新闻：</p><p><a href="https://hypebeast.com/2021/8/stephen-curry-bored-ape-yacht-club-nft-55-ethereum-purchase"><a href="https://hypebeast.com/tags/steph-curry">Stephen Curry</a>最近刚刚花费 55 ETH（约合 180,000 美元）购买了<a href="https://hypebeast.com/tags/bored-ape-yacht-club">Bored Ape Yacht Club</a> NFT。</a></p><p>如今，NFT 应用的用例十分广泛，包括：收藏品、游戏、艺术、虚拟资产、现实世界资产代币化等等。NFT 还能灵活地存储、控制和保护与个人身份相关信息。</p><p>那么，NFT 到底是什么？</p><p>NFT，全称为Non-Fungible Token，指非同质化代币，是用于表示数字资产（包括jpg和视频剪辑形式）的唯一加密货币令牌。现实世界中，不存在表现出完全相似特征或价值的两种商品，所以被称为非同质化货物，即指唯一的、无法替代的商品。</p><p>现实世界中，真实资产拥有所有权证书，同样，在区块链世界中，NFT 代币可以保持所有权记录和真实性证明。</p><p>每个NFT 之间无论是价值还是属性都各不相同。每个代币都有区别于其他代币的数字哈希值；因此，NFT 可以作为出处证明。NFT的价值：它不仅能证明原创艺术品和游戏代币等知识产权的所有权和真实性，还能代表股票、房地产等实际资产。在游戏和藏品领域，NFT 也被称为数字藏品。 </p><p>在现有的市场中，NFT的产品包括：收藏品，游戏资产，虚拟世界，加密艺术品，金融，功能型NFT等。</p><p>例如：游戏NFT，加密猫<a href="https://www.cryptokitties.co/?startMeow=visible">https://www.cryptokitties.co/?startMeow=visible</a></p><p>一款基于以太坊开发的NFT资产类游戏，每个NFT，也就是每只猫都有不同的属性，玩家购买NFT后，就可以开始小猫繁殖的游戏。</p><p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202312040931185.png" alt="image-20231204093130904"></p><p>孵化出来的小猫的基因一部分遗传自上一代，一部分随机生成，孵化的小猫卖出变现，实现在游戏中边玩边赚。简单来说，就是电子养猫，每只猫都有一定的价值。</p><p>在最开始的时候，CryptoKitties最初构想是通过游戏，让普通用户了解什么是区块链及加密货币。这是一个很好的出发点。游戏2017年上线，架设在以太坊网络上，当时年初以太坊价格才几十美元，年底涨到最高800多美元，当时用以太坊作为手续费，玩家还可以接受。现在以太坊价格已经涨到3k多美元，每次交易手续费就是挺大的成本了。</p><p>另一方面，它的价格波动也出现了传统加密货币的毛病：</p><p>在2017年顶峰的日活超过1.4万，然后刺激了区块链游戏赛道的发展（投资），这一度让CryptoKitties价格水涨船高。然而，在2018年，大量资本退出区块链市场，这个价格也达到很低。在最近几年，随着牛市以及NFT概念的火爆，CryptoKitties再度翻红。可以说，这种畸形的价格波动是NFT乃至加密货币市场存在的一个巨大问题。</p><h1 id="DeFi"><a href="#DeFi" class="headerlink" title="DeFi"></a>DeFi</h1><p>DeFi，去中心化金融，是与传统的金融机构以及工作原理所相反的一种经济方式。</p><p>传统的银行，作为金融业的巨头，为个人、企业、其它金融机构甚至政府提供便捷的支付、储蓄与信贷等服务。在全球前十大银行中，它们的市值加起来高达2万亿美元。</p><p>虽然银行毫无疑问成为社会中最重要的支柱，但是，银行是由人来管理并会受政策监管，因而容易遭受与人相关的风险，比如管理不善和腐败。DeFi试图利用新兴的互联网和区块链技术创建一个更好的金融环境，它对传统的银行系统的三个关键部分进行了优化：</p><ol><li>支付和清算：传统的转账，当你在国内想要给国外的人支付一笔费用，这通常包含三种手续费：你的银行汇率，国际电汇汇出手续费以及国际电汇汇入手续费，并且正常的银行系统需要几个工作日才能处理完这笔交易。在DeFi中，加密货币允许你绕过转账过程中撷取大份额利润的中间人，这不仅能够节省大量时间，（通常一笔交易只需要15s到5min），而且还只需要很少的手续费。</li><li>可获取性：现实中可能大部分人都有一个自己的银行账户，但是根据世界银行估计，全世界大约有17亿人，其中大部分来自于发展中国家，没有在金融机构持有账户，主要原因包括：贫穷，地理位置和信任问题。在DeFi中，代表着一场旨在推行无国界、无审查、无障碍金融产品的运动。DeFi协议不会歧视任何人，而且会为每个人营造公平的参与环境。</li><li>中心化和透明度：银行是导致金融体系崩溃的中心节点之一，让权力和资金集中于银行手中是十分危险的。透明度也与此紧密相关——普通投资者无法充分了解金融机构的运作。DeFi在这方面会有所不同。建立在公共区块链（如以太坊）上的DeFi协议大都是开源的，便于审计和提升透明度。这些协议通常会有去中心化的治理组织来确保每个人都清楚发生了什么，并确保没有恶意行为者能够单独地做出恶意决策。</li></ol><p>去中心化金融（DeFi）是一场能够让用户在无需依靠中心化实体的情况下使用诸如借贷和交易等金融服务的运动。DeFi不是单个产品或公司，而是一系列替代银行、保险、债券和货币市场等机构的产品和服务。</p><h1 id="跨链"><a href="#跨链" class="headerlink" title="跨链"></a>跨链</h1><p>跨链是目前区块链最前沿的技术，也是未来发展的重要方向之一</p><p>当前的区块链底层技术平台百花齐放，不同的业务、不同的技术底层的区块链之间缺乏统一的互联互通的机制，这极大限制了区块链技术和应用生态的健康发展。这也是跨链技术产生的原因。</p><p>简单来说，由于每个区块链都有其自己的规则和机制，不同的区块链之间通常就缺乏跨链通讯机制，例如你不能简单地在以太坊（Ethereum）上的DeFi平台直接使用比特币（Bitcoin）。 但是，你可以想象不同的区块链网络为不同的国家，而跨链就是在着些国家当中建立桥梁，隧道等通道。</p><p><strong>跨链技术本质上是⼀种将A链上的数据D（或信息I，或消息M）安全可信地转移到B链并在B链上产生预期效果的⼀种技术。</strong>因为区块链系统本来就是⼀种特殊的分布式账簿数据库系统，所以这个转移的数据，最常见的就是资产的数据，如代币余额。</p><p>目前主流的跨链技术为：公证人机制、哈希锁定、侧链&amp;中继链。目前最有名的跨链项⽬有Cosmos和Polkadot，两者采⽤的都是基于中继链的多链多层架构。</p><p>针对一项技术，尤其是这种设计多个区块链，影响价值巨大的技术，我们要考虑它的安全性问题。</p><p>截至 2022 年第三季，针对跨链桥的攻击已有13 次，被偷取的加密货币折合总值约20亿美元。资料来源：<a href="https://blog.chainalysis.com/reports/cross-chain-bridge-hacks-2022/">Chainalysis</a>.</p><p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202312040946062.png" alt="image-20231204094613983"></p><p>跨链桥的安全问题，关键之一在于跨链桥的信任机制，特别是跨链桥上交易和资产托管（custodian）的验证过程。</p><p>跨链桥的信任机制设计各有不同。当中一种常见的跨链桥类型是中心化（centralised）的跨链桥。中心化跨链桥依赖一小群组织或机构来验证交易、并充当跨链资产的保管人（custodian）。保管人负责在涉及的区块链上确认用户有存入代币，负责进行锁定代币和铸造代币等操作。这种设计往往造成单点故障（single point of failure）的情况，容易出现漏洞和风险。</p><p>但是，随着区块链逐渐向多链并行的方向发展，跨链解决方案打通不同区块链生态系统，显然可以为整体区块链生态提升应用价值。对用户而言，跨链技术可以让“各自为政”的区块链可以互联互通，自然可以让用户扩大手上加密货币资产的价值。毕竟，价值不是一潭死水，只有流通的价值才可以创造出更多的价值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;元宇宙&quot;&gt;&lt;a href=&quot;#元宇宙&quot; class=&quot;headerlink&quot; title=&quot;元宇宙&quot;&gt;&lt;/a&gt;元宇宙&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www</summary>
      
    
    
    
    <category term="区块链" scheme="http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链" scheme="http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>铜锁杂谈</title>
    <link href="http://example.com/posts/28392de5.html"/>
    <id>http://example.com/posts/28392de5.html</id>
    <published>2023-08-12T11:06:41.000Z</published>
    <updated>2023-12-02T11:03:10.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>铜锁/Tongsuo是一个提供现代密码学算法和安全通信协议的开源基础密码库，为存储、网络、密钥管理、隐私计算等诸多业务场景提供底层的密码学基础能力，实现数据在传输、使用、存储等过程中的私密性、完整性和可认证性，为数据生命周期中的隐私和安全提供保护能力。</p><p>项目地址：<a href="https://github.com/Tongsuo-Project/Tongsuo">https://github.com/Tongsuo-Project/Tongsuo</a></p><h1 id="安装Tongsuo"><a href="#安装Tongsuo" class="headerlink" title="安装Tongsuo"></a>安装Tongsuo</h1><p>本节将介绍如何在ubuntu的虚拟机中安装Tongsuo。</p><p>常见的安装方法有两种：直接安装和使用docker安装，没有本质上的区别，docker只是更方便我们卸载，你可以省略前面的安装dockers过程，直接到Tongsuo的安装步骤。</p><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>在这一步，建议大家进入root权限</p><h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><p>ubuntu下自带了docker的库，不需要添加新的源。<br>但是ubuntu自带的docker版本太低，需要先卸载旧的再安装新的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get remove docker docker-engine docker.io containerd runc</span><br><span class="line"></span><br><span class="line">(su)apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure><h3 id="获取软件最新源"><a href="#获取软件最新源" class="headerlink" title="获取软件最新源"></a>获取软件最新源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br></pre></td></tr></table></figure><h3 id="安装-apt-依赖包"><a href="#安装-apt-依赖包" class="headerlink" title="安装 apt 依赖包"></a>安装 apt 依赖包</h3><p>用于通过HTTPS来获取仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span><br></pre></td></tr></table></figure><h3 id="安装GPG证书"><a href="#安装GPG证书" class="headerlink" title="安装GPG证书"></a>安装GPG证书</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | <span class="built_in">sudo</span> apt-key add -</span><br></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-key fingerprint 0EBFCD88</span><br></pre></td></tr></table></figure><h3 id="设置稳定版仓库"><a href="#设置稳定版仓库" class="headerlink" title="设置稳定版仓库"></a>设置稳定版仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> add-apt-repository <span class="string">&quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br></pre></td></tr></table></figure><h3 id="安装-Docker-Engine-Community"><a href="#安装-Docker-Engine-Community" class="headerlink" title="安装 Docker Engine-Community"></a>安装 Docker Engine-Community</h3><h3 id="更新-apt-包索引"><a href="#更新-apt-包索引" class="headerlink" title="更新 apt 包索引"></a>更新 apt 包索引</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br></pre></td></tr></table></figure><p><strong>以下两种安装方式，选择一种即可</strong></p><h3 id="安装最新版本"><a href="#安装最新版本" class="headerlink" title="安装最新版本"></a>安装最新版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><h3 id="安装特定版本"><a href="#安装特定版本" class="headerlink" title="安装特定版本"></a>安装特定版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache madison docker-ce</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run hello-world</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="查看安装的dockers版本"><a href="#查看安装的dockers版本" class="headerlink" title="查看安装的dockers版本"></a>查看安装的dockers版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker version</span><br></pre></td></tr></table></figure><h2 id="安装tongsuo容器"><a href="#安装tongsuo容器" class="headerlink" title="安装tongsuo容器"></a>安装tongsuo容器</h2><p>安装 docker 成功之后，打开你的命令行工具，并执行如下命令，创建一个 docker 容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it --name tongsuo_lab ubuntu:20.04 bash</span><br></pre></td></tr></table></figure><p>继续在命令行中执行如下命令，进入 docker 容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it tongsuolab bash</span><br></pre></td></tr></table></figure><p>此时docker安装成功，并且创建容器</p><h2 id="下载Tongsuo密码库"><a href="#下载Tongsuo密码库" class="headerlink" title="下载Tongsuo密码库"></a>下载Tongsuo密码库</h2><p>我们将在容器中下载同事密码库。因为 ubuntu 自带 apt 命令，因此可以用过 apt 命令安装 git 命令下载铜锁密码库，并通过 make 命令编译它。</p><p>首先，我们先更新软件包索引，执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br></pre></td></tr></table></figure><p>接着安装 <code>git gcc, make开发工具</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install git gcc make -y</span><br></pre></td></tr></table></figure><p>使用 git 命令克隆铜锁密码库的代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Tongsuo-Project/Tongsuo.git</span><br></pre></td></tr></table></figure><p>接着，对铜锁密码库进行一些配置，进入到 <code>Tongsuo</code> 文件夹下，执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Tongsuo</span><br></pre></td></tr></table></figure><p>此时我们要开始编译，注意编译的时候要选择好你想使用的配置，常见的有：</p><ul><li>enable-xx：编译 xx 算法、协议或者功能，比如 我想使用bulletproof，就要enable-bulletproofs，根据自己的需求添加即可</li><li>—prefix=DIR：指定 openssl 的安装目录，如果只是想生成库文件，没有必要执行 make install 命令，也就可以不用指定该选项，默认值：/usr/local</li><li>-Wl,-rpath,/opt/tongsuo/lib：rpath 指定编译出的 openssl 二进制程序依赖的 libcrypto.so 和 libssl.so 目录，效果与 <code>LD_LIBRARY_PATH</code> 和 <code>DYLD_LIBRARY_PATH</code>环境变量一样</li><li>—debug：如果需要 gdb 或者 lldb 调试需要加这个选项</li></ul><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./config --prefix=/opt/tongsuo enable-bulletproofs enable-paillier enable-ntls enable-ssl-trace -Wl,-rpath,/opt/tongsuo/lib64 --debug</span><br><span class="line"></span><br><span class="line">./config --prefix=/opt/tongsuo -Wl,-rpath,/opt/tongsuo/lib enable-bulletproofs</span><br></pre></td></tr></table></figure><p>关于更多的编译选项请看：<a href="https://www.yuque.com/tsdoc/ts/rp7ul8a4ttav8ql9">https://www.yuque.com/tsdoc/ts/rp7ul8a4ttav8ql9</a></p><p>最后，执行如下命令进行编译和安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>此时，便安装成功了，可以通过如下命令查看安装情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /opt/tongsuo</span><br></pre></td></tr></table></figure><p>以及通过 <code>/opt/tongsuo/bin/tongsuo version</code> 命令查看铜锁密码库的版本</p><h1 id="Tongsuo的零知识证明"><a href="#Tongsuo的零知识证明" class="headerlink" title="Tongsuo的零知识证明"></a>Tongsuo的零知识证明</h1><p>零知识证明（ZKP，Zero Knowledge Proof）是隐私计算和区块链领域中非常重要的密码学技术，能够在证明者不向验证者提供任何有用信息的情况下，使验证者相信某个论断是正确的。</p><p>Tongsuo使用的零知识证明技术是Bulletproofs，这是一种相比于zk-SNARKs和 zk-STARKs 更加高效和紧凑的零知识证明方案。具体介绍可以见：<a href="https://www.yuque.com/tsdoc/ts/bulletproofs">https://www.yuque.com/tsdoc/ts/bulletproofs</a></p><p>本文介绍Tongsuo的零知识证明中一些需要注意的事。</p><h2 id="编译注意事项"><a href="#编译注意事项" class="headerlink" title="编译注意事项"></a>编译注意事项</h2><p>如果你想使用Bulletproofs算法，切记在Tongsuo代码拉去后编译时，添加enable-bulletproofs，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./config --prefix=/opt/tongsuo enable-bulletproofs enable-paillier enable-ntls enable-ssl-trace -Wl,-rpath,/opt/tongsuo/lib64 --debug</span><br></pre></td></tr></table></figure><h2 id="基本的零知识证明"><a href="#基本的零知识证明" class="headerlink" title="基本的零知识证明"></a>基本的零知识证明</h2><p>对于零知识证明，一般分为四步：公共参数，证据，证明，验证。详情可以看：<a href="https://www.yuque.com/tsdoc/ts/bulletproofs#RoXBu，下面我说一些值得注意的事情。">https://www.yuque.com/tsdoc/ts/bulletproofs#RoXBu，下面我说一些值得注意的事情。</a></p><p>首先，官网给出的命令行是这样子的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tongsuo bulletproofs -ppgen -out ./pp.pem -curve_name sm2 -gens_capacity 16 -party_capacity 4</span><br></pre></td></tr></table></figure><p>很显然不能直接用，我们要修改路径，把tongsuo修改成自己的路径，例如我的就是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/tongsuo/bin/tongsuo bulletproofs -ppgen -out ./pp.pem -curve_name sm2 -gens_capacity 16 -party_capacity 4</span><br></pre></td></tr></table></figure><p>后续指令同理。</p><h2 id="基于Tongsuo的range-proof"><a href="#基于Tongsuo的range-proof" class="headerlink" title="基于Tongsuo的range_proof"></a>基于Tongsuo的range_proof</h2><p>Tongsuo的官方说明文档给出了一个range_proof的教程：<a href="https://www.yuque.com/tsdoc/ts/bulletproofs-range。本文给出一些简单的补充。">https://www.yuque.com/tsdoc/ts/bulletproofs-range。本文给出一些简单的补充。</a></p><p>在给出的demo例子中，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/bulletproofs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">range_proofs_test</span><span class="params">(<span class="type">int</span> bits, <span class="type">int64_t</span> secrets[], <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>, i;</span><br><span class="line">    BIGNUM *v = <span class="literal">NULL</span>;</span><br><span class="line">    BP_TRANSCRIPT *transcript = <span class="literal">NULL</span>;</span><br><span class="line">    BP_PUB_PARAM *pp = <span class="literal">NULL</span>;</span><br><span class="line">    BP_WITNESS *witness = <span class="literal">NULL</span>;</span><br><span class="line">    BP_RANGE_CTX *ctx = <span class="literal">NULL</span>;</span><br><span class="line">    BP_RANGE_PROOF *proof = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    v = BN_new();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 创建交互抄本对象，证明者和验证者需要使用相同的方法和标签，否则验证失败 */</span></span><br><span class="line">    transcript = BP_TRANSCRIPT_new(BP_TRANSCRIPT_METHOD_sha256(), <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 创建公共参数对象，这里最大的批量验证个数为8 */</span></span><br><span class="line">    pp = BP_PUB_PARAM_new_by_curve_id(NID_secp256k1, bits, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span> || transcript == <span class="literal">NULL</span> || pp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建该公共参数下的证据对象 */</span></span><br><span class="line">    witness = BP_WITNESS_new(pp);</span><br><span class="line">    <span class="keyword">if</span> (witness == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!BN_lebin2bn((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)&amp;secrets[i], <span class="keyword">sizeof</span>(secrets[i]), v))</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 往证据对象中提交明文证据，由于是 range proof，不需要绑定名称，所以名称可以直接传 NULL */</span></span><br><span class="line">        <span class="keyword">if</span> (!BP_WITNESS_commit(witness, <span class="literal">NULL</span>, v))</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建 range proof 上下文对象 */</span></span><br><span class="line">    ctx = BP_RANGE_CTX_new(pp, witness, transcript);</span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建证明对象 */</span></span><br><span class="line">    proof = BP_RANGE_PROOF_new_prove(ctx);</span><br><span class="line">    <span class="keyword">if</span> (proof == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 验证证明对象是否有效 */</span></span><br><span class="line">    <span class="keyword">if</span> (!BP_RANGE_PROOF_verify(ctx, proof))</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    ret = <span class="number">1</span>;</span><br><span class="line">err:</span><br><span class="line">    BP_RANGE_PROOF_free(proof);</span><br><span class="line">    BP_RANGE_CTX_free(ctx);</span><br><span class="line">    BP_WITNESS_free(witness);</span><br><span class="line">    BP_PUB_PARAM_free(pp);</span><br><span class="line">    BP_TRANSCRIPT_free(transcript);</span><br><span class="line">    BN_free(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, ret;</span><br><span class="line">    <span class="type">int64_t</span> secrets[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">1</span> || argc &gt;= <span class="keyword">sizeof</span>(secrets)/<span class="keyword">sizeof</span>(secrets[<span class="number">0</span>])) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid parameter!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        secrets[i<span class="number">-1</span>] = atoi(argv[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, secrets[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里指定的位数为16，即 range 范围为：[0, 65535] */</span></span><br><span class="line">    ret = range_proofs_test(<span class="number">16</span>, secrets, argc - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s range: [0, 65535]\n&quot;</span>, ret == <span class="number">1</span> ? <span class="string">&quot;in&quot;</span> : <span class="string">&quot;not in&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：argc表示命令行输入参数的个数，其中从第二个参数开始才表示我要验证的数字，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./range_proof <span class="number">11</span> <span class="number">22</span> <span class="number">65535</span></span><br></pre></td></tr></table></figure><p>./range_proof是第一个参数，11 22 65535才表示我想要验证的数字。</p><p>此外，这个程序很明显经历了零知识证明中必须的四步：公共参数，证据，证明，验证。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transcript = BP_TRANSCRIPT_new(BP_TRANSCRIPT_METHOD_sha256(), <span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure><p>所谓交互抄本，主要是指零知识证明中双方交流的有效信息，其中的”test”可以更改成任意值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pp = BP_PUB_PARAM_new_by_curve_id(NID_secp256k1, bits, <span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>创建公共参数中，选取了根据椭圆曲线的id生成公共参数的方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">witness = BP_WITNESS_new(pp);</span><br></pre></td></tr></table></figure><p>这是根据公共参数生成证据对象。</p><p>然后就是根据证据对象和输入，生成证明和验证。</p><p>此外，在编译的时候，我们也需要修改官方文档给出的命令行示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -g -o my_range_proof ./my_range_proof.c -I/opt/tongsuo/include -L/opt/tongsuo/lib64 -lcrypto -Wl,-rpath=/opt/tongsuo/lib64</span><br><span class="line"></span><br><span class="line">./config --prefix=/opt/tongsuo -Wl,-rpath,/opt/tongsuo/lib enable-zkp-gadget enable-bulletproofs enable-nizk enable-twisted_ec_elgamal enable-ec_elgamal</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要修改你的Tongsuo安装目录，以及参数最后的依赖目录，这将决定range_proof.c的密码学库指向哪种依赖。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;铜锁/Tongsuo是一个提供现代密码学算法和安全通信协议的开源基础密码库，为存储、网络、密钥管理、隐私计算等诸多业务场景提供底层的密码学基础能力，实现数据在传输、使用、存储等过程中</summary>
      
    
    
    
    <category term="零知识证明" scheme="http://example.com/categories/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/"/>
    
    
    <category term="零知识证明" scheme="http://example.com/tags/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>纵向联邦学习</title>
    <link href="http://example.com/posts/c23d1ee9.html"/>
    <id>http://example.com/posts/c23d1ee9.html</id>
    <published>2023-08-12T09:00:49.000Z</published>
    <updated>2023-12-21T11:02:21.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>现在我们介绍另一种联邦学习算法：纵向联邦学习（Vertical Federated Learning）。纵向联邦学习的参与方拥有相同样本空间、不同特征空间的数据，通过共有样本数据进行安全联合建模，在金融、广告等领域拥有广泛的应用场景。和横向联邦学习相比，纵向联邦学习的参与方之间需要协同完成数据求交集、模型联合训练和模型联合推理。并且，参与方越多，纵向联邦学习系统的复杂度就越高。</p><p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202312211840783.png" alt="image-20231221184019649"></p><p>纵向联邦学习VFL一般由两部分组成：加密实体对齐，加密模型训练。</p><p><strong>加密实体对齐</strong></p><p>由于A方和B方公司的用户群体不同，系统使用一种基于加密的用户ID对齐技术，来确保A方和B方不需要暴漏各自的原始数据便可以对齐共同用户。在实体对齐期间，系统不会将属于某一家公司的用户暴露出来。</p><p><strong>加密模型训练</strong></p><p>在确定共有实体后，各方可以使用这些共有实体的数据来协同地训练一个机器学习模型。训练过程可以被分为以下四个步骤：</p><ul><li>协调者C创建密钥对，并将公共密钥发送给A方和B方</li><li>A方和B方对中间结果进行加密和交换，中间结果用来帮助计算梯度和损失值</li><li>A方和B方计算加密梯度并分别加入附加掩码。B方还会计算加密损失。A方和B方将加密的结果发送给C方</li><li>C方对梯度和损失信息进行解密，并将结果发送回A方和B方。A方和B方解除梯度信息上的掩码，并根据这些梯度信息来更新模型参数</li></ul><p>在样本对齐中，最常使用地便是隐私集合求交（Private Set Intersection，PSI）技术。业界PSI实现方案有多种：基于电路、基于公钥加密、基于不经意传输协议和基于全同态加密等。不同PSI方案各有优劣势。例如，基于公钥加密方案不需要辅助服务器运行，但公钥加密的计算开销大；而基于不经意传输方案计算性能高，但通信开销较大。因此在具体应用时，要根据实际场景来选择功能、性能和安全之间的最佳平衡方案。</p><p>基于RSA盲签名是一种基于公钥加密的经典PSI方法，也是当前业界纵向联邦学习系统中广泛应用的技术之一。下面以企业A和企业B为例描述RSA盲签名算法的基本流程。</p><p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202312211856382.png" alt="image-20231221185618332"></p><p>企业A作为服务端，拥有一个包含了标签数据+样本ID的集合。企业B则作为客户端，拥有样本ID集合。首先，企业A利用RSA算法生成私钥和公钥。其中，私钥保留在服务端，公钥则发送给企业B。</p><p>服务端利用RSA算法计算出参与样本对齐的ID的签名：</p><script type="math/tex; mode=display">t_j=H^`(K_{a:j})</script><p>其中$K_{a:j}=(H(a_j))^d(\mod n)$是采用私钥d加密的对$H(a_j)$的RSA加密的结果。</p><p>同样，在客户端侧对样本ID进行公钥加密，并乘以一个随机数用于加盲扰动:</p><script type="math/tex; mode=display">y_i=H(b_i)(R_{b,i})^e\mod n</script><p>客户端侧将上述计算出来的${y_1,…,y_v}$值传输给服务端侧。服务端侧收到$y_i$值后，使用私钥$d$进行签名并计算：</p><script type="math/tex; mode=display">y_i^`=y_i^d\mod n</script><p>然后将计算出的${y_1^<code>,...,y_v^</code>}$和${t_1,…,t_w}$发送给客户端侧。 而客户端侧收到$y_i^`$和$t_j$后，首先完成去盲操作：</p><script type="math/tex; mode=display">K_{b:i}=y_i^~/R_{b,i}</script><p>并将自己的ID签名与服务端发过来的ID签名进行样本对齐，得到加密和哈希组合状态下的ID交集$I$，</p><script type="math/tex; mode=display">t_i^`=H^`(K_{b:i})\\I=\{t_1,...,t_w\}\cap\{t_1^`,...,t_v^`\}</script><p>最后，将对齐后的样本ID交集$I$发送给服务端，服务端利用自身的映射表单独求取明文结果。这样企业A和企业B在加密状态下完成了求取相交的用户集合，并且在整个过程中双方非重叠样本ID都不会对外暴露。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;现在我们介绍另一种联邦学习算法：纵向联邦学习（Vertical Federated Learning）。纵向联邦学习的参与方拥有相同样本空间、不同特征空间的数据，通过共有样本数据进行</summary>
      
    
    
    
    <category term="联邦学习" scheme="http://example.com/categories/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="联邦学习" scheme="http://example.com/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>公钥加密方案在选择密文攻击下的不可区分性</title>
    <link href="http://example.com/posts/20dbd7e1.html"/>
    <id>http://example.com/posts/20dbd7e1.html</id>
    <published>2023-08-11T11:32:04.000Z</published>
    <updated>2023-11-19T08:00:40.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>IND-CPA安全仅保证敌手是完全被动情况的安全，不能保证敌手主动情况（如向网络中注入消息）的安全。</p><p>为了描述敌手的主动攻击，前人提出一种选择密文攻击（Chosen Ciphertext Attack，CCA）的概念，其中敌手在获得目标密文以前，可以访问解密喻言机。敌手获得目标密文后，希望获得目标密文对应的明文的部分信息。</p><p>公钥加密方案在选择密文攻击下的IND游戏如下：</p><p>（1）初始化。挑战者产生系统$\mathcal{\Pi}$，敌手获得系统的公开钥。</p><p>（2）训练。敌手向挑战者做解密询问，即取密文CT给挑战者，挑战者解密后，将明文给敌手。</p><p>（3）挑战，敌手输出两个长度相同的消息$M<em>0,M_1$，再从挑战者接收$M</em>{\beta}$的密文，其中随机值$\beta \larr _R{0,1}$。</p><p>（4）猜测，敌手输出$\beta^{\prime}$，如果$\beta^{\prime}=\beta$，则敌手攻击成功。</p><p>以上攻击过程称为午餐时间攻击，相当于有一个执行解密运算的黑河，掌握黑盒的人在午餐时间离开后，敌手能使用黑河对自己选择的密文解密。午餐过后，给敌手一个目标密文，敌手试图对目标密文解密，但不能再使用黑盒。</p><p>敌手的优势定义为安全参数$\mathcal{K}$的函数：</p><script type="math/tex; mode=display">Adv_{\mathcal{\Pi},\mathcal{A}}^{CCA}(\mathcal{A})=|Pr[\beta^{\prime}=\beta]-\frac{1}{2}|</script><p>如果对任何多项式时间的敌手$\mathcal{A}$，存在一个可忽略函数$\epsilon (\mathcal{K})$，使得$Adv_{\mathcal{\Pi},\mathcal{A}}^{CCA}(\mathcal{A}) \le \epsilon (\mathcal{K})$，那么我们就称这个加密算法$\mathcal{\Pi}$在选择密文攻击下具有不可区分性，或者称为IND-CCA安全。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;IND-CPA安全仅保证敌手是完全被动情况的安全，不能保证敌手主动情况（如向网络中注入消息）的安全。&lt;/p&gt;
&lt;p&gt;为了描述敌手的主动攻击，前人提出一种选择密文攻击（Chosen C</summary>
      
    
    
    
    <category term="密码学基础" scheme="http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="密码学基础" scheme="http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
