<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>zkBridge | Hibara</title><meta name="author" content="jhy"><meta name="copyright" content="jhy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="zkBridge: Trustless Cross-chain Bridges Made Practical当今时间，多种多样的区块链出现在人们的视野。多链世界的核心挑战是如何实现安全的跨链桥接，使不同区块链上的应用可以通过这些桥接进行通信。 区块链$C_1$和$C_2$之间桥梁的核心功能是向$C_2$上的应用程序证明某个事件发生在$C_1$上，反之亦然。 问题所在，虽然在实践中已经建立了">
<meta property="og:type" content="article">
<meta property="og:title" content="zkBridge">
<meta property="og:url" content="http://example.com/posts/e15e124.html">
<meta property="og:site_name" content="Hibara">
<meta property="og:description" content="zkBridge: Trustless Cross-chain Bridges Made Practical当今时间，多种多样的区块链出现在人们的视野。多链世界的核心挑战是如何实现安全的跨链桥接，使不同区块链上的应用可以通过这些桥接进行通信。 区块链$C_1$和$C_2$之间桥梁的核心功能是向$C_2$上的应用程序证明某个事件发生在$C_1$上，反之亦然。 问题所在，虽然在实践中已经建立了">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/1.png">
<meta property="article:published_time" content="2024-09-13T11:44:08.000Z">
<meta property="article:modified_time" content="2024-09-18T12:32:27.000Z">
<meta property="article:author" content="jhy">
<meta property="article:tag" content="cross-chain">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/1.png"><link rel="shortcut icon" href="/img/favicon1.png"><link rel="canonical" href="http://example.com/posts/e15e124"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'zkBridge',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-18 20:32:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/transpancy.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Hibara" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hibara</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">zkBridge</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-09-13T11:44:08.000Z" title="发表于 2024-09-13 19:44:08">2024-09-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="zkBridge"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer">



<h1 id="zkBridge-Trustless-Cross-chain-Bridges-Made-Practical"><a href="#zkBridge-Trustless-Cross-chain-Bridges-Made-Practical" class="headerlink" title="zkBridge: Trustless Cross-chain Bridges Made Practical"></a>zkBridge: Trustless Cross-chain Bridges Made Practical</h1><p>当今时间，多种多样的区块链出现在人们的视野。多链世界的核心挑战是如何实现安全的跨链桥接，使不同区块链上的应用可以通过这些桥接进行通信。</p>
<p>区块链$C_1$和$C_2$之间桥梁的核心功能是向$C_2$上的应用程序证明某个事件发生在$C_1$上，反之亦然。</p>
<p>问题所在，虽然在实践中已经建立了跨链桥，但现有的解决方案要么性能不佳，要么依赖于中心方。</p>
<p>桥的运行取决于两个链的共识协议。如果$C_1$运行的是工作证明（Proof-of-Work），具体来说，$C_2$上的智能合约（用$SC_2$表示）将跟踪$C_1$的区块头，根据这些区块头，可以用 Merkle 证明来验证交易的包含（和其他事件）。但是，这种方法会产生巨大的计算和存储开销，因为$SC_2$需要验证所有区块头，并保存一个不断增长的冗长列表。</p>
<p>作为一种高效的替代方案，许多桥接协议<br>(PolyNetwork、Wormhole、Ronin 等）都采用了基于信任中介（Trust In­ter­me­di­ary）的方法，所使用的技术包括侧链（PolyNetwork），跨链委员会（Ronin），预言机（LayerZero）</p>
<p>Wormhole：<a target="_blank" rel="noopener" href="https://docs.wormhole.com/wormhole/explore-wormhole/security">https://docs.wormhole.com/wormhole/explore-wormhole/security</a></p>
<p>Poly Network：<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3300">https://learnblockchain.cn/article/3300</a></p>
<p>此类方式需要有比较强的信任假设，也即假设跨链桥的结点有至少 2/3 是可信的，委员会中有至少 2/3 是可信的。</p>
<p>但是这种方式容易遭受到恶意的攻击。</p>
<p>为了降低对中介的信任依赖，一个比较简单的方式是不让中介传输数据，而是让中介对数据进行签名，之后由接受数据的链对签名进行验证即可</p>
<p>这个思路有点类似于轻量级客户端验证，只要客户端验证并持续追踪验证状态即可</p>
<p>举个例子，Cos­mos IBC 是一个用于 Cos­mos 链的跨链协议，这个协议会验证来自其他链的数据的区块首部，从而完成跨链数据的验证，不过此类方式也存在缺点，需要跨链的接收方部署这个 IBC 协议来完成数据验证（比如以太坊没有部署这个东西，就无法支持跨链）</p>
<p>或者向 NEAR Rain­bow bridge 那样的做法，将其以智能合约的形式部署于以太坊来支持跨链，但是这会导致链上验证的开销非常大</p>
<p>为了在消除中介的同时提供足够强的安全性，这里可以引入 ZKP 技术，主要思想和很多去中心化的协议类似，将对可信机构的信任转移至对密码学假设的依赖。</p>
<p>zkBridge 可以实现高效的跨链桥接，而无需信任中央委员会。其主要思想是利用 zk-SNARK，即简洁的非交互式知识证明（论证）</p>
<p>zk-SNARK能让证明者有效地让$SC_2$相信，在$C_1$上发生了某种状态转换。为此，$SC_2$将跟踪$SC_1$最新提示的摘要$D$。要使$SC_2$与$C_1$中的新区块同步，任何人都可以生成并提交 zk-SNARK，向$SC_2$证明$C_1$的顶端已经从 $D$推进到$D^\prime$。</p>
<p>好处：</p>
<p>zk-SNARK 的健全性确保了桥梁的安全性。除了底层区块链的安全性外，我们不需要额外的安全性要求。</p>
<p>通过专门构建的 zk-SNARK，$C_2$可以验证$C_1$的状态转换，远比在$SC_2$中编码$C_1$的共识逻辑更有效。</p>
<p>要使用 zk-SNARK 证明给定计算结果的正确性，首先需要将计算表达为算术电路。</p>
<p>虽然 zk-SNARK 验证速度很快（与电路的大小成对数关系，甚至是常数），但证明生成时间至少是线性的，而且在实践中可能昂贵得令人望而却步。</p>
<p>此外，现实世界中区块链使用的组件并不容易用算术电路来表示。例如，广泛使用的 EdDSA 数字签名方案在 CPU 上的验证效率很高，但要用算术电路表示却很昂贵，需要 200 多万个门。在跨链桥中，根据链的不同，每个状态转换可能需要验证数百个签名，这使得生成所需的 zk-SNARK 证明的成本过高。</p>
<p>因此，为了使 zkBridge 实用化，我们必须缩短证明生成时间。</p>
<p>我们发现跨链桥所使用的电路是数据并行的，因为它们包含一个较小的子电路的多个相同副本。具体来说，用于验证$N$数字签名的电路包含签名验证子电路的$N$个副本。因此，本文提出一种基于Virgo的分布式协议，deVirgo，如果证明生成分布在$M$台机器上，生成时间可减少$M$倍。</p>
<p>虽然 deVirgo 大大缩短了证明生成时间，但在链上验证 deVirgo 证明（尤其是 zkBridge 中的十亿门电路）对于计算资源极其有限的智能合约来说可能是昂贵的。</p>
<p>为了压缩证明大小和验证成本，本文使用 Groth 提出的经典 zk-SNARK 递归证明（可能很大）deVirgo 证明的正确性，以下简称 Groth16。Groth16 校验器能输出恒定大小的证明，EVM 区块链上的智能合约可以快速验证这些证明。我们强调，不能使用 Groth16 生成整个 zkBridge 证明，因为 zkBridge 所需的电路对于 Groth16 验证器来说太大了。</p>
<p>相反，我们使用 Groth16 压缩 deVirgo 证明的方法却能提供两全其美的效果：快速的 deVirgo 并行证明器可生成大部分证明，而生成的证明则被压缩为简洁的 Groth16 证明，可快速验证。</p>
<p>为了证明zkBridge的实用性，我们在Cosmos和以太坊之间实现了zkBridge的端到端原型，包括deVirgo和递归验证协议，以及交易中继应用。</p>
<h1 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h1><p>$F$：有限域</p>
<p>$\lambda$：安全参数</p>
<p>$f(),h()$：多项式表达式</p>
<p>$x,y$：单一变量</p>
<p>$\vec{x},\vec{y}$：变量向量</p>
<p>$\vec{x}[i],\vec{x}[i:k]=(x<em>i,x</em>{i+1},…,x_k)$</p>
<p>Merkle Tree:</p>
<ul>
<li>$rt\leftarrow MT.Commit(\vec{x})$</li>
<li>$(\vec{x}[i],\pi_i)\leftarrow MT.Open(\vec{x},i)$</li>
<li>${1,0}\leftarrow MT.Verify(\pi_i,\vec{x}[i],rt)$</li>
</ul>
<p>$blk={blkh;trx_1,…,trx_t}$：区块</p>
<p>$LOG<em>r^i=[blk_1,…,blk_r]$：账本，$r$是高度，$blk</em>{k\cdot ptr}=blkH_{k-1}$</p>
<p>一致性：对于诚实的节点$i,j$，一定有$LOG_i^{r_0}$是$LOG_j^{r_1}$的前缀。</p>
<p>有效性：如果一个诚实节点在某一轮 $r$ 收到了某笔交易$trx$，那么$trx$最终会被包含到所有诚实节点的区块链中。</p>
<p>$LightCC(LCS<em>{r-1},blkH</em>{r-1},blkH<em>r)\rightarrow {true,false}$：轻客户端的区块验证规则，其中$blkH_r$表示新的区块头，$blkH</em>{r-1}$旧的区块头，$LCS_{r-1}$当前的状态</p>
<p><strong>零知识证明：</strong>当$\lambda$作为安全参数，$R$是一种$NP$关系，算法$(\mathcal{G,P,V})$对于$R$来说是零知识的，当其满足：</p>
<ul>
<li>Completeness：对于$\mathcal{G}(1^\lambda)$产生的参数$pp$，$(x;w)\in \mathcal{R},\pi\leftarrow \mathcal{P}(x,w,pp)$：</li>
</ul>
<script type="math/tex; mode=display">
Pr[\mathcal{V}(x,\pi,pp)=1]=1</script><ul>
<li>Knowledge Soundness：对于PPT的证明者$\mathcal{P}^<em>$，存在一个PPT模拟器$\mathcal{E}$和辅助字符串$z$.$pp\leftarrow \mathcal{G}(1^\lambda),\pi^</em> \leftarrow P^<em>(x,z,pp),w,\mathcal{E}^{P^</em>(\cdot)}(x,z,pp)$：</li>
</ul>
<script type="math/tex; mode=display">
Pr[(x;w)\notin R \and \mathcal{V}(x,\pi^*,pp)=1]\le negl(\lambda)</script><ul>
<li>Zero knowledge：存在一个PPT模拟器$S$对于PPT算法$\mathcal{V}^*$，$(x,w)\in \mathcal{R},pp\leftarrow \mathcal{G}(1^\lambda)$</li>
</ul>
<script type="math/tex; mode=display">
View(\mathcal{V}^*(pp,x))\approx \mathcal{S}^{\mathcal{V}^*}(x)</script><p>我们说$(\mathcal{G,P,V})$是简洁的，当$\mathcal{P,V}$之间的总开销（证明大小）以及$\mathcal{V}$的运行时间，是$poly(\lambda,|x|,log|\mathcal{R}|)$的，其中$|R|$是电路的大小</p>
<h1 id="zkBridge"><a href="#zkBridge" class="headerlink" title="zkBridge"></a>zkBridge</h1><p>注意：zkBridge两个方向的操作是一致的。</p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>为了让不同的应用程序都能轻松地与 zkBridge 集成，我们采用了模块化设计，将特定于应用程序的逻辑（如验证智能合约状态）与核心桥接功能（即转发区块头）分离开来。</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202409141639416.png" alt="image-20240914163902252"></p>
<p>如图显示了zkBridge的架构和工作流程。核心桥接功能由一个<strong>区块头中继网络</strong>（仅在有效性方面受信任）提供，$\mathcal{C}_1$的中继块头提供正确性证明，$\mathcal{C}_2$的<strong>更新器合约</strong>验证和接收证明。</p>
<p>更新器合约维护最新的区块头列表，并在验证中继节点提交的证明后对其进行适当更新；它公开了一个简单且与应用程序无关的应用程序接口，应用程序智能合约可以从中获取发送方区块链的最新区块头，并在此基础上构建特定于应用程序的逻辑。</p>
<p>依赖于 zkBridge 的应用程序通常会在$\mathcal{C}_1$和$\mathcal{C}_2$上分别部署一对合约，即发送方合约和接收方合约。我们把它们统称为应用合约或依赖合约。接收者合约可以调用更新器合约来获取$\mathcal{C}_1$的块头，并在此基础上执行特定的应用任务。根据应用的不同，接收方合约可能还需要用户或第三方提供特定应用的证明，如智能合约状态的 Merkle 证明。</p>
<p>如图展示了跨链代币转移的工作流程。</p>
<p>假设用户$\mathcal{u}$想要在另一个区块链$\mathcal{C}_2$上的交易所交易她在$\mathcal{C}_1$的资产，即将资金从$\mathcal{C}_1$转移到$\mathcal{C}_2$上。</p>
<p>一对智能合约$SC<em>{lock}$和$SC</em>{mint}$分别部署在区块链$C_1$和$C_2$上。</p>
<p>为了转移资金，用户将 $v 代币锁定在$SC<em>{lock}$（图 1 中的步骤 1），然后请求$SC</em>{mint}$发行 $v 代币。</p>
<p>$SC<em>{mint}$只应在且仅在用户已锁定$C_1$上的代币时才发行新代币。这要求$SC</em>{mint}$从不同的区块链读取$SC_{lock}$的状态（$\mathcal{U}$的余额，在步骤 2 中更新），但它不能直接这样做。</p>
<p>zkBridge 通过将$C_1$的区块头和证明一起转发给$C_2$来实现这一点（步骤 3 和 4）。</p>
<p>$SC_{mint}$可以从智能合约前端（更新合约）获取区块头，检查用户$\mathcal{U}$的余额是否确实为 $v（步骤 5 ），然后能铸造 $v 代币（步骤 6 ）。</p>
<p>除了跨链代币转移，zkBridge 还能实现其他各种应用，如跨链抵押贷款、一般消息传递等。</p>
<h2 id="detail"><a href="#detail" class="headerlink" title="detail"></a>detail</h2><h3 id="security-and-system-model"><a href="#security-and-system-model" class="headerlink" title="security and system model"></a>security and system model</h3><p>为了建模桥，我们将区块链$\mathcal{C}$建模为区块编号索引的键值存储，表示为$\mathcal{C}[t]:\mathcal{K}\rightarrow \mathcal{V}$其中$t$是区块编号，$\mathcal{K}$和 $\mathcal{V}$分别是键和值空间。</p>
<p>例如，以太坊中，$\mathcal{V}={0,1}^{256}$（每个地址存储32字节的值），密钥是智能合约标识符$\mathcal{SC}$和每个智能合约存储地址$\mathcal{K}$的连接。对于一个给定的合约$\mathcal{SC}$，我们将存储在地址$\mathcal{K}$区块编号$t$的值记作$\mathcal{SC}[t,\mathcal{K}]$，将$\mathcal{SC}[t,\cdot]$叫做$\mathcal{SC}$在区块编号为$t$的状态</p>
<p>我们关注于从$\mathcal{SC}_1$到$\mathcal{SC}_2$，记作$\mathcal{BR}[\mathcal{SC}_1\rightarrow \mathcal{SC}_2]$</p>
<p><strong>Functional and security goals</strong></p>
<p>我们要求桥$\mathcal{BR}[\mathcal{SC}_1\rightarrow \mathcal{SC}_2]$正确及时地反映$\mathcal{SC}_1$的状态：</p>
<p>正确性： 对于所有$t,\mathcal{K}$，$\mathcal{SC}_2$接受错误状态$\mathcal{V}\ne \mathcal{SC}_1[t,\mathcal{K}]$的概率可忽略不计。</p>
<p>有效性： 假设$\mathcal{SC}_2$需要验证$SC_1$在$(t,K)$处的状态，桥最终会提供必要的信息。</p>
<p><strong>Security assumptions</strong></p>
<p>为了保证正确性，除了底层区块链的信任假设外，zkBridge 没有引入额外的信任假设。也就是说，我们假设发送方区块链和接收方区块链都是一致的和有效的（第 2 节），并且发送方链有一个轻客户端协议，可以快速验证区块头。对于这两个特性，我们假设中继网络中至少有一个诚实节点，并且所使用的 zk-SNARK 是可靠的。</p>
<h3 id="construction"><a href="#construction" class="headerlink" title="construction"></a>construction</h3><p>如第 3 节所述，桥接器$\mathcal{BR}[\mathcal{SC}_1\rightarrow \mathcal{SC}_2]$由三个部分组成：区块头中继网络、更新合约和一个或多个应用合约。下面我们将说明每个组件的协议。</p>
<p><strong>区块头中继网络：</strong></p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202409181843063.png" alt="img"></p>
<p>块标头中继网络中的节点以更新合约的当前状态（$LCS<em>{r-1},blkH</em>{r-1}$）为输入，运行 RelayNextHeader。</p>
<p>中继节点连接到$C<em>1$中的全节点，并获得继$blkH</em>{r-1}$之后的块头$blkH<em>r$。中继节点生成一个 ZKP $\pi$，显示$blkH_r$的正确性，主要证明$blkH_r$在块$blkH</em>{r-1}$之后被$C_1$的轻客户端接受。</p>
<p>它将 ($\pi,blkH_r$) 发送给$C_2$上的更新合约。</p>
<p>为了避免因碰撞而浪费证明时间（注意，当多个中继节点同时发送时，只能接受一个证明），中继节点可以使用标准技术进行协调（例如，以循环方式发送）。</p>
<p><strong>为了激励区块头中继节点，证明者可以在验证其证明后获得费用奖励。激励机制的设计留待今后研究。</strong></p>
<p>我们注意到，这种设计依赖于发送者链的轻客户端验证器的安全性。例如，轻客户端验证器必须拒绝最终可能成为孤儿且不属于发件人链的有效块头。</p>
<p><strong>更新者合约</strong></p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202409181900829.png" alt="image-20240918190006734"></p>
<p>更新器合约维护轻客户端的内部状态，包括 headerDAG 中$C<em>1$的区块头列表。它有两个公开暴露的函数。HeaderUpdate 函数可以可由任何区块头中继节点调用，并提供下一个区块头和一个证明作为输入。如果证明与当前轻客户端状态 $LCS$ 和 $blkH</em>{r-1}$ 一致，合约将对轻客户端进行进一步检查，然后相应地更新状态。由于该函数的调用者必须支付一定费用，因此自然可以防止$DoS$攻击。</p>
<p>接收合约可调用 GetHeader 函数来获取高度为 $t$ 的区块头。接收方合约可以使用获得的区块头完成特定应用验证，可能需要用户或第三方的帮助。</p>
<p>zkBridge 采用模块化设计，更新合约与应用程序无关。因此，在$\mathcal{BR}[\mathcal{SC}_1\rightarrow \mathcal{SC}_2]$中，由应用合约$SC_1$和$SC_2$决定桥接的信息是什么。一般来说，证明$SC_1[t,K]=V$的过程非常简单：$SC_2$可以请求获得与地址$K$对应的状态 Trie Tree 的叶子（位于区块编号 𝑡）的 Merkle 证明。接收方合约可以通过调用函数 $GetHeader(t)$，从更新方合约中获取$blkH_t$。然后，它可以根据$blkH_t$中的 Merkle 根验证$SC_1[t,K]=V$</p>
<p>下面的定理说明了 zkBridge 的安全性。<br>由协议 1 和 2 实现的桥$\mathcal{BR}[\mathcal{SC}_1\rightarrow \mathcal{SC}_2]$同时满足一致性和有效性，假设以下条件成立：</p>
<ol>
<li>在区块头中继网络中至少有一个诚实节点；</li>
<li>发送方链是一致和有效的；</li>
<li>发送方链有一个定义 2.1 中的轻客户端验证器；以及</li>
<li>简洁证明系统是健全的。</li>
</ol>
<h2 id="Application-cases"><a href="#Application-cases" class="headerlink" title="Application cases"></a>Application cases</h2><p><strong>Transaction inclusion: a building block</strong></p>
<p>跨链应用的一个常见构件是验证另一个区块链上的交易包含性。</p>
<p>具体来说，目的是使$C_2$上的接收方合约$SC_2$能够验证给定的交易$trx$已包含在高度为$t$的$C_1$上的区块$B_t$中。为此，接收方合约$SC_2$需要用户或第三方服务为$B_t$中的$trx$提供 Merkle 证明。然后，$SC_2$将调用更新器合约，检索高度为$t$的$C_1$的区块头，然后根据头中包含的 Merkle 根验证所提供的 Merkle 证明。</p>
<p><strong>消息传递和数据分享</strong></p>
<p>跨链消息传递是另一种常见的构建模块，可用于跨区块链共享链外数据等。消息传递可以通过在交易中嵌入消息，作为交易包含的简单扩展来实现。具体来说，要将$C_1$的消息$m$传递到$C_2$，用户可以将$m$嵌入事务$trx_m$，将$trx_m$发送到$C_1$，然后执行上述事务包含证明。</p>
<p><strong>跨链交换资产</strong></p>
<p>在此应用中，用户可以在发送方区块链$C_1$上注入一定数量的代币$T_A$，并在接收方区块链$C_2$上获得相同数量的代币$T_A$（如果符合条件，用于原生资产转移）或一定数量的价值大致相同的代币$T_B$（用于原生资产交换）。</p>
<p>首先，开发者会在$C<em>1$上部署一个锁合约$SC</em>{lock}$，在$SC$上部署一个合约$SC_{mint}$。如果用户想将$n_A$的代币$T_A$换成等值的代币$T_B$。</p>
<p>她将首先发送一个交易$trx<em>{lock}$，将$n_A$的代币$T_A$转移到$SC</em>{lock}$，同时发送一个地址$addr<em>{C_2}$，以便在$C_2$上接收代币$T_B$。在区块$B$中确认$trx</em>{lock}$后，用户将向$SC<em>{mint}$发送交易$trx</em>{mint}$，其中包括足够的信息来验证是否包含$trx<em>{lock}$。根据$trx</em>{mint}$中的信息，$SC<em>{mint}$将验证$C_1$上是否包含了$trx</em>{lock}$，并将相应的$T<em>B$代币转移到$trx</em>{lock}$中指定的地址$addr_{C_2}$上。</p>
<p>最后，$SC<em>{mint}$将标记$trx</em>{lock}$为铸币，以完成转账。</p>
<p><strong>NFT的互操作</strong></p>
<p>在不可兑换代币（NFT）的互操作应用中，用户总是在发送方区块链上锁定/标记 NFT，并在接收方区块链上获得铸币的 NFT 或 NFT 衍生物。通过设计 NFT 衍生物，跨链协议可以在两个区块链系统上分离 NFT 的所有权和效用，从而支持在发送方区块链上锁定 NFT 的所有权，在接收方区块链上获取效用。</p>
<h2 id="efficient-proof-systems-for-zkBridge"><a href="#efficient-proof-systems-for-zkBridge" class="headerlink" title="efficient proof systems for zkBridge"></a>efficient proof systems for zkBridge</h2><p>当发送链和接收链使用不同的加密实现时，开销的一个主要来源是不同椭圆曲线之间的字段转换，这在实践中很常见。</p>
<p>为了使 zkBridge 实用化，我们提出了两个想法。</p>
<p>利用 deVirgo 缩短证明时间。我们发现，用于验证多个签名的 ZKP 电路由一个子电路的多个副本组成。我们的第一个想法是利用这一特殊结构，在多个服务器之间分布式生成证明。我们提出了一种名为 deVirgo 的新型分布式 ZKP 协议。</p>
<p>通过递归验证降低链上成本。虽然在普通 CPU 上验证 deVirgo 证明非常高效，但链上验证的成本仍然很高。为了进一步降低链上验证成本（计算和存储），我们使用递归验证：证明者递归地证明正确的证明。<br>证明者使用对智能合约友好的零知识协议递归证明一个（可能很大的）Virgo 证明的正确性，从而得到一个小的、验证者效率高的证明。</p>
<h1 id="Distributed-Proof-Generation"><a href="#Distributed-Proof-Generation" class="headerlink" title="Distributed Proof Generation"></a>Distributed Proof Generation</h1><p>快速验证时间的机会来自于验证$N$签名的电路由相同子电路的$N$副本组成这一事实。这种电路被称为数据并行电路</p>
<p>我们选择 Virgo 作为底层 ZKP 协议有两个原因： </p>
<ul>
<li><p>Virgo 不需要可信设置，而且是可信的后量子安全协议。</p>
</li>
<li><p>Virgo 是最快的协议之一，验证时间简洁，证明规模简洁，可解决大规模问题。.</p>
</li>
</ul>
<p>我们为数据并行算术电路提出了一种新的分布式 Virgo 版本，它能在证明大小不增加任何开销的情况下实现最佳可扩展性。具体地说，在使用$N$台并行机器、具有$N$个副本的数据并行电路上，我们的 deVirgo 协议比原始 Virgo 快$N$倍，而证明大小保持不变。我们的方案具有独立的意义，可以用于其他基于 Virgo 的系统，以提高效率。</p>
<p>假设证明者总共有$N$台机器，标记范围从$P<em>0$到$P</em>{N-1}$。</p>
<p>假设$P_0$是主节点，其他机器是普通节点。假设$v$是验证器。</p>
<p>给定一个由$N$个相同结构组成的数据并行算术电路，分布式 Virgo 的简单算法是将每个子电路分配给一个单独的节点。然后，每个节点分别运行 Virgo 生成证明。𝑁 证明的合并即为最终证明。</p>
<p>遗憾的是，这种天真算法的证明大小与子电路的数量成线性关系，这对于具有许多子副本的数据并行电路来说，可能大得令人望而却步。</p>
<p>为了解决这个问题，我们的方法通过在分布式机器之间聚合信息和证明，消除了证明大小中的$N$附加因子。具体来说，Virgo 的原始协议由两个主要构件组成。一个是 GKR 协议 [53]，它由深度为$d$的电路的sumcheck 协议组成。另一个是多项式承诺（PC）方案。我们分别为求和检查和多项式承诺 (PC) 设计了分布式方案。</p>
<p>在我们的分布式 sumcheck 协议中，主节点$P_0$会汇总来自所有机器的信息，然后在每一轮将汇总后的信息发送给 $v$，而不是直接将来自所有机器的信息发送给 𝒱。我们的分布式 sumcheck 协议与原始 sumcheck 协议的证明大小完全相同，因此比原始分布式协议节省了$N$倍。此外，在我们的分布式 PC 协议中，我们优化了承诺阶段，让$P_0$将$N$个承诺聚合成一个，而不是直接将$N$个承诺发送给$v$。在开局阶段，证明也可以聚合在一起，这样就能以多项式大小的对数因子来改善证明的大小。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">jhy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/posts/e15e124.html">http://example.com/posts/e15e124.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Hibara</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/cross-chain/">cross-chain</a></div><div class="post_share"><div class="social-share" data-image="/img/1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/4a17b156.html"><img class="prev-cover" src="/img/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hello World</div></div></a></div><div class="next-post pull-right"><a href="/posts/b537f0e7.html"><img class="next-cover" src="/img/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">DaspTop10</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">jhy</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jhy-3/"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#zkBridge-Trustless-Cross-chain-Bridges-Made-Practical"><span class="toc-number">1.</span> <span class="toc-text">zkBridge: Trustless Cross-chain Bridges Made Practical</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Notation"><span class="toc-number">2.</span> <span class="toc-text">Notation</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#zkBridge"><span class="toc-number">3.</span> <span class="toc-text">zkBridge</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Overview"><span class="toc-number">3.1.</span> <span class="toc-text">Overview</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#detail"><span class="toc-number">3.2.</span> <span class="toc-text">detail</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#security-and-system-model"><span class="toc-number">3.2.1.</span> <span class="toc-text">security and system model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#construction"><span class="toc-number">3.2.2.</span> <span class="toc-text">construction</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Application-cases"><span class="toc-number">3.3.</span> <span class="toc-text">Application cases</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#efficient-proof-systems-for-zkBridge"><span class="toc-number">3.4.</span> <span class="toc-text">efficient proof systems for zkBridge</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Distributed-Proof-Generation"><span class="toc-number">4.</span> <span class="toc-text">Distributed Proof Generation</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/4a17b156.html" title="Hello World"><img src="/img/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/posts/4a17b156.html" title="Hello World">Hello World</a><time datetime="2025-06-24T12:01:22.562Z" title="发表于 2025-06-24 20:01:22">2025-06-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e15e124.html" title="zkBridge"><img src="/img/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="zkBridge"/></a><div class="content"><a class="title" href="/posts/e15e124.html" title="zkBridge">zkBridge</a><time datetime="2024-09-13T11:44:08.000Z" title="发表于 2024-09-13 19:44:08">2024-09-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/b537f0e7.html" title="DaspTop10"><img src="/img/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DaspTop10"/></a><div class="content"><a class="title" href="/posts/b537f0e7.html" title="DaspTop10">DaspTop10</a><time datetime="2024-09-11T13:16:33.000Z" title="发表于 2024-09-11 21:16:33">2024-09-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/294d1009.html" title="ERC20笔记"><img src="/img/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ERC20笔记"/></a><div class="content"><a class="title" href="/posts/294d1009.html" title="ERC20笔记">ERC20笔记</a><time datetime="2024-09-10T03:02:49.000Z" title="发表于 2024-09-10 11:02:49">2024-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/86ac9353.html" title="zkp2"><img src="/img/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="zkp2"/></a><div class="content"><a class="title" href="/posts/86ac9353.html" title="zkp2">zkp2</a><time datetime="2024-07-29T09:27:06.000Z" title="发表于 2024-07-29 17:27:06">2024-07-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By jhy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>