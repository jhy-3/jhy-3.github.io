[{"title":"DaspTop10","url":"/posts/b537f0e7.html","content":"\nDASP TOP 10\nhttps://www.dasp.co/\nThis project is an initiative of NCC Group. It is an open and collaborative project to join efforts in discovering smart contract vulnerabilities within the security community. To get involved, join the github page.\nReentrancy\n重入漏洞\n也称为或与竞空、递归调用漏洞、调用未知相关\n这个漏洞在审查中被许多不同的人漏掉了很多次：审查人员倾向于一次审查一个函数，并假定对安全子程序的调用会按预期安全运行。 -Phil Daian\n重入攻击（Reentrancy attack）可能是最著名的以太坊漏洞，它首次被发现时让所有人都大吃一惊。它是在一次价值数百万美元的抢劫中首次被发现的，这次抢劫导致了以太坊的硬分叉。\n当外部合约调用被允许在初始执行完成之前对调用合约进行新的调用时，就会出现重定向。对于函数来说，这意味着在执行过程中，由于调用了不受信任的合约或使用了带有外部地址的低级函数，合约状态可能会发生变化。\n损失：估计为 350 万个以太坊（当时约合 5000 万美元）\nTimeline of discovery:\n\n\n\nDate\nEvent\n\n\n\n\nJun 5, 2016\nChristian Reitwiessner discovers an antipattern in solidity\n\n\nJun 9, 2016\nMore Ethereum Attacks: Race-To-Empty is the Real Deal (vessenes.com)\n\n\nJun 12, 2016\nNo DAO funds at risk following the Ethereum smart contract ‘recursive call’ bug discovery (blog.slock.it)\n\n\nJun 17, 2016\nI think TheDAO is getting drained right now (reddit.com)\n\n\nAug 24, 2016\nThe History of the DAO and Lessons Learned (blog.slock.it)\n\n\n\n著名事件\n\nThe DAO\n\n举例说明：\n智能合约会跟踪多个外部地址的余额，并允许用户使用其公共 withdraw() 函数取回资金。\n恶意智能合约使用 withdraw() 函数取回全部余额。\n在更新恶意合约的余额之前，受害者合约会执行 call.value(amount)() 低级函数将以太币发送给恶意合约。\n恶意合约有一个可支付的 fallback() 函数，用于接收资金，然后再调用受害者合约的 withdraw() 函数。\n第二次执行会触发资金转移：请记住，恶意合约的余额仍未从第一次提款中更新。因此，恶意合约第二次成功提取了全部余额。\n代码示例：\n下面的函数包含一个容易受到重入攻击的函数。当低级 call() 函数向 msg.sender 地址发送以太坊时，该函数就会受到攻击；如果该地址是智能合约，支付就会使用剩余的交易气体触发回退函数：\nfunction withdraw(uint _amount) &#123;\trequire(balances[msg.sender] &gt;= _amount);\tmsg.sender.call.value(_amount)();\tbalances[msg.sender] -= _amount;&#125;\nAccess Control\n通过调用 initWallet 函数，可以将奇偶校验钱包库合约转化为普通的多重签名钱包，并成为其所有者\n访问控制问题在所有程序中都很常见，不仅仅是智能合约。事实上，它在 OWASP Top 10 中排名第 5。人们通常通过合约的公共或外部函数访问合约的功能。虽然不安全的可见性设置让攻击者可以直接访问合约的私有值或逻辑，但访问控制绕过有时更为隐蔽。当合约使用已废弃的 tx.origin 来验证调用者、使用冗长的 require 来处理大型授权逻辑，以及在代理库或代理合约中肆意使用 delegatecall 时，就会出现这些漏洞。\n例子：\n智能合约指定初始化合约的地址为合约所有者。这是授予特殊权限（如提取合约资金的能力）的常见模式。\n不幸的是，初始化函数可以被任何人调用–甚至在它已经被调用之后。这就允许任何人成为合约的所有者并提取其资金。\n代码例子：\n在下面的示例中，合约的初始化函数将函数的调用者设置为其所有者。然而，该逻辑与合约的构造函数是分离的，它不会跟踪它已被调用的事实。\nfunction initContract() public &#123;\towner = msg.sender;&#125;\n在 Parity 多重签名钱包中，这个初始化函数脱离了钱包本身，而是定义在一个 “库 ”合约中。用户需要通过委托调用库函数来初始化自己的钱包。不幸的是，在我们的例子中，该函数并没有检查钱包是否已经初始化。更糟糕的是，由于库是一个智能合约，任何人都可以初始化库本身并调用销毁它。\nArithmetic Issues\n溢出条件会产生不正确的结果，尤其是在没有预料到这种可能性的情况下，会危及程序的可靠性和安全性。\n整数溢出和下溢并不是一类新的漏洞，但它们在智能合约中尤其危险，因为智能合约中普遍存在无符号整数，而大多数开发人员习惯于使用简单的 int 类型（通常只是有符号整数）。如果出现溢出，许多看似无害的代码路径就会成为盗窃或拒绝服务的载体。\n例子：\n智能合约的 withdraw() 函数允许您取回捐赠给合约的以太币，只要您的余额在操作后仍为正数。\n攻击者试图提取超过其当前余额的以太币。\nwithdraw() 函数的检查结果总是正数，允许攻击者提取超出允许范围的金额。由此产生的余额不足溢出，变得比应有余额大一个数量级。\n代码例子\n最直接的例子就是一个不检查整数下溢的函数，允许你提取无限量的代币：\nfunction withdraw(uint _amount) &#123;\trequire(balances[msg.sender] - _amount &gt; 0);\tmsg.sender.transfer(_amount);\tbalances[msg.sender] -= _amount;&#125;\n第二个例子（在 “狡猾的 Solidity 编码竞赛 ”中发现的）是由于数组的长度用无符号整数表示而产生的偏差：\nfunction popArrayOfThings() &#123;\trequire(arrayOfThings.length &gt;= 0);\tarrayOfThings.length--; &#125;\n第三个例子是第一个例子的变种，即对两个无符号整数进行运算的结果是一个无符号整数：\nfunction votes(uint postId, uint upvote, uint downvotes) &#123;\tif (upvote - downvote &lt; 0) &#123;\t\tdeletePost(postId)\t&#125;&#125;\n第四个示例使用了即将淘汰的 var 关键字。因为 var 将改变自身为包含赋值所需的最小类型，所以它将变成 uint8 来保存值 0。如果循环要遍历 255 次以上，它将永远不会达到这个数字，并会在执行耗尽时停止：\nfor (var i = 0; i &lt; somethingLarge; i ++) &#123;\t// ...&#125;\nUnchecked Return Values For Low Level Calls\n应尽可能避免使用低级 “调用”。如果返回值处理不当，可能会导致意想不到的行为。\n底层函数 call()、callcode()、delegatecall() 和 send() 是 Solidity 的深层特性之一。它们在处理错误时的行为与其他 Solidity 函数截然不同，因为它们不会传播（或冒泡），也不会导致当前执行的完全回退。相反，它们会返回一个设置为 false 的布尔值，代码将继续运行。这可能会让开发人员大吃一惊，而且如果不检查此类低级调用的返回值，可能会导致失败打开和其他不必要的结果。请记住，发送可能会失败！\n代码例子\n下面的代码就是一个例子，说明如果忘记检查 send() 的返回值可能会出现什么问题。如果调用 send() 函数向一个不接受以太币的智能合约发送以太币（例如，因为该合约没有可支付的回退函数），那么 EVM 就会将其返回值替换为 false。由于在我们的示例中没有检查返回值，因此函数对合约状态的更改将不会被还原，etherLeft 变量最终将跟踪一个不正确的值：\nfunction withdraw(uint256 _amount) public &#123;\trequire(balances[msg.sender] &gt;= _amount);\tbalances[msg.sender] -= _amount;\tetherLeft -= _amount;\tmsg.sender.send(_amount);&#125;\nDenial of Service\n在以太坊的世界里，拒绝服务是致命的：其他类型的应用程序最终可以恢复，而智能合约却可能因为一次这样的攻击而永远离线。导致拒绝服务的方式有很多，包括作为交易接收方时的恶意行为、人为增加计算函数所需的气体、滥用访问控制访问智能合约的私有组件、利用混淆和疏忽等。这类攻击包括许多不同的变种，在未来几年可能会有很大的发展。\n例子：\n\n拍卖合约允许用户竞拍不同的资产。\n要出价，用户必须调用 bid(uint object) 函数，并输入所需的以太币金额。拍卖合约会将以太币存入托管账户，直到对象的所有者接受竞价或初始竞价者取消竞价为止。这就意味着拍卖合约的余额中必须包含所有未竞价的以太币。\n拍卖合约还包含一个 withdraw(uint amount) 函数，允许管理员从合约中提取资金。由于该函数会将金额发送到一个硬编码地址，因此开发者决定公开该函数。\n攻击者看到了潜在的攻击机会，于是调用了该函数，将合约的所有资金都转给了管理员。这就破坏了托管承诺，并阻止了所有待定投标。\n虽然管理员可能会将托管资金返还给合约，但攻击者只需再次提取资金就能继续攻击。\n\n代码例子：\n在下面的例子中（灵感来自《以太之王》），如果公开贿赂前任总统，游戏合约的一个功能就可以让你成为总统。不幸的是，如果上一任总统是一个智能合约，并在付款时导致还原，那么权力转移就会失败，恶意智能合约将永远担任总统。听起来像是独裁：\nfunction becomePresident() payable &#123;    require(msg.value &gt;= price); // must pay the price to become president    president.transfer(price);   // we pay the previous president    president = msg.sender;      // we crown the new president    price = price * 2;           // we double the price to become president&#125;\n在第二个例子中，调用者可以决定下一次函数调用将奖励给谁。由于 for 循环中的指令很昂贵，攻击者可以引入一个大到无法迭代的数字（由于以太坊中的气体块限制），这将有效阻止函数的运行。\nfunction selectNextWinners(uint256 _largestWinner) &#123;\tfor(uint256 i = 0; i &lt; largestWinner, i++) &#123;\t\t// heavy code\t&#125;\tlargestWinner = _largestWinner;&#125;\nBad Randomness\n该合约对区块.编号年龄的验证不足，导致 400 ETH 被一名未知玩家抢走，该玩家在等待了 256 个区块后才揭晓了可预测的中奖号码。\n随机性在以太坊中很难实现。虽然 Solidity 提供的函数和变量可以访问明显难以预测的值，但它们通常要么比看上去更公开，要么受到矿工的影响。由于这些随机性来源在一定程度上是可预测的，恶意用户一般可以复制它，并依靠其不可预测性攻击函数。\n例子：\n\n智能合约使用区块号作为游戏的随机性来源。\n攻击者会创建一个恶意合约，检查当前区块编号是否是赢家。如果是，它就会调用第一个智能合约来获胜；由于调用是同一交易的一部分，因此两个合约上的区块链号码将保持不变。\n攻击者只需调用她的恶意合约，直到它获胜为止。\n\n代码例子：\n在第一个例子中，私人种子与迭代次数和 keccak256 哈希函数结合使用，以确定调用者是否获胜。尽管种子是私有的，但它一定是在某个时间点通过交易设置的，因此在区块链上是可见的。\nuint256 private seed;function play() public payable &#123;\trequire(msg.value &gt;= 1 ether);\titeration++;\tuint randomNumber = uint(keccak256(seed + iteration));\tif (randomNumber % 2 == 0) &#123;\t\tmsg.sender.transfer(this.balance);\t&#125;&#125;\n在第二个示例中，block.blockhash 被用来生成一个随机数。如果 blockNumber 被设置为当前的 block.number，那么这个哈希值就是未知的（原因显而易见），因此会被设置为 0。如果 blockNumber 被设置为过去 256 个以上的区块，那么它将始终为 0。最后，如果它被设置为一个不算太旧的前一个区块编号，另一个智能合约就可以访问相同的编号，并调用游戏合约作为同一交易的一部分。\nfunction play() public payable &#123;\trequire(msg.value &gt;= 1 ether);\tif (block.blockhash(blockNumber) % 2 == 0) &#123;\t\tmsg.sender.transfer(this.balance);\t&#125;&#125;\nFront-Running\n事实证明，只需大约 150 行 Python 代码，就能获得一个有效的前端运行算法。\n由于矿工代表外部拥有的地址（EOA）运行代码总能通过气体费获得奖励，因此用户可以指定更高的费用，让自己的交易更快被挖掘出来。由于以太坊区块链是公开的，因此每个人都可以看到其他人的待处理交易内容。这就意味着，如果某个用户透露了谜题的答案或其他有价值的秘密，恶意用户就可以窃取答案，并以更高的费用复制他们的交易，抢占原始答案的先机。如果智能合约的开发者稍有不慎，这种情况就会导致实际的破坏性前置攻击。\n例子：\n\n智能合约发布一个 RSA 数字（N = prime1 x prime2）。\n调用其带有正确质数 1 和质数 2 的 submitSolution() 公共函数，就能获得奖励。\n爱丽丝成功计算出 RSA 数字并提交了解决方案。\n网络上有人看到 Alice 的交易（包含解决方案）正在等待挖矿，于是以更高的天然气价格提交了该交易。\n由于支付的费用较高，第二笔交易首先被矿工选中。攻击者赢得了奖金。\n\nTime manipulation\n如果矿工持有合约的股份，他就可以通过为正在开采的区块选择合适的时间戳来获得优势。\n从锁定代币销售到在游戏的特定时间解锁资金，合约有时需要依赖当前时间。在 Solidity 中，这通常是通过 block.timestamp 或其别名来实现的。但这个值从何而来？来自矿工！由于交易的矿工在报告挖矿发生的时间上有一定的回旋余地，因此好的智能合约会避免强烈依赖所公布的时间。请注意，block.timestamp 有时也会被（误）用于生成随机数，这在 #6 中讨论过。随机性差。\n例子：\n\n一个游戏在今天午夜向第一个玩家支付奖金。\n一个恶意矿工试图赢得游戏，并将时间戳设置为午夜。\n在午夜前一点，矿工最终挖出了区块。真实的当前时间与午夜（当前设置的区块时间戳）“足够接近”，网络上的其他节点决定接受该区块。\n\n代码例子：\n以下函数只接受特定日期之后的调用。由于矿工可以影响其区块的时间戳（在一定程度上），他们可以尝试挖掘一个包含其交易的区块，并将区块时间戳设置在未来。如果时间足够接近，就会被网络接受，在其他玩家试图赢得游戏之前，这笔交易就会给矿工以太币：\nfunction play() public &#123;\trequire(now &gt; 1521763200 &amp;&amp; neverPlayed == true);\tneverPlayed = false;\tmsg.sender.transfer(1500 ether);&#125;\nShort Address Attack\n为令牌传输准备数据的服务部门假定用户将输入 20 字节长的地址，但实际上并没有检查地址的长度。\n短地址攻击是 EVM 本身接受错误填充参数的副作用。攻击者可以利用这一点，使用特制的地址使编码不良的客户端在将参数纳入事务之前对参数进行错误编码。这是 EVM 的问题还是客户端的问题？是否应该在智能合约中解决？虽然每个人都有不同的看法，但事实是，大量以太币可能会受到这个问题的直接影响。虽然这个漏洞尚未被广泛利用，但它很好地展示了客户端与以太坊区块链之间的交互所产生的问题。还存在其他链外问题：其中一个重要问题是以太坊生态系统对特定 Javascript 前端、浏览器插件和公共节点的深度信任。Coindash ICO 遭黑客攻击时使用了一个臭名昭著的链外漏洞，该漏洞修改了该公司网页上的以太坊地址，诱骗参与者向攻击者的地址发送以太坊。\n例子：\n\n一个交易所应用程序接口（API）有一个交易函数，它接收一个收件人地址和一个金额。\n然后，API 与智能合约 transfer(address _to, uint256 _amount)函数交互，并填充参数：在地址（预期长度为 20 字节）前加上 12 个 0 字节，使其长度达到 32 字节。\n鲍勃（0x3bdde1e9fbaef2579dd63e2abbf0be445ab93f00）要求爱丽丝给他转 20 个代币。他恶意地将自己的地址截短，去掉了尾部的 0。\nAlice 使用交换 API 获取了 Bob 较短的 19 字节地址（0x3bdde1e9fbaef2579dd63e2abbf0be445ab93f）。\nAPI 在地址中填充了 12 个零字节，使地址从 32 字节变为 31 字节。这实际上是从下面的 _amount 参数中窃取了一个字节。\n最终，执行智能合约代码的 EVM 会指出数据未正确填充，并在 _amount 参数末尾添加丢失的字节。这样，转移的代币数量实际上比想象的多 256 倍。\n\nUnknown Unknowns\n我们认为，更多的安全审计或更多的测试不会有什么影响。主要问题是审查人员不知道应该注意什么。\n以太坊仍处于起步阶段。用于开发智能合约的主要语言 Solidity 还未达到稳定版本，生态系统的工具仍处于试验阶段。一些最具破坏性的智能合约漏洞让所有人都大吃一惊，没有理由相信不会再出现同样出人意料或同样具有破坏性的漏洞。只要投资者决定将大量资金投入到复杂但未经严格审核的代码上，我们就会不断看到新的发现，从而导致可怕的后果。对智能合约进行正式验证的方法尚未成熟，但它们似乎大有希望摆脱目前摇摇欲坠的现状。随着新的漏洞不断被发现，开发人员需要保持警惕，并开发新的工具，在坏人发现之前找到它们。在智能合约开发达到稳定和成熟的状态之前，这十大漏洞可能会迅速演变。\n"},{"title":"ERC20笔记","url":"/posts/294d1009.html","content":"\nERC-20\nERC20是以太坊上的一种代币，它定义了一组接口（方法和事件），使得代币可以在不同的应用程序，钱包和交易所之间进行互操作。\n原生币和代币\n原生币（ETH）是以太坊区块链的原生加密货币。它直接由区块链协议生成和管理。主要用于支付网络上的交易费用（Gas）以及奖励矿工（现在是验证者）。原生币的交易是直接在区块链上进行的，不需要任何智能合约。以太币的交易地址是由以太坊协议生成的。\n代币（例如ERC20）是通过智能合约创建和管理的加密货币。它们不是区块链的原生币，而是构建在区块链之上的。可以代表各种资产或功能，如稳定币、权益证明、治理代币等。ERC20 代币遵循以太坊改进提案 20（EIP-20）的标准，实现了一组基本的接口和功能，使其能够在去中心化应用（DApps）之间互操作。ERC20 代币的合约地址是由智能合约生成的。\nERC-20标准\n标准规定：6个函数，2个事件，3个变量\ncontract ERC20Interface &#123;  \tfunction totalSupply() public view returns (uint256);  \tfunction balanceOf(address _owner) public view returns (uint256 balance);  \tfunction transfer(address _to, uint256 _value) public returns (bool success);  \tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);  \tfunction approve(address _spender, uint256 _value) public returns (bool success);  \tfunction allowance(address _owner, address _spender) public view returns (uint256 remaining);  \t  \t  \tevent Transfer(address indexed from, address indexed to, uint tokens);    \tevent Approval(address indexed tokenOwner, address indexed spender, uint tokens);    string public constant name = &quot;&quot;;    string public constant symbol = &quot;&quot;;    uint8 public constant decimals = ;  &#125;\n解释\ntotalSupply()\n返回代币的总量\nbalanceOf()\n查询某个账户的代币余额\ntransfer()\n从当前的自己账户，实现代币的交易\ntransferFrom()\n实现用户之间的代币交易（非自己账户）\napprove()\n设置允许某个账户spender从此地址可使用的代币数\nallowance()\n查询某个账户可转账金额，用于控制代币的交易\nevent Transfer(address indexed from, address indexed to, uint tokens)\n当代币被交易时会触发此函数\nevent Approval(address indexed tokenOwner, address indexed spender, uint tokens)\n当成功调用approve函数时会触发此函数\nname\n代币名称\nsymbol\n代币简称\ndecimals\n返回token使用的小数点后几位。比如如果设置为3，就是支持0.001表示。一般为18位。\n变量及函数定义\n定义变量\n一般会定义几个映射变量\nmapping (address =&gt; uint256) public balances\n保存着每个地址对应的余额。\nmapping (address =&gt; mapping (address =&gt; uint256)) public allowed\n两层映射。保存着某个地址A允许另一个地址B可操作的金额。最外层映射为某个地址A，内层映射为另一个地址B，值为可操作（发起交易）金额总量。\n函数实现\nfunction balanceOf(address tokenOwner) public constant returns (uint balance) &#123;       return balances[tokenOwner];&#125;\n从映射变量balances中取出某个地址的余额。\nfunction transfer(address to, uint tokens) public returns (bool success) &#123;    balances[msg.sender] = balances[msg.sender].sub(tokens);    balances[to] = balances[to].add(tokens);    Transfer(msg.sender, to, tokens);    return true;&#125;\n当前账户转账操作\nfunction transferFrom(address from, address to, uint tokens) public returns (bool success)&#123;        balances[from] = balances[from].sub(tokens);        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);        balances[to] = balances[to].add(tokens);        Transfer(from, to, tokens);        return true; &#125;\n用户之间转账操作，由from地址发起转账交易。\nfunction approve(address spender, uint tokens) public returns (bool success) &#123;        allowed[msg.sender][spender] = tokens;        Approval(msg.sender, spender, tokens);        return true; &#125;\n设置某账户spender可操控msg.sender的代币数\nERC20高级功能\n高级功能：代币管理，代币增发，空投代币，代币冻结，销毁代币，代币兑换\n代币管理\n有时代币需要有一个管理者功能\ncontract Owned &#123;    address public owner;    constructor() public &#123;        owner = msg.sender;    &#125;    modifier onlyOwner &#123;        require(msg.sender == owner);        _;    &#125;    function transferOwnership(address newOwner) onlyOwner public &#123;        owner = newOwner;    &#125;&#125;\n如果是 owner 调用这个函数，则函数会被执行，否则会抛出异常。\n代币增发\n代币增发可使代币总供应量增加，可以指定某个账户的代币增加，同时总供应量也随之增加。\nfunction mintToken(address target, uint256 mintedAmount) onlyOwner public &#123;       balances[target] += mintedAmount;       _totalSupply += mintedAmount;       emit Transfer(address(0), address(this), mintedAmount);       emit Transfer(address(this), target, mintedAmount);   &#125;\n代币销毁\n管理者代币销毁\nfunction burn(uint256 _value) onlyOwner public returns (bool success) &#123;       require(balances[owner] &gt;= _value);       balances[owner] -= _value;       _totalSupply -= _value;       emit Burn(owner, _value);       return true;   &#125;\n用户代币销毁\nfunction burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success) &#123;        require(balances[_from] &gt;= _value);        require(_value &lt;= allowed[_from][owner]);        balances[_from] -= _value;        allowed[_from][owner] -= _value;        _totalSupply -= _value;        emit Burn(_from, _value);        return true;    &#125;\n"},{"title":"GSW同态加密","url":"/posts/1a0df74e.html","content":"\n同态加密GSW方案\n本文将介绍同态加密中的一个方案——GSW，它利用近似特征向量技术，设计了无需计算密钥的全同态加密方案。原论文：《Homomorphic Encryption from Learning with Errors: Conceptually-Simpler, Asymptotically-Faster, Attribute-Based》\n\nGSW整体思想\n基本思想\n矩阵有着这样的一个性质：一个矩阵CCC乘以vvv等于一个特征值乘以vvv，vvv是这个矩阵的特征向量，μ\\muμ是特征值:C⋅v=μ⋅mod qC\\cdot v =\\mu \\cdot mod \\ qC⋅v=μ⋅mod q\n那么，我们现在可以把CCC看作密文，vvv看作密钥，要加密的消息是μ\\muμ:\n\n很容易可以发现这个形式具有同态的性质：密文的加或乘相当于明文的加或者乘。\nC1⋅v=μ1⋅v mod qC2⋅v=μ2⋅v mod qC1⋅C1⋅v=μ1⋅μ2⋅v mod qC_1\\cdot v=\\mu_1 \\cdot v\\ mod \\ q \\\\\nC_2\\cdot v=\\mu_2 \\cdot v\\ mod \\ q \\\\\nC_1\\cdot C_1\\cdot v=\\mu_1\\cdot \\mu_2 \\cdot v\\ mod \\ q \nC1​⋅v=μ1​⋅v mod qC2​⋅v=μ2​⋅v mod qC1​⋅C1​⋅v=μ1​⋅μ2​⋅v mod q\n然而，这个形式虽然具有同态的性质，但是很明显非常的不安全，因为找到一个矩阵的特征向量很简单，密钥很容易得到。为了保证安全性，我们可以将其转换为 LWE 的形式：\nC⋅v=μ⋅v+e mod qC\\cdot v =\\mu \\cdot v +e \\ mod \\ qC⋅v=μ⋅v+e mod q，\n其中，CCC代表密文，μ\\muμ代表消息，eee代表密钥，是系数很小的噪声向量(e&lt;&lt;qe&lt;&lt;qe&lt;&lt;q)，vvv是一个近似特征向量。\n同态性质\n我们来验证一下这个方案的同态性质：\nC1⋅v=μ1⋅v+e1 mod q, C2⋅v=μ2⋅v+e2 mod qC_1\\cdot v =\\mu_1 \\cdot v +e_1 \\ mod \\ q,\\ C_2\\cdot v =\\mu_2 \\cdot v +e_2 \\ mod \\ qC1​⋅v=μ1​⋅v+e1​ mod q, C2​⋅v=μ2​⋅v+e2​ mod q\n加法运算:(C1+C2)⋅v=(μ1+μ2)⋅v+(e1+e2) mod q(C_1+C_2)\\cdot v=(\\mu_1+\\mu_2)\\cdot v +(e_1+e_2)\\ mod\\ q(C1​+C2​)⋅v=(μ1​+μ2​)⋅v+(e1​+e2​) mod q\n乘法运算：(C1×C2)⋅v=C1⋅(μ2⋅v+e2)=(μ1⋅μ2)⋅v+(μ2⋅e1+C1⋅e2)(C_1 \\times C_2)\\cdot v =C_1\\cdot (\\mu_2\\cdot v+e_2)=(\\mu_1\\cdot \\mu_2)\\cdot v+(\\mu_2\\cdot e_1+C_1\\cdot e_2)(C1​×C2​)⋅v=C1​⋅(μ2​⋅v+e2​)=(μ1​⋅μ2​)⋅v+(μ2​⋅e1​+C1​⋅e2​)\n同态加法和乘法满足，但乘法会导致额外噪声的出现。\n噪声处理\n为了让这个噪声项尽量小，我们对这个新的噪声进行分析：\n\n可以减小μ2\\mu_2μ2​，即让消息空间变小。要达到这个目的仅需将消息空间设置成{0,1}\\{0,1\\}{0,1}即可。GSW 方案中使用与非门 (NAND gats) 可将消息空间设置成{0,1}\\{0,1\\}{0,1}。\n可以使密文 CCC变小。密文可能是两个密文的乘法，即使初始的密文很小，计算后也可能得到较大的密文。是否能有什么技术能够使得密文一直保持在很小的范围内（甚至在 {0, 1} 内）？文中提出一种 Flatten ciphertext 的技术。\n\n密文大小限制\n限制密文大小：分解技术\n我们有以下定义：\na∈Zqka\\in Z^k_qa∈Zqk​其中k是维度，q是模。l=logq+1l=log_q+1l=logq​+1是q的对数，N=k⋅lN=k\\cdot lN=k⋅l\n有一些函数：\n\nBitDecomp(a)=(a1,0,...,a1,l−1,...,ak,0,...,ak,l−1)BitDecomp(a)=(a_{1,0},...,a_{1,l-1},...,a_{k,0},...,a_{k,l-1})BitDecomp(a)=(a1,0​,...,a1,l−1​,...,ak,0​,...,ak,l−1​)是a的每个系数的比特分解，从低位到高位\nBitDecomp−1(b∈ZqN)BitDecomp^{-1}(b\\in Z^N_q)BitDecomp−1(b∈ZqN​)是上面分解函数的逆分解\nFlattern(b∈ZqN)=BitDecomp(BitDecomp−1(b))Flattern(b\\in Z^N_q)=BitDecomp(BitDecomp^{-1}(b))Flattern(b∈ZqN​)=BitDecomp(BitDecomp−1(b))是一个系数都在{0,1}\\{0,1\\}{0,1}中的向量\nPowersof2(s)=(s1,2s1,...,2l−1s1,...,sk,2sk,...,2l−1sk)Powersof2(s)=(s_1,2s_1,...,2^{l-1}s_1,...,s_k,2s_k,...,2^{l-1}s_k)Powersof2(s)=(s1​,2s1​,...,2l−1s1​,...,sk​,2sk​,...,2l−1sk​)\n\n然后我们给出近似特征向量的一个特殊形式：v=Powersof2(s)v=Powersof2(s)v=Powersof2(s)其中s是随机的\n开始 Flatten Ciphertext （展平密文）：\n\n假设对于一个与非门（NAND）： $C^{NAND}=I_N-C_1\\cdot C_2\\ mod\\ q $\n令 C3←Flatten(CNAND)C_3\\larr Flatten(C^{NAND})C3​←Flatten(CNAND)为CNANDC^{NAND}CNAND每一行的展开结果，C3C_3C3​中所有的系数都在集合{0,1}\\{0,1\\}{0,1}中\nC3⋅v=CNAND⋅v mod qC_3\\cdot v=C^{NAND}\\cdot v\\ mod\\ qC3​⋅v=CNAND⋅v mod q我们没有改变加密的消息，甚至没有增加噪声。\n\nGSW加密方案\n\n\nSetup(1n,1L)Setup(1^n,1^L)Setup(1n,1L)，选择k=k(λ,L)k=k(\\lambda,L)k=k(λ,L)bit的模q，格的维度参数是n=n(λ,L)n=n(\\lambda,L)n=n(λ,L)，适当的为LWE取误差分布X=X(λ,L)X=X(\\lambda,L)X=X(λ,L)使得在已知攻击下达到2λ2^{\\lambda}2λ的安全性。同时，选择参数m=m(λ,L)=O(nlogq)m=m(\\lambda,L)=O(nlogq)m=m(λ,L)=O(nlogq)，参数params=(n,q,X,m)params=(n,q,X,m)params=(n,q,X,m)，令l=logq+1,N=(n+1)⋅ll=log_q+1,N=(n+1)\\cdot ll=logq​+1,N=(n+1)⋅l\n\n\nKeyGen(params)KeyGen(params)KeyGen(params)，采样t←Zqnt\\larr Z^n_qt←Zqn​，输出sk=s←(1,−t1,...,−tn)∈Zqn+1sk=s\\larr (1,-t_1,...,-t_n)\\in Z_q^{n+1}sk=s←(1,−t1​,...,−tn​)∈Zqn+1​，v←Powersof2(s)∈ZqNv\\larr Powersof2(s)\\in Z_q^Nv←Powersof2(s)∈ZqN​\n\n\nPubKeyGen(params,sk)PubKeyGen(params,sk)PubKeyGen(params,sk)，均匀生成一个矩阵B←Zqm×nB\\larr Z^{m\\times n}_qB←Zqm×n​和一个向量e←χme\\larr \\chi ^me←χm，设b=B⋅t+eb=B\\cdot t+eb=B⋅t+e，设A为（n+1）列矩阵，设置公钥pk=Apk=Apk=A，公钥可以看作一个LWE实例，是由向量组成的矩阵，且与密钥点积得到的结果很小。\n\n\nEnc(A,μ)Enc(A,\\mu)Enc(A,μ)，为了加密消息μ∈Zq\\mu\\in Z_qμ∈Zq​，均匀采样一个矩阵R∈{0,1}N×mR\\in \\{0,1\\}^{N\\times m}R∈{0,1}N×m，可得A⋅RA\\cdot RA⋅R的每一行为0的加密，因为他们与密钥的点积的结果非常小，同时输出如下密文:\n\n\nC=Flatten(μ⋅IN+BitDecomp(R⋅A))∈ZqN×NC=Flatten(\\mu \\cdot I_N+BitDecomp(R\\cdot A))\\in Z_q^{N\\times N}\nC=Flatten(μ⋅IN​+BitDecomp(R⋅A))∈ZqN×N​\n\n解密Dec(C,v)Dec(C,v)Dec(C,v)，计算C⋅v=μ⋅v+BitDecomp(R⋅A)⋅v=μ⋅v+R⋅A⋅s=μ⋅v+smallC\\cdot v=\\mu \\cdot v+BitDecomp(R\\cdot A) \\cdot v =\\mu \\cdot v+ R\\cdot A\\cdot s=\\mu \\cdot v+smallC⋅v=μ⋅v+BitDecomp(R⋅A)⋅v=μ⋅v+R⋅A⋅s=μ⋅v+small\n\n\n\n同态操作：在密文上进行加法/乘法后，展平密文。\n\n加法，Add(C1,C2)=Flattem(C1+C2)Add(C_1,C_2)=Flattem(C_1+C_2)Add(C1​,C2​)=Flattem(C1​+C2​)，噪音为e1+e2e_1+e_2e1​+e2​，增长因子为20\n","categories":["同态加密"],"tags":["同态加密"]},{"title":"Introduction_to_Security_Reduction翻译","url":"/posts/460fc444.html","content":"\n本文将翻译Fuchun Guo老师所编写的Introduction to Security Reduction一书，本书主要讲述密码学协议是如何构造一个安全性证明的。\nIntroduction to Security Reduction\nhttps://doi.org/10.1007/978-3-319-93049-7\nPreface\n安全还原（原文是security reduction，也可以说是安全性降低）是证明公钥密码学安全性的一种非常流行的方法。粗略地说，通过安全还原，我们可以证明破解一个方案就像解决一个数学难题一样困难。然而，如何利用对手的自适应攻击来编制正确的安全还原是相当复杂的。原因在于，并不存在适用于所有建议方案的通用安全还原。\n密码学研究论文中给出的安全还原通常很难被初学者完全理解。为了帮助初学者，一些密码学教科书用较简单的例子说明了如何正确编制安全还原程序。不过，研究论文和以往教科书中提到的安全还原通常是针对特定方案的。不同方案的安全还原不同，导致初学者无所适从。我们需要一本系统介绍如何为密码系统（而非特定方案）正确编写安全还原程序的书籍。有鉴于此，我们编写了这本书，希望能帮助读者了解如何正确编写安全还原程序。\n本书的内容，尤其是安全裁减的基础，是基于我们的理解和经验。读者可能会发现，书中对概念的解释与其他资料略有不同，因为我们添加了一些 “佐料”，以帮助读者理解这些概念。例如，在安全还原中，对手不是黑盒对手，而是拥有无限制计算能力的恶意对手。我们原以为本书能在一年内完成，但我们低估了它的难度。我们花了四年多的时间才完成本书的写作。肯定还有一些错误尚未发现。欢迎大家提出意见和建议。\nAcknowledgements\nPass!\nGuide to This Book\n在公钥密码学中，构建可证明安全的密码系统的第一步是明确其密码学概念，并正式定义算法及其相应的安全模型。密码学概念有助于读者理解算法的定义，而安全模型对于衡量所提方案的强度至关重要。方案构建和安全证明都需要相应的密码学基础知识。有鉴于此，我们按照图 1.1 所示的可证明安全方案的工作过程来安排本书的章节。\n\n图1.1：构建可证明安全的公钥加密方案的步骤\n公钥密码学中有两种流行的安全证明方法，即基于博弈的证明和基于模拟的证明。前者又可分为两类，即安全还原和博弈跳转。本书只涉及安全还原，它首先假设存在一个能破解所提方案的对手。在有安全还原的安全证明中，具体的安全还原取决于相应的密码系统、方案和基础难题。目前还没有通用的方法来为所有方案编制安全还原。本书介绍了三种特定密码系统的安全还原：数字签名、公钥加密和基于身份的加密。本书给出的所有示例和方案都是在有或没有双线性映射的循环群上构建的。\n各章内容概述如下。第 2 章简要回顾了密码学概念、算法和安全模型。如果读者熟悉定义，可以跳过本章。第 3 章介绍了基于群的密码学基础：我们介绍了有限域、循环群、双线性配对和哈希函数。我们的介绍主要集中在高效可计算运算和群表示。我们尽量减少对分组密码学初步知识的描述。第 4 章是本书最重要的一章。在这一章中，我们对安全还原的基本概念进行了分类和解释，并总结了如何对数字签名和加密进行全面的安全还原编程。在有必要举例说明概念时，我们以基于组的密码学为例。本书其余各章专门介绍一些选定方案的安全证明，以帮助读者理解如何正确编程安全还原。每个选定方案的安全证明都对应一种有用的还原技术。\n关于符号。本书倾向于使用以下符号。相同的符号在不同的应用中可能有不同的含义。\nFor mathematical primitives:\n\n\nq,pq,pq,p：素数\n\n\nFqnF_{q^n}Fqn​：有限域，有限域的阶表示为pⁿ（p是素数、n是正整数）\n\n\nkkk：扩展域F(qn)kF_{(q^n)^k}F(qn)k​的嵌入度，嵌入度（embedding degree）指的是将有限域F的元素扩展到更大扩域中的最小次数。换句话说，它是将F的元素映射到一个具有更高次数的扩域中所需的最小扩展次数。\n\n\nZpZ_pZp​：整数集合{0,1,2,...,p−1}\\{0,1,2,...,p-1\\}{0,1,2,...,p−1}\n\n\nZp∗Z_p^*Zp∗​：整数集合{1,2,...,p−1}\\{1,2,...,p-1\\}{1,2,...,p−1}\n\n\nHHH：一个一般群\n\n\nGGG：一个素阶循环群，其中群的阶（元素个数）为一个素数p。\n\n\nu,vu,vu,v：域或群中的一般元素\n\n\ng,hg,hg,h：循环群中的所有元素\n\n\nw,x,y,zw,x,y,zw,x,y,z：一个整数集合中的整数，例如ZpZ_pZp​\n\n\neee：一个双线性映射（是一种从两个向量空间到一个标量域的映射）\n\n\nFor scheme constructions:\n\n\nλ\\lambdaλ：一个安全参数\n\n\n(G,g,p)(G,g,p)(G,g,p)：一个具有素数阶 p 的一般循环群 G，其中 g 是 G 的一个生成元。\n\n\n∣p∣|p|∣p∣：在二进制表示中，数值 p 的比特长度。\n\n\n∣g∣|g|∣g∣：在二进制表示中，群元素 g 的比特长度。\n\n\n∣G∣|G|∣G∣：群 G 中群元素的数量。\n\n\nPG=(G,GT,g,p,e)PG=(G,G_T,g,p,e)PG=(G,GT​,g,p,e)：一个配对群，由两个具有相同素数阶数 p 的群 GGG 和 GtG_tGt​ 组成，其中 G 的生成元为 g，并且具有一个双线性映射 e:G×F→GTe:G\\times F\\rarr G_Te:G×F→GT​。\n\n\n{0,1}∗\\{0,1\\}^*{0,1}∗：任意长度所有可能的二进制序列\n\n\n{0,1}n\\{0,1\\}^n{0,1}n：n比特长度的所有可能的二进制序列\n\n\nα,β,γ\\alpha, \\beta, \\gammaα,β,γ：ZpZ_pZp​中的随机整数作为密钥\n\n\ng,h,u,vg,h,u,vg,h,u,v：群元素\n\n\nr,sr,sr,s：ZpZ_pZp​中的随机数字\n\n\nnnn：与相应情景相关联的一个一般正数。\n\n\ni,ji,ji,j：索引\n\n\nmmm：明文\n\n\nσm=(σ1,σ2,..,σn)\\sigma_m=(\\sigma_1,\\sigma_2,..,\\sigma_n)σm​=(σ1​,σ2​,..,σn​)：m的签名，其中σi\\sigma_iσi​表示第i个元素\n\n\nCT=(C1,C2,...,Cn)CT=(C_1,C_2,...,C_n)CT=(C1​,C2​,...,Cn​)：密文CiC_iCi​\n\n\n(pk,sk)(pk,sk)(pk,sk)：一对密钥，其中pk表示公钥，sk表示私钥。\n\n\ndIDd_{ID}dID​：在基于身份的加密中，与身份ID相关联的私钥。\n\n\nFor hard problems:\n\nIII：一个数学困难问题的实例。\nZZZ：在一个决策性困难问题的实例中将要判断的目标，其中Z可以是一个真元素或者一个假元素。\ng,h,u,vg,h,u,vg,h,u,v：群元素。\na,b,ca,b,ca,b,c：问题实例III中从ZpZ_pZp​中随机选择且未知的指数。\nF(x),f(x),g(x)F(x),f(x),g(x)F(x),f(x),g(x)：在Zp[x]Z_p[x]Zp​[x]中的（随机）多项式，即多项式中的所有系数都是从ZpZ_pZp​中随机选择的。\nFi,Gi,fi,aiF_i,G_i,f_i,a_iFi​,Gi​,fi​,ai​：多项式中xi的系数。\nn,k,ln,k,ln,k,l：与相应情景相关联的一般正整数。\n\nFor security models and security proofs:\n\nA\\mathcal{A}A：攻击者（adversary）\nC\\mathcal{C}C：挑战者（challenger）\nB\\mathcal{B}B：模拟器（simulator）\nε\\varepsilonε：打破方案或解决困难问题的优势（advantage）\nttt：打破方案所需的时间成本（time cost）\nqqq：与底层困难问题相关的数字\nqsq_sqs​： 签名查询的数量（signature queries）\nqkq_kqk​：身份基础密码学中私钥查询的数量（private-key queries）\nqdq_dqd​：解密查询的数量（decryption queries）\nqHq_HqH​：随机预言机的哈希查询数量（hash queries to random oracles）\nc,coinc,coinc,coin：从{0,1}中随机选择的比特位\nw,x,y,zw,x,y,zw,x,y,z：模拟器从Zp中选择的秘密和随机数\nTsT_sTs​：安全性约简的时间成本（time cost of security reduction）\n\n研究学生须知。安全还原需要非常棘手的分析。即使你能理解别人的安全还原，但要为自己的方案编制一个正确的安全还原，可能仍有难度。中国有句传统谚语\nSeeing once is better than hearing 100 times ,but doing once is better than seeing 100 timesSeeing\\ once\\ is\\ better\\ than\\ hearing\\ 100\\ times\\ ,\\\\ but\\ doing\\ once\\ is\\ better\\ than\\ seeing\\ 100\\ times\nSeeing once is better than hearing 100 times ,but doing once is better than seeing 100 times\n&quot;百闻不如一见，百见不如一做&quot;。\n为了更好地利用本书，你可以在阅读本书给出的安全证明（看）之前，根据第 4 章的知识尝试证明（做）书中提供的方案。这样，你就能更清楚地了解哪个部分对你来说最难，以及如何正确编程安全还原。读者可以访问作者的主页，查找本书的补充资源。\nNotions, Definitions, and Models\n在本章中，我们简要回顾了数字签名、公钥加密和基于身份的加密的重要知识，包括密码学概念、算法和安全模型。为了方便演示，我们将数字签名和公钥加密的传统密钥生成算法分为系统参数生成算法和密钥生成算法，其中系统参数可以由所有用户共享。本书中的每个密码系统由四个算法组成。\nDigital Signatures\n数字签名是密码学中的一种基本工具，被广泛应用于身份验证和不可否认性。以身份验证为例。假设一方，比如Alice，希望说服其他所有方，证明一条消息m是由她发布的。为此，Alice生成一个公钥/私钥对(pk,sk)，并将公钥pk发布给所有的验证者。为了在消息m上生成一个签名σm\\sigma _mσm​，她使用她的私钥sk对m进行数字签名。收到(m,σm)(m,\\sigma _m)(m,σm​)的任何已知pk的接收方可以验证签名σm\\sigma _mσm​，并确认消息m的来源。\n数字签名方案包括以下四个算法：\n**SysGen: ** 系统参数生成算法以安全参数 λ\\lambdaλ 作为输入，并返回系统参数 SPSPSP\n**KeyGen:  ** 密钥生成算法以系统参数 SPSPSP 作为输入，并返回公钥/私钥对 (sk,pk)(sk,pk)(sk,pk)\n**Sign: ** 签名算法以消息空间中的消息 mmm、私钥 sksksk 和系统参数 SPSPSP 作为输入，并返回用 σm\\sigma _mσm​ 表示的消息 mmm 的签名。\n**Verify: ** 验证算法以消息-签名对 (m,σm)(m, \\sigma_m)(m,σm​)、公钥 pkpkpk 和系统参数 SPSPSP 作为输入。如果 σm\\sigma_mσm​ 是使用私钥 sksksk 对 mmm 进行签名的有效签名，则返回“接受”；否则，返回“拒绝”\n正确性：对于任意的 (pk,sk,m,σm)(pk, sk, m, σ_m)(pk,sk,m,σm​)，如果 σmσ_mσm​ 是使用私钥 sksksk 对 mmm 进行签名的有效签名，则在 (m,σm,pk)(m, σ_m, pk)(m,σm​,pk) 上运行的验证算法将返回“接受”。\n安全性：在没有私钥 sksksk 的情况下，任何概率多项式时间(PPT)的对手很难伪造一个能通过签名验证的新消息 mmm 的有效签名 σmσ_mσm​。\n在数字签名的安全模型中，安全性通过一个由挑战者和对手玩的游戏来建模。在他们之间的互动过程中，挑战者生成一个签名方案，而对手则试图破解这个方案。也就是说，挑战者首先生成一个密钥对 (pk,sk)(pk, sk)(pk,sk)，将公钥 pkpkpk 发送给对手，而保留私钥。然后，对手可以对由自己选择的任何消息进行适应性查询。最后，对手返回一个未被查询过的新消息的伪造签名。这种安全概念被称为存在性不可伪造性。\n存在性不可伪造性（EU-CMA）的安全模型可以描述如下：\n设置阶段：令 SPSPSP 为系统参数。挑战者运行密钥生成算法以生成密钥对 (pk,sk)(pk, sk)(pk,sk)，并将 pkpkpk 发送给对手。挑战者保留 sksksk 以响应对手的签名查询。\n查询阶段：对手根据自己的选择进行消息的签名查询。对于消息 mim_imi​ 的签名查询，挑战者运行签名算法计算 σmiσ_{m_i}σmi​​，并将其发送给对手。\n伪造阶段：对手返回一个在某个消息 m∗m^*m∗ 上的伪造签名 σm∗σ_{m^∗}σm∗​ 并且在游戏中获胜，如果：\n\nσm∗σ_{m^∗}σm∗​ 是消息 m∗m^∗m∗ 的有效签名。\n在查询阶段，没有对消息 m∗m^*m∗ 进行签名查询。\n\n获胜游戏的优势 εεε 是返回有效伪造签名的概率。\n**定义2.1.0.1（EU-CMA）**在 EU-CMA 安全模型中，如果不存在能够在时间 ttt 内进行 qsq_sqs​ 次签名查询后以优势 εεε 赢得上述游戏的对手，则签名方案被称为 (t,qs,ε)−(t,q_s,ε)-(t,qs​,ε)−安全。\n更强的数字签名安全模型定义如下。\n**定义2.1.0.1（SU-CMA）**在针对强存在性不可伪造性的选择消息攻击（SU-CMA）的安全模型中，如果不存在能够在时间 ttt 内进行 qsq_sqs​ 次签名查询后以优势 εεε 赢得上述游戏的对手，则签名方案被称为 (t,qs,ε)−(t,qs,ε)-(t,qs,ε)−安全。在这种情况下，伪造的签名可以是任意消息，只要它与所有查询的签名都不相同。\n在（标准）数字签名的定义中，私钥 sksksk 在签名生成期间不需要更新。我们将这种签名称为无状态签名（stateless signature）。相反，如果在生成每个签名之前需要更新私钥 sk，则称之为有状态签名（stateful signature）。本书将在第6.3节和第6.5节介绍有状态签名方案。\nPublic-Key Encryption\n公钥加密是公钥密码体系中的另一个重要工具，已经证明了许多有用的应用，如数据机密性、密钥交换、遗忘传输等。以数据机密性为例，假设一方（称为Bob）希望将敏感消息 m 发送给另一方（称为Alice），尽管他们没有共享任何秘密密钥。Alice首先生成一个公钥/私钥对（pk, sk），并将她的公钥 pk 公开给所有发送者。使用 pk，Bob可以将敏感消息 m 加密，并将得到的密文发送给Alice。Alice可以使用私钥 sk 解密密文，并获取消息 m。\n公钥加密方案包括以下四个算法。\nSysGen：系统参数生成算法以安全参数λ\\lambdaλ作为输入，返回系统参数SP。\nKeyGen：密钥生成算法以系统参数SPSPSP作为输入，返回公钥/私钥对(pk,sk)(pk,sk)(pk,sk)。\nEncrypt：加密算法以来自其消息空间的消息mmm、公钥pkpkpk和系统参数SPSPSP作为输入，返回密文CT=E[SP,pk,m]CT = E[SP,pk,m]CT=E[SP,pk,m]。\nDecrypt：解密算法以密文CTCTCT、私钥sksksk和系统参数SPSPSP作为输入，返回消息mmm或输出⊥⊥⊥表示失败。\n正确性：对于任意的(SP,pk,sk,m,CT)(SP,pk,sk,m,CT)(SP,pk,sk,m,CT)，如果CT=E[SP,pk,m]CT = E[SP,pk,m]CT=E[SP,pk,m]是使用公钥pkpkpk对消息mmm进行加密得到的密文，则使用私钥sksksk对CTCTCT进行解密将返回原始消息mmm。\n安全性：在没有私钥sksksk的情况下，对于任何概率多项式时间（PPT）的对手来说，从给定的密文CT=E[SP,pk,m]CT = E[SP,pk,m]CT=E[SP,pk,m]中提取消息m是困难的。\n公钥加密的不可区分性安全性通过由挑战者和对手进行的一场游戏来建模。挑战者生成加密方案，而对手试图破解该方案。开始时，挑战者生成一个密钥对(pk,sk)(pk,sk)(pk,sk)，将公钥pkpkpk发送给对手，并保留私钥sksksk。对手从相同消息空间中输出两个不同的消息m0,m1m_0,m_1m0​,m1​作为挑战。挑战者在{m0,m1}\\{m_0,m_1\\}{m0​,m1​}中随机选择一条消息mcm_cmc​，生成一个挑战密文CT∗CT^∗CT∗。如果允许进行解密查询，对手可以对由对手自己自适应选择的任意密文进行解密查询，但不允许对CT∗CT^∗CT∗进行解密查询。最后，对手输出对挑战密文CT∗CT^∗CT∗中所选择的消息mcm_cmc​的猜测。\n形式化地，针对选择密文攻击的不可区分性安全（IND-CCA）模型可以描述如下：\n设置：令SPSPSP为系统参数。挑战者运行密钥生成算法以生成密钥对(pk,sk)(pk,sk)(pk,sk)，并将pkpkpk发送给对手。挑战者保留sksksk以回应对手的解密查询。\n第一阶段：对手可以在由对手自己自适应选择的密文上进行解密查询。对于对密文CTiCT_iCTi​的解密查询，挑战者运行解密算法，然后将解密结果发送给对手。\n挑战：对手从相同消息空间中自适应选择两个不同的消息m0m_0m0​、m1m_1m1​。挑战者随机选择一个比特c∈{0,1}c \\in \\{0,1\\}c∈{0,1}，然后计算一个挑战密文CT∗=E[SP,pk,mc]CT^∗ = E[SP,pk,m_c]CT∗=E[SP,pk,mc​]，并将其提供给对手。\n第二阶段：挑战者以与第一阶段相同的方式回应解密查询，但限制不允许对CT∗CT^∗CT∗进行解密查询。\n猜测：对手输出一个对c的猜测c0，并且如果c0 = c，则对手赢得游戏。对手在赢得这个游戏中的优势ε定义为：\nε=2(Pr[c′=c]−12)\\varepsilon=2(Pr[c^{\\prime}=c]-\\frac{1}{2})\nε=2(Pr[c′=c]−21​)\n定义2.2.0.1（IND-CCA）：在IND-CCA安全模型下，如果不存在能够在时间t内进行qdq_dqd​个解密查询的对手能够以优势εεε赢得上述游戏，则公钥加密方案是(t,qd,ε)(t,q_d,ε)(t,qd​,ε)-安全的。\n一般情况下，我们认为IND-CCA模型是加密安全性的标准安全模型。还有一个较弱的不可区分性版本，即针对已知明文攻击的不可区分性（IND-CPA），也称为语义安全性，其定义如下。\n定义2.2.0.2（IND-CPA）：在不可区分选择明文攻击（IND-CPA）的安全模型下，公钥加密方案是(t,ε)(t,ε)(t,ε)安全的，如果该方案在IND-CCA安全模型中是(t,0,ε)(t,0,ε)(t,0,ε)安全的，其中对手不被允许进行任何解密查询。\n在安全模型的描述中，挑战者选择一个随机硬币来决定在挑战阶段要加密的消息。在本书中，我们用符号c∈{0,1}c ∈ \\{0,1\\}c∈{0,1}或符号coin∈{0,1}coin ∈ \\{0,1\\}coin∈{0,1}来表示随机硬币，如果c已经在难度假设中使用过。\nIdentity-Based Encryption\n身份基加密（IBE）是由公钥加密的一个劣势所激发的，即每个公钥看起来都像是一个随机字符串，因此公钥加密需要一个证书系统。在IBE的概念中，有一个由私钥生成器（PKG）生成的主密钥对(mpk,msk)(mpk,msk)(mpk,msk)。主公钥mpk被发布给所有用户，主秘钥msk由PKG保留。假设一方，比如Bob，想要向另一方，比如Alice，发送一条敏感消息。Bob只需使用主公钥mpk和Alice的身份ID（比如Alice的电子邮件地址）对消息进行加密。Alice使用她的私钥dIDd_{ID}dID​对密文进行解密，该私钥由PKG使用身份ID和主秘钥msk计算得到。\nIBE方案只需要所有加密者验证主公钥mpk的有效性。因此，他们不需要验证接收者的公钥，因为公钥就是接收者的身份信息。只有匹配身份信息的接收者才能从PKG获取其私钥并解密相应的密文。IBE允许Bob使用Alice的姓名作为身份来加密消息；然后Alice向PKG申请相应的私钥。在本书中，解密密钥在PKE中被称为秘密密钥；而在IBE中，解密密钥被称为私钥。\n一个身份基加密方案包括以下四个算法。\n设置：设置算法以安全参数λ作为输入。它返回一个主公钥/秘密钥对(mpk,msk)(mpk,msk)(mpk,msk)。\n密钥生成：密钥生成算法以身份ID和主密钥对(mpk,msk)(mpk,msk)(mpk,msk)作为输入。它返回ID的私钥dIDd_{ID}dID​。\n加密：加密算法以来自其消息空间的消息m，身份ID和主公钥mpk作为输入。它返回一个密文CT=E[mpk,ID,m]CT = E[mpk,ID,m]CT=E[mpk,ID,m]。\n解密：解密算法以ID的密文CT，私钥dIDd_{ID}dID​和主公钥mpk作为输入。它返回一个消息m或输出⊥⊥⊥表示失败。\n正确性：对于任何（mpk，msk，ID，dID，m，CT），如果CT = E[mpk，ID，m]是使用ID对消息m进行加密的密文，则使用私钥dID解密CT将返回消息m。\n安全性：在没有私钥dIDd_{ID}dID​的情况下，任何PPT对手很难从给定的密文CT=E[mpk,ID,m]CT = E[mpk,ID,m]CT=E[mpk,ID,m]中提取消息。\n身份基加密的不可区分性安全性是由挑战者和对手进行的一种游戏模型来建模的。挑战者生成一个IBE方案，而对手试图破解该方案。首先，挑战者生成一个主密钥对(mpk,msk)(mpk,msk)(mpk,msk)，将主公钥mpk发送给对手，并保留主秘钥msk。对手输出两个不同的消息m0，m1和一个要挑战的身份ID∗ID^∗ID∗。挑战者为ID∗ID^∗ID∗从{m0,m1}\\{m0,m1\\}{m0,m1}中随机选择一个消息生成一个挑战密文CT∗CT^∗CT∗。在游戏过程中，对手可以自适应地对除了挑战身份之外的任何身份进行私钥查询，并可以对除了挑战密文之外的任何密文进行解密查询。特别地，对手可以对满足(ID=ID∗,CT≠CT∗)(ID = ID^∗,CT \\ne CT^∗)(ID=ID∗,CT​=CT∗)或(ID≠ID∗,CT=CT∗)(ID \\ne ID^∗,CT = CT^∗)(ID​=ID∗,CT=CT∗)的(ID,CT)(ID,CT)(ID,CT)进行解密查询。最后，对手输出对于挑战密文CT∗CT^∗CT∗中选择的消息的猜测。\n对于选择密文攻击（IND-CCA）的不可区分性安全性模型可以描述如下。\n设置：挑战者运行设置算法生成主密钥对（mpk，msk），并将mpk发送给对手。挑战者保留msk以回应对手的查询。\n第一阶段：对手进行私钥查询和解密查询，其中身份和密文由对手自适应选择。\n• 对于关于 IDiID_iIDi​ 的私钥查询，挑战者使用主密钥 mskmskmsk 在 IDiID_iIDi​ 上运行密钥生成算法，然后将 dIDid_{ID_i}dIDi​​ 发送给对手。\n• 对于关于(IDi,CTi)(ID_i,CT_i)(IDi​,CTi​)的解密查询，挑战者使用私钥 dIDid_{ID_i}dIDi​​ 运行解密算法，然后将解密结果发送给对手。\n挑战：对手输出两个不同的消息 m0,m1m_0,m_1m0​,m1​，这两个消息来自相同的消息空间，并选择一个要进行挑战的标识符 ID∗ID^∗ID∗。其中 m0,m1m_0,m_1m0​,m1​ 和 ID∗ID^∗ID∗ 均由对手自己自适应地选择。在 Phase 1 中，我们要求没有查询过 ID∗ID^∗ID∗ 的私钥。挑战者随机选择一个 c∈{0,1}c ∈ \\{0,1\\}c∈{0,1}，然后计算一个挑战密文 CT∗=E[mpk,ID∗,mc]CT^∗ = E[mpk,ID^∗,m_c]CT∗=E[mpk,ID∗,mc​]，并将该密文给予对手。\n第二阶段： 挑战者对私钥查询和解密查询的回应方式与 Phase 1 相同，但有以下限制：不允许对 ID∗ID^∗ID∗ 进行私钥查询，也不允许对 (ID∗,CT∗)(ID^∗,CT^∗)(ID∗,CT∗) 进行解密查询。\nGuess. 对手输出一个猜测 c′c^{\\prime}c′ 关于 c，并在 c′c^{\\prime}c′ = c 时赢得游戏。对手在赢得该游戏中的优势 ε 定义为：\nϵ=2(Pr[c′=c]−12)\\epsilon = 2 (Pr[c^{\\prime}=c]-\\frac{1}{2})\nϵ=2(Pr[c′=c]−21​)\n定义 2.3.0.1 (IND-ID-CCA)：如果不存在任何在时间 t 内通过进行 qkq_kqk​ 次私钥查询和 qdq_dqd​ 次解密查询来获得优势 εεε 的对手能够赢得上述游戏，则基于身份的加密方案在 IND-ID-CCA 安全模型中是 (t,qk,qd,ε)(t,q_k,q_d,ε)(t,qk​,qd​,ε)-安全的。\n存在两个更弱的安全模型，定义如下： 定义 2.3.0.2 (IND-sID-CCA)：如果加密方案在 IND-ID-CCA 安全模型中是 (t,qk,qd,ε)(t,q_k,q_d,ε)(t,qk​,qd​,ε)-安全的，但对手必须在设置阶段之前选择挑战身份 ID∗ID^∗ID∗，则基于身份的加密方案在选择性身份 (IND-sID-CCA) 安全模型中是 (t,qk,qd,ε)(t,q_k,q_d,ε)(t,qk​,qd​,ε)安全的。\n在安全模型的阶段1和阶段2中，对手可以交替进行私钥查询和解密查询。对手在安全模型中总共进行的查询次数为 qkq_kqk​ 和 qdq_dqd​，但是对手可以自行适应性地决定阶段1中的私钥查询次数（记为 q1q_1q1​）和解密查询次数（记为 q2q_2q2​），只要满足 q1≤qkq_1 ≤ q_kq1​≤qk​ 和 q2≤qdq_2 ≤ q_dq2​≤qd​。\nFurther Reading\n在这个部分，我们简要介绍了数字签名、公钥加密（PKE）和基于身份的加密（IBE）的安全模型的发展。\n数字签名。数字签名最早由Diffie和Hellman[34]引入，并由Goldwasser、Micali和Rivest[50]正式定义，其中首次定义了EUCMA安全模型。一次性签名是Lamport[71]发明的一种非常特殊的数字签名，是密码构造的重要组成部分。\n文献中提出了许多数字签名的安全模型，其中签名的安全模型被定义为用于模拟签名查询和伪造签名。强不可伪造性（SU）的概念在[13, 4]中进行了讨论。如果对手可以查询签名但不能决定要签署哪些消息，安全模型被定义为已知消息攻击[50]或随机消息攻击[64]。如果对手可以选择要查询的消息，但必须在看到公钥之前这样做，安全模型被定义为弱选择消息攻击[21]，通用选择消息攻击[50]，或已知消息攻击[64]。关于这些模型、它们之间的关系以及如何将一个较弱的模型转化为一个较强的模型，读者可以参考Jonathan Katz撰写的书籍[64]。注意，EU-CMA模型并不是最强的安全模型。一些安全模型（例如[12, 36, 59, 62]）被定义为捕获数字签名的抗泄露安全性，而一些安全模型（例如[82, 7, 8]）则被定义为考虑多用户环境下的安全性。\n公钥加密。公钥加密的安全模型被定义为对解密查询和安全目标的建模。\n对于解密查询，我们有选择明文攻击（CPA）[49]、选择密文攻击（CCA）[11, 88]和非自适应选择密文攻击（CCA1）[84]的定义。在CCA1安全模型中，对手只允许在接收到挑战密文之前进行解密查询。对于安全目标，我们有以下四个定义。\n• 不可区分性 (IND) 的定义[49]: 对手无法区分挑战密文中的加密消息。\n• 语意安全性 (SS) 的定义[49]: 对手无法从密文中计算出加密消息。\n• 不可篡改性 (NM) 的定义[37, 38]: 给定一个挑战密文，对手无法输出另一个密文，使得相应的加密消息是“有意义相关的”。\n• 明文感知性 (PA) 的定义[15]: 对手在不知道加密的基础消息的情况下无法创建密文。\n语意安全性（SS）的概念被证明与不可区分性（IND）等价[100]，而非篡改性（NM）则蕴含了任何类型攻击下的不可区分性[11]。 我们建议读者参考文献[11]，了解上述安全模型之间的关系。还存在一些更强的安全模型（例如[59, 36, 27, 35]），用于捕捉PKE的抗泄漏安全性。一些安全模型（例如[10, 60, 45, 46]）已经被定义为考虑在多用户环境下的安全性。\n基于身份的加密（IBE）。基于身份的加密系统最早由Shamir[93]引入。IND-ID-CPA和IND-ID-CCA的安全模型在几篇文献中被定义（例如[24, 25]）。IND-sID-CCA的安全模型首次在[27, 28, 20]中被定义。类似于PKE，IBE的安全模型也有一些变种，如IND-ID-CCA1、IND-sID-CCA1、NM-ID-CPA、NM-ID-CCA1、NM-ID-CCA、NM-sID-CPA、SS-ID-CPA、SS-ID-CCA1、SS-ID-CCA和SS-sIDCPA。文献[6]表明，非篡改性仍然蕴含了任何类型攻击下的不可区分性，而语意安全性对于IBE仍然等价于不可区分性。[103, 56]中提出的更强的安全模型是为了捕捉IBE的抗泄漏安全性。\nFoundations of Group-Based Cryptography\n在本章中，我们介绍了一些数学基元，包括有限域、群和双线性配对，它们是基于群的密码学的基础。我们还描述了在方案构建中起重要作用的三种哈希函数。我们主要关注介绍基本操作的可行性和二进制表示的大小。\n","categories":["密码学基础"],"tags":["密码学基础"]},{"title":"KDF","url":"/posts/8824d597.html","content":"\nKDF 密钥派生函数\n在现实生活中，我们更倾向于使用密码来保护自己的数据，而不是二进制的密钥。因为相比于二进制复杂的密钥，字符形式（小写字母，大写字母，数字，特殊符号等的组合）才符合人类正常的思维。\n可对计算机来说这相反，现代密码学的很多算法都要求输入是一个大的数字，二进制的密钥就是这样一个大的数字。 因此显然我们需要一个将字符密码（Password）转换成密钥（Key）的函数，这就是密钥派生函数 Key Derivation Function。\n直接使用SHA-一类的哈希函数加密password是不可取的，因为password通常都包含着个人的情感元素，这是容易记忆但容易受到猜测的，通常密码不会很长，在10位左右。另外，有的人为了方便，还会选择一些常见的弱密码，比如123456，admin，个人生日等。这就导致如果直接使用SHA-类的算法，许多密码将很容易被暴力破解，字典攻击，彩虹表攻击等手段猜测出来。\nKDF 目前主要从如下三个维度提升 hash 碰撞难度：\n\n时间复杂度：对应 CPU/GPU 计算资源\n空间复杂度：对应 Memory 内存资源\n并行维度：使用无法分解的算法，锁定只允许单线程运算\n\n主要手段是加盐，以及多次迭代。\n\n因为相比其他加密哈希算法，KDF 具有一个独特属性——计算速度很慢，而且从设计上就使其计算速度难以提升，所以 KDF 也被称作「慢哈希算法」。\n目前比较著名的 KDF 算法主要有如下几个：\n\nPBKDF2：这是一个非常简单的加密 KDF 算法，目前已经不推荐使用。\nBcrypt：安全性在下降，用得越来越少了。不建议使用。\nScrypt：可以灵活地设定使用的内存大小，在 argon2 不可用时，可使用它。\nArgon2：目前最强的密码 Hash 算法，在 2015 年赢得了密码 Hash 竞赛。\n\nScrypt\nScrypt 是一个强大的密钥派生函数，其通过内存密集的计算方式来抵抗 GPU、ASIC、FPGA 这类密码破解硬件的攻击。\nScrypt 接收多个输入参数，进行计算后输出密钥：\nkey = Scrypt(password, salt, N, r, p, derived-key-len)\n其中的参数被称为&quot; Scrypt 配置参数&quot;，说明如下：\n\nN - 迭代次数，将影响 CPU 和内存用量，例：16384 、2048 ；\nr - 块大小，将影响 CPU 和内存用量，例：8 ；\np - 并行因数 （并行运行的线程数，将影响 CPU 和内存用量），通常为 1 ；\npassword - 输入的密码（推荐至少为 8 - 10 个字符）；\nsalt - 安全产生的随机字节序列（最小为 64 位，推荐 128 位）；\nderived-key-len - 输出的密钥要有多少字节长，例如 32 （256 位）\n\nScrypt 计算过程中的每一步都会 按照强相关的顺序 访问内存，这就让内存读写性能成为了算法速度的瓶颈。\n具体怎么选择参数，要取决于我们能够等待的时间和所需的安全等级（即抗破解的能力）：\n\n用于交互式登录的示例参数：N=16384, r=8, p=1（RAM = 16MB）。交互式的登录一般耗时都要小于 0.5s ，所以必须快速完成计算。同样的，对于服务端而言，如果同时有很多用户登录，那么 Scrypt 的缓慢会拖慢整个系统；\n用于文件加密的示例参数：N=1048576, r=8, p=1（RAM = 1GB）。当要加密硬盘时，通常不会频繁解密数据（一天可能只解密 2 ~ 3次），所以你可能会愿意多等 2 ~ 3 秒作为提升安全性的代价。\n\n在 MyEtherWallet 加密钱包应用中，默认的参数是 N=8192, r=8, p=1 。对于此类应用而言，该强度不够高，但可以通过要求用户输入又长又复杂的密码来对抗密码破解攻击。\nimport osfrom cryptography.hazmat.primitives.kdf.scrypt import Scryptsalt = os.urandom(16)# derivekdf = Scrypt(    salt=salt,    length=32,    n=2**14,    r=8,    p=1,)key = kdf.derive(b&quot;password123&quot;)# verifykdf = Scrypt(    salt=salt,    length=32,    n=2**14,    r=8,    p=1,)kdf.verify(b&quot;password123&quot;, key)\n在配置合适的前提下，Scrypt 被认为是高度安全的 KDF 函数，所以可以用在任何需要 KDF 的地方——加密钱包、文件、App 密码等场景都可以\nBcrypt\nBcrypt 也是一个 KDF ，问世时间早于 Scrypt ，对于 ASIC 、GPU 攻击的抗性相对弱一些。其虽然也可以配置迭代数，但由于对内存的压力较小，因此比较容易构建相应的硬件加速密码破解器。\n在很多的应用、框架和工具中（比如 WordPress 站点的数据库），Bcrypt 加密后的密码都是和算法设置以及盐保存在一起的，体现为一个单一的字符串（字符串有着特定的格式）。这个字符串包含数个部分，以 $ 符号分割\n例如：\n$2a$07$wHirdrK4OLB0vk9r3fiseeYjQaCZ0bIeKY9qLsNep/I2nZAXbOb7m$2a$12$UqBxs0PN/u106Fio1.FnDOhSRJztLz364AwpGemp1jt8OnJYNsr.e$2a$12$8Ov4lfmZZbv8O5YKrXXCu.mdH9Dq9r72C5GnhVZbGNsIzTr8dSUfm\n","categories":["密码学基础"],"tags":["密码学基础"]},{"title":"LLM","url":"/posts/d2609092.html","content":"\nLLM\n大语言模型（large language model，LLM）是一种语言模型，由具有许多参数的人工神经网络组成，使用自监督学习或半监督学习对未标记文本进行训练。\n\n大型语言模型被训练来解决通用（常见）的语言问题，如文本分类、问答、文档总结和文本生成等。\n（1）文本分类：大型语言模型可以通过对输入文本进行分析和学习，将其归类到一个或多个预定义的类别中。例如，可以使用大型语言模型来分类电子邮件是否为垃圾邮件，或将推文归类为积极、消极或中立。\n（2）问答：大型语言模型可以回答用户提出的自然语言问题。例如，可以使用大型语言模型来回答搜索引擎中的用户查询，或者回答智能助手中的用户问题。\n（3）文档总结：大型语言模型可以自动提取文本中的主要信息，以生成文档摘要或摘录。例如，可以使用大型语言模型来生成新闻文章的概要，或从长篇小说中提取关键情节和事件。\n（4）文本生成：大型语言模型可以使用先前学习的模式和结构来生成新的文本。例如，可以使用大型语言模型来生成诗歌、短故事、或者以特定主题的文章。\n大语言模型特征\nLarge（大）：在&quot;大语言模型&quot;的上下文中，&quot;大&quot;主要有两层含义。一方面，它指的是模型的参数数量。在这些模型中，参数的数量通常会非常大，达到数十亿甚至数百亿。另一方面，&quot;大&quot;也指的是训练数据的规模。大语言模型通常在大规模的文本数据上进行训练。\nGeneral-purpose（通用）：这个词描述的是模型的应用范围。通用语言模型在训练时使用了来自各种领域的数据，因此它们能够处理各种类型的任务，不仅限于某一个特定的任务或领域。这使得这些模型在处理新的、未见过的任务时具有很强的泛化能力。\nPre-trained and fine-tuned（预训练和微调）：这是描述模型训练过程的关键词。在预训练阶段，模型在大规模的通用文本数据上进行训练，学习语言的基本结构和各种常识。然后，在微调阶段，模型在更小、更特定的数据集上进行进一步的训练。\n大语言模型的好处\n单一模型可用于不同任务：由于大语言模型是通用的，并且具有强大的泛化能力，所以它们可以处理各种类型的任务，比如文本分类、命名实体识别、情感分析、问答系统、文本生成等。这意味着我们可以使用同一个预训练的模型来处理不同的任务，只需要进行相应的微调就可以。这大大减少了开发和维护不同模型的复杂性和成本。\n微调过程只需要最小的数据：尽管大语言模型在预训练阶段需要大量的通用文本数据，但在微调阶段，它们通常只需要相对较小的领域特定数据。这是因为模型在预训练阶段已经学习了大量的语言知识和常识，微调阶段主要是让模型适应特定的任务或领域。这使得大语言模型能够在数据稀缺的领域中也能表现出色。\n随着更多的数据和参数，性能持续提升：大语言模型的性能通常随着训练数据的增加和模型参数的增加而提升。这意味着，通过训练更大的模型，并使用更多的数据，我们可以获得更好的性能。这是因为更大的模型有更多的参数，能够学习和表示更复杂的模式；同时，更多的数据能够提供更丰富的信息，帮助模型更好地理解语言。\n","categories":["AI安全"],"tags":["大语言模型"]},{"title":"crypto","url":"/posts/68282885.html","content":"\n密码学\n什么是密码学\n百度百科：密码学是研究编制密码和破译密码的技术科学。 研究密码变化的客观规律，应用于编制密码以保守通信秘密的，称为编码学；应用于破译密码以获取通信情报的，称为破译学，总称密码学\n本博客密码学参考教程：《现代密码学：理论与实践》\n\n本密码学系列仅用来回顾我的密码学心得历程，如有错误，还请联系我jhuaiyu3@gmail.com\n","categories":["密码学基础"],"tags":["密码学基础"]},{"title":"R1CS","url":"/posts/4cdf8b1a.html","content":"\n本文介绍零知识证明中的一对概念：R1CS和QAP\n\n概述\nzk-SNARKS是目前最常用的零知识证明系统，但是由于其复杂性，不能直接应用于任何计算问题，因此需要对计算问题进行一步步的转化，其中就包含了R1CS和QAP。\nR1CS 全程 Rank-1 Con­straint Sys­tem，一阶约束系统，其本质是一个可计算的三元方程组。\n而 QAP 全称 Qua­dratic Arith­metic Peoblem，二次算术问题，QAP 转换不仅可以将函数的代码转换为 QAP，还可以在转换的同时构建一个对应于代码输入的解（又称为 QAP 的 Wit­ness），之后再基于这个 wit­ness 构建一个实际的零知识证明系统。\n本文的参考是V神\nQAP\n在V神的文章中，给出了一个例子：P希望向V证明其知道方程x3+x+5=35x^3+x+5=35x3+x+5=35的解（P知道这个方程的解，因此witness为x=3x=3x=3），接下来是如何转化为QAP问题\n首先，我们用程序语言描述这个问题：\ndef find(x):    y=x**3    return y+x+5\nFlattening\n第一步就是将这个语言中的代码转换为下列两个操作\n1.x=y（y可以是变量或数字）2.x=y op z（op代表一种基本运算操作）\n经过 Flat­ten­ing 后，上述的语言可以转换为下面这个结果\nsym_1 = x * xy = sym_1 * xsym_2 = y + x~out = sym_2 + 5\n这里可以将上述转换后的每一行都理解为一个数学电路中的逻辑门（一个仅包含加法门和乘法门的电路），与原始代码相比，这里引入了两个中间变量 sym_1 和 sym_2，输出标记为 ~out，不难验证其与原始代码的等价性\n~out = sym_2 + 5 = y + x + 5 = sym_1 * x + x + 5 = x * x * x + x + 5\nR1CS\n第二步需要将 Flat­ten­ing 的结果转化为一阶约束系统 R1CS，一个 R1CS 是一个由三个向量构成的向量组(a⃗,b⃗,c⃗)(\\vec a,\\vec b,\\vec c)(a,b,c)，假设 R1CS 的解也是一个向量，记为s⃗\\vec ss，则s⃗\\vec ss满足\n(s⃗⋅a⃗)∗(s⃗⋅b⃗)−(s⃗⋅c⃗)=0(\\vec s \\cdot \\vec a)*(\\vec s \\cdot \\vec b)-(\\vec s \\cdot \\vec c)=0\n(s⋅a)∗(s⋅b)−(s⋅c)=0\n其中⋅⋅表示向量内积，∗∗表示算数乘法\n举例，假设向量组和解向量分别如下：\na⃗=[0,1,0,0,0,0]b⃗=[0,1,0,0,0,0]c⃗=[0,0,0,1,0,0]s⃗=[1,3,35,9,27,30]\\vec a =[0,1,0,0,0,0]\\\\\n\\vec b=[0,1,0,0,0,0]\\\\\n\\vec c=[0,0,0,1,0,0]\\\\\n\\vec s=[1,3,35,9,27,30]\na=[0,1,0,0,0,0]b=[0,1,0,0,0,0]c=[0,0,0,1,0,0]s=[1,3,35,9,27,30]\n此时这个s⃗\\vec ss满足R1CS\n\n这个例子中只有一个约束条件（也即只有一个 R1CS），接下来需要将之前的每个逻辑门都转化为一个约束（也即将 Flat­ten­ing 之后的每一个语句都转化为一个 R1CS 向量组），转化的方法很简单，只需要声明何种运算与声明的参数是常量还是变量。\n因此，将上述 Flat­ten­ing 的结果转化之前，需要先将所有用到的变量用解向量s⃗\\vec ss表示，根据前面的分析，需要有五个变量(x,∼out,sym_1,y,sym_2)(x,\\sim out,sym\\_1,y,sym\\_2)(x,∼out,sym_1,y,sym_2)，此外还需要一个冗余变量表示数字 1，记为∼one\\sim one∼one，因此得到解向量s⃗\\vec ss如下\ns⃗=[∼one,x,∼out,sym_1,y,sym_2]\\vec s=[\\sim one,x,\\sim out,sym\\_1,y,sym\\_2]\ns=[∼one,x,∼out,sym_1,y,sym_2]\n接下来看第一个逻辑门sym_1=x∗xsym\\_1=x∗xsym_1=x∗x，其等价于x∗x−sym_1=0x∗x−sym\\_1=0x∗x−sym_1=0，因此不难得出R1CS 向量组如下\na⃗1=[0,1,0,0,0,0]b⃗1=[0,1,0,0,0,0]c⃗1=[0,0,0,1,0,0]\\vec a_1=[0,1,0,0,0,0]\\\\\n\\vec b_1=[0,1,0,0,0,0]\\\\\n\\vec c_1=[0,0,0,1,0,0]\\\\\na1​=[0,1,0,0,0,0]b1​=[0,1,0,0,0,0]c1​=[0,0,0,1,0,0]\n然后第二个逻辑门y=sym_1∗xy=sym\\_1∗xy=sym_1∗x同理，其等价于sym_1∗x−y=0sym\\_1∗x−y=0sym_1∗x−y=0，得到第二个 R1CS 向量组\na⃗1=[0,0,0,1,0,0]b⃗1=[0,1,0,0,0,0]c⃗1=[0,0,0,0,1,0]\\vec a_1=[0,0,0,1,0,0]\\\\\n\\vec b_1=[0,1,0,0,0,0]\\\\\n\\vec c_1=[0,0,0,0,1,0]\\\\\na1​=[0,0,0,1,0,0]b1​=[0,1,0,0,0,0]c1​=[0,0,0,0,1,0]\n第三个逻辑门sym2=y+xsym_2=y+xsym2​=y+x同理，其等价于(y+x)∗1−sym2=0(y+x)∗1−sym_2=0(y+x)∗1−sym2​=0，得到第三个 R1CS 向量组\na⃗1=[0,1,0,0,1,0]b⃗1=[1,0,0,0,0,0]c⃗1=[0,0,0,0,0,1]\\vec a_1=[0,1,0,0,1,0]\\\\\n\\vec b_1=[1,0,0,0,0,0]\\\\\n\\vec c_1=[0,0,0,0,0,1]\\\\\na1​=[0,1,0,0,1,0]b1​=[1,0,0,0,0,0]c1​=[0,0,0,0,0,1]\n最后是第四个逻辑门∼out=sym_2+5\\sim out =sym\\_2+5∼out=sym_2+5同理，其等价于(sym_2+5)∗1−(∼out)=0(sym\\_2+5)*1-(\\sim out)=0(sym_2+5)∗1−(∼out)=0得到第四个 R1CS 向量组\na⃗1=[5,0,0,0,0,1]b⃗1=[1,0,0,0,0,0]c⃗1=[0,0,1,0,0,0]\\vec a_1=[5,0,0,0,0,1]\\\\\n\\vec b_1=[1,0,0,0,0,0]\\\\\n\\vec c_1=[0,0,1,0,0,0]\\\\\na1​=[5,0,0,0,0,1]b1​=[1,0,0,0,0,0]c1​=[0,0,1,0,0,0]\n此时之前的 wit­ness 为x=3x=3x=3，经过 R1CS 转换后 wit­ness 就转换为了使得这四个 R1CS 同时成立的解向量s⃗\\vec ss\ns⃗=[1,3,35,9,27,30]\\vec s=[1,3,35,9,27,30]\ns=[1,3,35,9,27,30]\n将上述结果整理一下，把每个 R1CS 中的三个向量分别整理成一个向量组\nA=(010000000100010010500001)B=(010000010000100010100000)C=(000100000010000001001000)A=\\left(\n\\begin{matrix}\n0 &amp; 1 &amp; 0 &amp;0 &amp;0 &amp;0\\\\\n0 &amp; 0 &amp; 0 &amp;1 &amp;0 &amp;0\\\\\n0 &amp; 1 &amp; 0 &amp;0 &amp;1 &amp;0\\\\\n5 &amp; 0 &amp; 0 &amp;0 &amp;0 &amp;1\n\\end{matrix}\n\\right)\\\\\n\nB=\\left(\n\\begin{matrix}\n0 &amp; 1 &amp; 0 &amp;0 &amp;0 &amp;0\\\\\n0 &amp; 1 &amp; 0 &amp;0 &amp;0 &amp;0\\\\\n1 &amp; 0 &amp; 0 &amp;0 &amp;1 &amp;0\\\\\n1 &amp; 0 &amp; 0 &amp;0 &amp;0 &amp;0\n\\end{matrix}\n\\right)\\\\\n\nC=\\left(\n\\begin{matrix}\n0 &amp; 0 &amp; 0 &amp;1 &amp;0 &amp;0\\\\\n0 &amp; 0 &amp; 0 &amp;0 &amp;1 &amp;0\\\\\n0 &amp; 0 &amp; 0 &amp;0 &amp;0 &amp;1\\\\\n0 &amp; 0 &amp; 1 &amp;0 &amp;0 &amp;0\n\\end{matrix}\n\\right)\\\\\nA=⎝⎜⎜⎜⎛​0005​1010​0000​0100​0010​0001​⎠⎟⎟⎟⎞​B=⎝⎜⎜⎜⎛​0011​1100​0000​0000​0010​0000​⎠⎟⎟⎟⎞​C=⎝⎜⎜⎜⎛​0000​0000​0001​1000​0100​0010​⎠⎟⎟⎟⎞​\nR1CS to QAP\n下一步是将这个 R1CS 转换成 QAP 的形式，QAP 实现了与 R1CS 完全相同的逻辑，只不过使用的是多项式而不是向量内积，具体做法如下\n在上述三个向量组A,B,C中，利用在每个xxx坐标处求多项式代表一个约束条件（每个向量组的第一个行向量代表x=1x=1x=1），将每个向量组的四个长度为 6 的行向量转换成六个长度为 4 的向量（六个阶为 3 的多项式）\n也就是说，如果我们求出x=1x=1x=1处的多项式，我们就得到了第一组向量，如果我们求出x=2x=2x=2处的多项式，我们就得到第二组向量，以此类推\n在每个xxx点处来评估不同的约束，每个向量组都有四个约束，因此我们分别用多项式在 x=1,2,3,4x=1,2,3,4x=1,2,3,4处来评估这四个向量组，然后使用拉格朗日差值公式来将 R1CS 转化为 QAP 形式\n以向量组 A 举例，首先需要求出四个约束所对应的每个a⃗\\vec aa向量的第一个值的多项式，也就是对向量组 A 的第一列采用拉格朗日插值法，求过点(1,0),(2,0),(3,0),(4,5)四个点的多项式（可以用在线工具 Cubic Polynomial Generator 求解，或者自己写脚本也行），求得三阶多项式如下\ny1=−5+9.166x−5x2+0.833x3y_1=-5+9.166x-5x^2+0.833x^3\ny1​=−5+9.166x−5x2+0.833x3\n将多项式的系数按xxx的阶数升序排列，得到系数向量(−5.0,9.166,−5.0,0.833)\n不难验证，将x=1,2,3,4x=1,2,3,4x=1,2,3,4分别带入上述多项式，可以恢复向量组 A 的第一个列向量\n同理可以求出剩下的17个系数向量\nA=(−59.166−50.8338−11.3335−0.6660000−69.5−40.54−73.5−0.5−11.833−10.166)B=(3−5.1662.5−0.333−25.166−2.50.3330000000000000000)C=(00000000−11.833−10.1664−4.3331.5−0.166−69.5−40.54−73.5−0.5)A=\\left(\n\\begin{matrix}\n-5 &amp; 9.166 &amp; -5 &amp;0.833\\\\\n8 &amp; -11.333 &amp; 5 &amp;-0.666\\\\\n0 &amp; 0 &amp; 0 &amp;0\\\\\n-6 &amp; 9.5 &amp; -4 &amp;0.5\\\\\n4 &amp; -7 &amp; 3.5 &amp;-0.5\\\\\n-1 &amp; 1.833 &amp; -1 &amp;0.166\\\\\n\\end{matrix}\n\\right)\\\\\n\nB=\\left(\n\\begin{matrix}\n3 &amp; -5.166 &amp; 2.5 &amp;-0.333\\\\\n-2 &amp; 5.166 &amp; -2.5 &amp;0.333\\\\\n0 &amp; 0 &amp; 0 &amp;0\\\\\n0 &amp; 0 &amp; 0 &amp;0\\\\\n0 &amp; 0 &amp; 0 &amp;0\\\\\n0 &amp; 0 &amp; 0 &amp;0\\\\\n\\end{matrix}\n\\right)\\\\\n\nC=\\left(\n\\begin{matrix}\n0 &amp; 0 &amp; 0 &amp;0\\\\\n0 &amp; 0 &amp; 0 &amp;0\\\\\n-1 &amp; 1.833 &amp; -1 &amp;0.166\\\\\n4 &amp;-4.333 &amp;1.5 &amp;-0.166\\\\\n-6 &amp; 9.5 &amp; -4 &amp;0.5\\\\\n4 &amp; -7 &amp; 3.5 &amp;-0.5\n\\end{matrix}\n\\right)\\\\\nA=⎝⎜⎜⎜⎜⎜⎜⎜⎛​−580−64−1​9.166−11.33309.5−71.833​−550−43.5−1​0.833−0.66600.5−0.50.166​⎠⎟⎟⎟⎟⎟⎟⎟⎞​B=⎝⎜⎜⎜⎜⎜⎜⎜⎛​3−20000​−5.1665.1660000​2.5−2.50000​−0.3330.3330000​⎠⎟⎟⎟⎟⎟⎟⎟⎞​C=⎝⎜⎜⎜⎜⎜⎜⎜⎛​00−14−64​001.833−4.3339.5−7​00−11.5−43.5​000.166−0.1660.5−0.5​⎠⎟⎟⎟⎟⎟⎟⎟⎞​\n将x=1x=1x=1带入这些十八组系数构成的多项式，可以恢复出三个 R1CS 中第一个约束的三个向量(0,1,0,0,0,0),(0,1,0,0,0,0) 和(0,0,0,1,0,0)\n将x=2,3,4x=2,3,4x=2,3,4带入这些多项式，则可以完全恢复三个 R1CS 向量组\n","categories":["零知识证明"],"tags":["零知识证明"]},{"title":"Sigma零知识证明协议","url":"/posts/8c0d2487.html","content":"\nSigma零知识证明，知道秘密ω\\omegaω，且与公开输入QQQ满足离散对数关系Q=ωGQ=\\omega GQ=ωG\n\nSigma零知识证明协议\n设关系R⊆X∗YR\\subseteq X *YR⊆X∗Y, 那么&lt;P, V&gt; 构建在R上的一个Sigma 协议为：\nP是一个叫证明的交互式协议，其输入为一个witness-statement对(x,y)∈R(x,y)\\in R(x,y)∈R.\nV是一个叫验证的交互式协议，其输入为一个statement，y∈Ry\\in Ry∈R\nP和V交互过程为：\n\n\n首先，P计算一个承诺(commitment) t ，将其发送给V；\n\n\n在收到来自P的消息后，V在有限的挑战空间C中随机选取一个挑战元素(challenge) c，并将其发送给P ；\n\n\n在接收到来自V的挑战后， P计算出一个反馈(response) z ,将其发送给V\n\n\n在收到了来自P的反馈后, V输出accept或者reject。\n例子\n\n\n1）P计算h=gxmod ph=g^xmod\\ ph=gxmod p作为秘密\n2）P选择随机数r∈zqr\\in z_qr∈zq​，计算a=grmodpa=g^rmodpa=grmodp, P将a值发送给V\n3）V选择随机数challenge e，V将e值发送给P；\n4） P计算z=r+ex modpz=r+ex\\ mod pz=r+ex modp, 将z值发送给V，\n5） V判断gz=?=ahemodpg^z=?=ah^emod pgz=?=ahemodp是否成立，同时检验e的哈希结果是否正确，都通过后，则V接受认为P确实知道正确的x.\n正确性(completeness)\n在上面的协议中，正确性意味着如果每个人都遵守协议，那么协议正常执行。在Sigma协议的中，这意味着P和V这么做，V最后应该接受状态。\n公平性(special soundness)\n公平性意味着P不能证明一个错误的陈述statement. Sigma协议实现公平的。准确地说，特殊公平性！特殊公平性是说，如果P能让V在挑战中找到两个挑战，那么这两个挑战分别是(e,z)和(e′,z′)。通过代数计算【幂除法】可以得到d=(e−e′),x=d(s−s′)d=(e-e^{\\prime}),x=d(s-s^{\\prime})d=(e−e′),x=d(s−s′)。这样计算出x那么只能满足其中一个等式。\n零知识性 (special honest verifier zk)\nV既不能从协议中知道x的值，而且还不能向第三者，证明V知道这个秘密（即V无法冒充P）。也就是V从协议中什么也没学到（除了P知道x之外）。\nsigma协议又称为诚实验证者的（特殊）零知识证明。即假设验证者是诚实的\n交互式方式有其应用局限，比如得双方或多方同时在线等。Fiat-Shamir变换，又叫Fiat-Shamir Heurisitc（启发式），或者Fiat-Shamir Paradigm（范式），是Fiat和Shamir在1986年提出的一个变换，其特点是可以将交互式零知识证明转换为非交互式零知识证明。这样就通过减少通信步骤而提高了通信的效率！\n该算法允许将交互步骤中随机挑战替换为非交互随机数预言机（Random oracle）。\n1）P计算h=gxmod ph=g^xmod\\ ph=gxmod p作为秘密\n2）P选择随机数r∈zqr\\in z_qr∈zq​，计算a=grmodpa=g^rmodpa=grmodp, P将a值发送给V\n3）P计算e=Hash(h,a)e=Hash(h,a)e=Hash(h,a)\n4） P计算z=r+ex modpz=r+ex\\ mod pz=r+ex modp, 将z值发送给V，\n5） V判断gz=?=ahemodpg^z=?=ah^emod pgz=?=ahemodp是否成立，同时检验e的哈希结果是否正确，都通过后，则V接受认为P确实知道正确的x.\nSigma协议应用到ElGamal同态加密\n同态密文运算\n密钥生成：A,B,C,D的私钥和公钥分别是：\nA:(α1,g1),g1=gα1B:(α2,g2),g2=gα2C:(α3,g3),g3=gα1D:(α4,g4),g4=gα2A:(\\alpha_1,g_1),g_1=g^{\\alpha_1}\\\\\nB:(\\alpha_2,g_2),g_2=g^{\\alpha_2}\\\\\nC:(\\alpha_3,g_3),g_3=g^{\\alpha_1}\\\\\nD:(\\alpha_4,g_4),g_4=g^{\\alpha_2}\\\\\nA:(α1​,g1​),g1​=gα1​B:(α2​,g2​),g2​=gα2​C:(α3​,g3​),g3​=gα1​D:(α4​,g4​),g4​=gα2​\n余额初始状态：\n\n\nA余额初始状态密文为[C0,D0][C_0,D_0][C0​,D0​]，其中C0=gr0,D0=gm0g1r0C_0=g^{r_0},D_0=g^{m_0}g_1^{r_0}C0​=gr0​,D0​=gm0​g1r0​​\n\n\nB余额初始状态密文为[C0′,D0′][C_0^{\\prime},D_0^{\\prime}][C0′​,D0′​]，其中C0′=gr0′,D0′=gm0′g1r0′C_0^{\\prime}=g^{r_0^{\\prime}},D_0^{\\prime}=g^{m_0^{\\prime}}g_1^{r_0^{\\prime}}C0′​=gr0′​,D0′​=gm0′​g1r0′​​\n\n\nC,D起始状态金额为0\n\n\nA支付给C金额数量为m1m_1m1​，使用ElGamal同态加密生成密文[C1,D1],[C1′,D1′][C_1,D_1],[C_1^{\\prime},D_1^{\\prime}][C1​,D1​],[C1′​,D1′​]并生成零知识证明zkProofzkProofzkProof和范围证明BulletProofBulletProofBulletProof\n\nA选择随机数r1r_1r1​，基于C的公钥g3g_3g3​，生成[C1,D1][C_1,D_1][C1​,D1​]\nA选择随机数r1r_1r1​，基于自己的公钥g1g_1g1​，生成[C1′,D1′][C_1^{\\prime},D_1^{\\prime}][C1′​,D1′​]\n\nC1=gr1, D1=gm1g3r1C1′=gr1′,D1′=gm1′g3r1′ZK{r1,r1′,m1,m1′,m1=m1′∣C1,D1,C1′,D1′}BulletProof{0≤m0−m1≤232,0≤m1≤232}C_1=g^{r_1},\\ D_1=g^{m_1}g_3^{r_1}\\\\\nC_1^{\\prime}=g^{r_1^{\\prime}},D_1^{\\prime}=g^{m_1^{\\prime}}g_3^{r_1^{\\prime}}\\\\\nZK\\{r_1,r_1^{\\prime},m_1,m_1^{\\prime},m_1=m_1^{\\prime}|C_1,D_1,C_1^{\\prime},D_1^{\\prime}\\}\\\\\nBulletProof\\{0\\le m_0-m_1\\le2^{32},0\\le m_1\\le2^{32} \\}\nC1​=gr1​, D1​=gm1​g3r1​​C1′​=gr1′​,D1′​=gm1′​g3r1′​​ZK{r1​,r1′​,m1​,m1′​,m1​=m1′​∣C1​,D1​,C1′​,D1′​}BulletProof{0≤m0​−m1​≤232,0≤m1​≤232}\nA对交易单签名;矿工验证签名、零知识证明和范围证明。然后:\n\n更新C金额记作[C1,D1][C_1,D_1][C1​,D1​]，则C能够解密获得m1m_1m1​并进行支付，解密过程：gm1=D1/(C1)α3g^{m_1}=D_1/(C_1)^{\\alpha_3}gm1​=D1​/(C1​)α3​\n更新A的金额状态记为[C0/C1′,D0/D1′][C_0/C_1^{\\prime},D_0/D_1^{\\prime}][C0​/C1′​,D0​/D1′​]，则A能过够解密获得m0−m1m_0-m_1m0​−m1​并进行支付。解密过程：gm0−m1′=(D0/D1′)/(C0/C1′)α1g^{m_0-m_1^{\\prime}}=(D_0/D_1^{\\prime})/(C_0/C_1^{\\prime})^{\\alpha_1}gm0​−m1′​=(D0​/D1′​)/(C0​/C1′​)α1​\n\nC余额增加m1m_1m1​，A余额减少m1′m_1^{\\prime}m1′​\nB支付给C金额为m2m_2m2​，使用ElGamal同态加密生成密文[C2,D2],[C2′,D2′][C_2,D_2],[C_2^{\\prime},D_2^{\\prime}][C2​,D2​],[C2′​,D2′​]，并生成零知识证明zkProofzkProofzkProof和范围证明BulletProofBulletProofBulletProof\nC2=gr2, D2=gm2g3r2C2′=gr2′,D2′=gm2′g3r2′ZK{r2,r2′,m2,m2′,m2=m2′∣C2,D2,C2′,D2′}BulletProof{0≤m0−m2≤232,0≤m2≤232}C_2=g^{r_2},\\ D_2=g^{m_2}g_3^{r_2}\\\\\nC_2^{\\prime}=g^{r_2^{\\prime}},D_2^{\\prime}=g^{m_2^{\\prime}}g_3^{r_2^{\\prime}}\\\\\nZK\\{r_2,r_2^{\\prime},m_2,m_2^{\\prime},m_2=m_2^{\\prime}|C_2,D_2,C_2^{\\prime},D_2^{\\prime}\\}\\\\\nBulletProof\\{0\\le m_0-m_2\\le2^{32},0\\le m_2\\le2^{32} \\}\nC2​=gr2​, D2​=gm2​g3r2​​C2′​=gr2′​,D2′​=gm2′​g3r2′​​ZK{r2​,r2′​,m2​,m2′​,m2​=m2′​∣C2​,D2​,C2′​,D2′​}BulletProof{0≤m0​−m2​≤232,0≤m2​≤232}\nB对交易单签名;矿工验证签名、零知识证明和范围证明。然后:\n\n更新C金额记作[C1C2,D1D2][C_1C_2,D_1D_2][C1​C2​,D1​D2​]，则C能够解密获得m1+m2m_1+m_2m1​+m2​并进行支付，解密过程：gm1+m2=D1D2/(C1C2)α3g^{m_1+m_2}=D_1D_2/(C_1C_2)^{\\alpha_3}gm1​+m2​=D1​D2​/(C1​C2​)α3​\n更新A的金额状态记为[C0/C2′,D0/D2′][C_0/C_2^{\\prime},D_0/D_2^{\\prime}][C0​/C2′​,D0​/D2′​]，则A能过够解密获得m0′−m2m_0^{}\\prime-m_2m0​′−m2​并进行支付。解密过程：gm0′−m2′=(D0′/D2′)/(C0/C2′)α2g^{m_0^{\\prime}-m_2^{\\prime}}=(D_0^{\\prime}/D_2^{\\prime})/(C_0/C_2^{\\prime})^{\\alpha_2}gm0′​−m2′​=(D0′​/D2′​)/(C0​/C2′​)α2​\n\nC支付给D金额数量为m3m_3m3​，使用ElGamal同态加密生成密文[C3,D3],[C3′,D3′][C_3,D_3],[C_3^{\\prime},D_3^{\\prime}][C3​,D3​],[C3′​,D3′​]，并生成零知识证明zkProofzkProofzkProof和范围证明BulletProofBulletProofBulletProof\nC3=gr3, D3=gm3g4r3C3′=gr3′,D3′=gm3′g3r3′ZK{r3,r3′,m3,m3′,m3=m3′∣C3,D3,C3′,D3′}BulletProof{0≤m1+m2−m3≤232,0≤m3≤232}C_3=g^{r_3},\\ D_3=g^{m_3}g_4^{r_3}\\\\\nC_3^{\\prime}=g^{r_3^{\\prime}},D_3^{\\prime}=g^{m_3^{\\prime}}g_3^{r_3^{\\prime}}\\\\\nZK\\{r_3,r_3^{\\prime},m_3,m_3^{\\prime},m_3=m_3^{\\prime}|C_3,D_3,C_3^{\\prime},D_3^{\\prime}\\}\\\\\nBulletProof\\{0\\le m_1+m_2-m_3\\le2^{32},0\\le m_3\\le2^{32} \\}\nC3​=gr3​, D3​=gm3​g4r3​​C3′​=gr3′​,D3′​=gm3′​g3r3′​​ZK{r3​,r3′​,m3​,m3′​,m3​=m3′​∣C3​,D3​,C3′​,D3′​}BulletProof{0≤m1​+m2​−m3​≤232,0≤m3​≤232}\nC对交易单签名;矿工验证签名、零知识证明和范围证明。然后:\n\n更新C金额记作[C1C2/C3′,D1D2/D3′][C_1C_2/C_3^{\\prime},D_1D_2/D_3{\\prime}][C1​C2​/C3′​,D1​D2​/D3​′]，则C能够解密获得m1+m2−m3m_1+m_2-m_3m1​+m2​−m3​并进行支付，解密过程：gm1+m2−m3=(D1D2/D3′)/(C1C2/C3)α3g^{m_1+m_2-m_3}=(D_1D_2/D_3^{\\prime})/(C_1C_2/C_3)^{\\alpha_3}gm1​+m2​−m3​=(D1​D2​/D3′​)/(C1​C2​/C3​)α3​\n更新A的金额状态记为[C3,D3][C_3,D_3][C3​,D3​]，则A能过够解密获得m3m_3m3​并进行支付。解密过程：gm3=(D3)/(C3)α4g^{m_3}=(D_3)/(C_3)^{\\alpha_4}gm3​=(D3​)/(C3​)α4​\n\nSigma 零知识证明确保：支付方的减少额 == 接收方的增加额。\n","categories":["零知识证明"],"tags":["零知识证明"]},{"title":"openSSL","url":"/posts/6ea65089.html","content":"\n\n什么是openSSL\nOpenSSL 是一个开源的安全套接字层密码库，提供了各种密码和加密算法的实现。OpenSSL 头文件是用于在 C/C++ 代码中访问 OpenSSL 库功能的接口定义。\n下面介绍一些常用的 OpenSSL 头文件：\n\n&lt;openssl/ssl.h&gt;：包含与 SSL/TLS 协议相关的函数和数据结构的声明，用于实现安全的网络通信。\n&lt;openssl/evp.h&gt;：包含对称加密算法和哈希算法的函数和数据结构的声明，用于实现数据的加密、解密和摘要计算。\n&lt;openssl/rsa.h&gt;：包含 RSA 加密算法的函数和数据结构的声明，用于实现 RSA 密钥的生成、加密和解密。\n&lt;openssl/dh.h&gt;：包含 Diffie-Hellman 密钥交换算法的函数和数据结构的声明，用于实现 DH 密钥的生成和共享密钥的计算。\n&lt;openssl/x509.h&gt;：包含 X.509 数字证书和公钥基础设施（PKI）相关的函数和数据结构的声明，用于实现证书的读取、验证和操作。\n&lt;openssl/bio.h&gt;：包含 I/O 抽象层的函数和数据结构的声明，用于实现对不同类型数据流的读写操作。\n&lt;openssl/rand.h&gt;：包含随机数生成器相关的函数和数据结构的声明，用于生成随机数，例如密钥和初始化向量（IV）。\n&lt;openssl/pem.h&gt;：包含 PEM 编码格式相关的函数和数据结构的声明，用于实现对 PEM 格式的数据进行读写和解析。\n\n这只是一部分常用的 OpenSSL 头文件，OpenSSL 库还提供了很多其他功能和算法的头文件。使用这些头文件，开发者可以在自己的代码中利用 OpenSSL 提供的加密、解密、签名、验证等功能，以增强应用程序的安全性。\nBIGNUM\nBIGNUM是OpenSSL库中定义的数据类型，用于表示大整数（Big Number）。它是一个结构体，在OpenSSL库中用于处理大数运算和数字加密算法。\nBIGNUM可以存储任意长度的整数，并支持在整数之间进行各种运算，如加法、减法、乘法、除法、取模等。在密码学和安全领域，BIGNUM经常用于处理密钥、加密算法、数字签名等操作中涉及的大整数。\n通过使用BIGNUM数据类型，开发者可以方便地进行大数运算，并且不受固定整数长度的限制。这对于需要处理很大的数字或进行复杂的数学操作的应用程序非常有用。\n#include &lt;openssl/bn.h&gt;void bignum_example() &#123;    BIGNUM *a = NULL;    BIGNUM *b = NULL;    BIGNUM *sum = NULL;    // 初始化大数对象    a = BN_new();    b = BN_new();    sum = BN_new();    // 设置要进行运算的大数值    BN_dec2bn(&amp;a, &quot;123456789&quot;);    BN_dec2bn(&amp;b, &quot;987654321&quot;);    // 执行加法运算    BN_add(sum, a, b);    // 将结果转换为字符串    char *result = BN_bn2dec(sum);    if (result != NULL) &#123;        printf(&quot;Sum: %s\\n&quot;, result);        OPENSSL_free(result);    &#125;    // 释放资源    BN_free(a);    BN_free(b);    BN_free(sum);&#125;int main()&#123;    bignum_example();    return 0;&#125;\n编译并运行\ngcc BIGNUM.c -o BIGNUM -lcrypto./BIGNUM\n在这个例子中，我们首先创建了三个BIGNUM类型的指针对象：a、b、sum。然后，使用BN_new()函数初始化这些对象。\n接下来，我们使用BN_dec2bn()函数将字符串形式的数字转换为BIGNUM对象，并将其赋值给a和b。在这个例子中，我们将123456789赋给a，将987654321赋给b。\n然后，我们使用BN_add()函数执行大数相加操作，将结果存储在sum中。\n最后，我们使用BN_bn2dec()函数将大数结果转换为字符串，并打印出来。注意，在使用BN_bn2dec()函数后，需要使用OPENSSL_free()函数释放返回的字符串内存。\n最后，我们释放所有的BIGNUM对象，以及其他动态分配的内存。\n","categories":["零知识证明"],"tags":["零知识证明"]},{"title":"Hello World","url":"/posts/4a17b156.html","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start\nCreate a new post\n$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n$ hexo server\nMore info: Server\nGenerate static files\n$ hexo generate\nMore info: Generating\nDeploy to remote sites\n$ hexo deploy\nMore info: Deployment\n"},{"title":"zkBridge","url":"/posts/e15e124.html","content":"\nzkBridge: Trustless Cross-chain Bridges Made Practical\n当今时间，多种多样的区块链出现在人们的视野。多链世界的核心挑战是如何实现安全的跨链桥接，使不同区块链上的应用可以通过这些桥接进行通信。\n区块链C1C_1C1​和C2C_2C2​之间桥梁的核心功能是向C2C_2C2​上的应用程序证明某个事件发生在C1C_1C1​上，反之亦然。\n问题所在，虽然在实践中已经建立了跨链桥，但现有的解决方案要么性能不佳，要么依赖于中心方。\n桥的运行取决于两个链的共识协议。如果C1C_1C1​运行的是工作证明（Proof-of-Work），具体来说，C2C_2C2​上的智能合约（用SC2SC_2SC2​表示）将跟踪C1C_1C1​的区块头，根据这些区块头，可以用 Merkle 证明来验证交易的包含（和其他事件）。但是，这种方法会产生巨大的计算和存储开销，因为SC2SC_2SC2​需要验证所有区块头，并保存一个不断增长的冗长列表。\n作为一种高效的替代方案，许多桥接协议\n(PolyNetwork、Wormhole、Ronin 等）都采用了基于信任中介（Trust In­ter­me­di­ary）的方法，所使用的技术包括侧链（PolyNetwork），跨链委员会（Ronin），预言机（LayerZero）\nWormhole：https://docs.wormhole.com/wormhole/explore-wormhole/security\nPoly Network：https://learnblockchain.cn/article/3300\n此类方式需要有比较强的信任假设，也即假设跨链桥的结点有至少 2/3 是可信的，委员会中有至少 2/3 是可信的。\n但是这种方式容易遭受到恶意的攻击。\n为了降低对中介的信任依赖，一个比较简单的方式是不让中介传输数据，而是让中介对数据进行签名，之后由接受数据的链对签名进行验证即可\n这个思路有点类似于轻量级客户端验证，只要客户端验证并持续追踪验证状态即可\n举个例子，Cos­mos IBC 是一个用于 Cos­mos 链的跨链协议，这个协议会验证来自其他链的数据的区块首部，从而完成跨链数据的验证，不过此类方式也存在缺点，需要跨链的接收方部署这个 IBC 协议来完成数据验证（比如以太坊没有部署这个东西，就无法支持跨链）\n或者向 NEAR Rain­bow bridge 那样的做法，将其以智能合约的形式部署于以太坊来支持跨链，但是这会导致链上验证的开销非常大\n为了在消除中介的同时提供足够强的安全性，这里可以引入 ZKP 技术，主要思想和很多去中心化的协议类似，将对可信机构的信任转移至对密码学假设的依赖。\nzkBridge 可以实现高效的跨链桥接，而无需信任中央委员会。其主要思想是利用 zk-SNARK，即简洁的非交互式知识证明（论证）\nzk-SNARK能让证明者有效地让SC2SC_2SC2​相信，在C1C_1C1​上发生了某种状态转换。为此，SC2SC_2SC2​将跟踪SC1SC_1SC1​最新提示的摘要DDD。要使SC2SC_2SC2​与C1C_1C1​中的新区块同步，任何人都可以生成并提交 zk-SNARK，向SC2SC_2SC2​证明C1C_1C1​的顶端已经从 DDD推进到D′D^\\primeD′。\n好处：\nzk-SNARK 的健全性确保了桥梁的安全性。除了底层区块链的安全性外，我们不需要额外的安全性要求。\n通过专门构建的 zk-SNARK，C2C_2C2​可以验证C1C_1C1​的状态转换，远比在SC2SC_2SC2​中编码C1C_1C1​的共识逻辑更有效。\n要使用 zk-SNARK 证明给定计算结果的正确性，首先需要将计算表达为算术电路。\n虽然 zk-SNARK 验证速度很快（与电路的大小成对数关系，甚至是常数），但证明生成时间至少是线性的，而且在实践中可能昂贵得令人望而却步。\n此外，现实世界中区块链使用的组件并不容易用算术电路来表示。例如，广泛使用的 EdDSA 数字签名方案在 CPU 上的验证效率很高，但要用算术电路表示却很昂贵，需要 200 多万个门。在跨链桥中，根据链的不同，每个状态转换可能需要验证数百个签名，这使得生成所需的 zk-SNARK 证明的成本过高。\n因此，为了使 zkBridge 实用化，我们必须缩短证明生成时间。\n我们发现跨链桥所使用的电路是数据并行的，因为它们包含一个较小的子电路的多个相同副本。具体来说，用于验证NNN数字签名的电路包含签名验证子电路的NNN个副本。因此，本文提出一种基于Virgo的分布式协议，deVirgo，如果证明生成分布在MMM台机器上，生成时间可减少MMM倍。\n虽然 deVirgo 大大缩短了证明生成时间，但在链上验证 deVirgo 证明（尤其是 zkBridge 中的十亿门电路）对于计算资源极其有限的智能合约来说可能是昂贵的。\n为了压缩证明大小和验证成本，本文使用 Groth 提出的经典 zk-SNARK 递归证明（可能很大）deVirgo 证明的正确性，以下简称 Groth16。Groth16 校验器能输出恒定大小的证明，EVM 区块链上的智能合约可以快速验证这些证明。我们强调，不能使用 Groth16 生成整个 zkBridge 证明，因为 zkBridge 所需的电路对于 Groth16 验证器来说太大了。\n相反，我们使用 Groth16 压缩 deVirgo 证明的方法却能提供两全其美的效果：快速的 deVirgo 并行证明器可生成大部分证明，而生成的证明则被压缩为简洁的 Groth16 证明，可快速验证。\n为了证明zkBridge的实用性，我们在Cosmos和以太坊之间实现了zkBridge的端到端原型，包括deVirgo和递归验证协议，以及交易中继应用。\nNotation\nFFF：有限域\nλ\\lambdaλ：安全参数\nf(),h()f(),h()f(),h()：多项式表达式\nx,yx,yx,y：单一变量\nx⃗,y⃗\\vec{x},\\vec{y}x,y​：变量向量\nx⃗[i],x⃗[i:k]=(xi,xi+1,...,xk)\\vec{x}[i],\\vec{x}[i:k]=(x_i,x_{i+1},...,x_k)x[i],x[i:k]=(xi​,xi+1​,...,xk​)\nMerkle Tree:\n\nrt←MT.Commit(x⃗)rt\\leftarrow MT.Commit(\\vec{x})rt←MT.Commit(x)\n(x⃗[i],πi)←MT.Open(x⃗,i)(\\vec{x}[i],\\pi_i)\\leftarrow MT.Open(\\vec{x},i)(x[i],πi​)←MT.Open(x,i)\n{1,0}←MT.Verify(πi,x⃗[i],rt)\\{1,0\\}\\leftarrow MT.Verify(\\pi_i,\\vec{x}[i],rt){1,0}←MT.Verify(πi​,x[i],rt)\n\nblk={blkh;trx1,...,trxt}blk=\\{blkh;trx_1,...,trx_t\\}blk={blkh;trx1​,...,trxt​}：区块\nLOGri=[blk1,...,blkr]LOG_r^i=[blk_1,...,blk_r]LOGri​=[blk1​,...,blkr​]：账本，rrr是高度，blkk⋅ptr=blkHk−1blk_{k\\cdot ptr}=blkH_{k-1}blkk⋅ptr​=blkHk−1​\n一致性：对于诚实的节点i,ji,ji,j，一定有LOGir0LOG_i^{r_0}LOGir0​​是LOGjr1LOG_j^{r_1}LOGjr1​​的前缀。\n有效性：如果一个诚实节点在某一轮 rrr 收到了某笔交易trxtrxtrx，那么trxtrxtrx最终会被包含到所有诚实节点的区块链中。\nLightCC(LCSr−1,blkHr−1,blkHr)→{true,false}LightCC(LCS_{r-1},blkH_{r-1},blkH_r)\\rightarrow \\{true,false\\}LightCC(LCSr−1​,blkHr−1​,blkHr​)→{true,false}：轻客户端的区块验证规则，其中blkHrblkH_rblkHr​表示新的区块头，blkHr−1blkH_{r-1}blkHr−1​旧的区块头，LCSr−1LCS_{r-1}LCSr−1​当前的状态\n**零知识证明：**当λ\\lambdaλ作为安全参数，RRR是一种NPNPNP关系，算法(G,P,V)(\\mathcal{G,P,V})(G,P,V)对于RRR来说是零知识的，当其满足：\n\nCompleteness：对于G(1λ)\\mathcal{G}(1^\\lambda)G(1λ)产生的参数pppppp，(x;w)∈R,π←P(x,w,pp)(x;w)\\in \\mathcal{R},\\pi\\leftarrow \\mathcal{P}(x,w,pp)(x;w)∈R,π←P(x,w,pp)：\n\nPr[V(x,π,pp)=1]=1Pr[\\mathcal{V}(x,\\pi,pp)=1]=1\nPr[V(x,π,pp)=1]=1\n\nKnowledge Soundness：对于PPT的证明者P∗\\mathcal{P}^*P∗，存在一个PPT模拟器E\\mathcal{E}E和辅助字符串zzz.pp←G(1λ),π∗←P∗(x,z,pp),w,EP∗(⋅)(x,z,pp)pp\\leftarrow \\mathcal{G}(1^\\lambda),\\pi^* \\leftarrow P^*(x,z,pp),w,\\mathcal{E}^{P^*(\\cdot)}(x,z,pp)pp←G(1λ),π∗←P∗(x,z,pp),w,EP∗(⋅)(x,z,pp)：\n\nPr[(x;w)\\notin R \\and \\mathcal{V}(x,\\pi^*,pp)=1]\\le negl(\\lambda)\n\n\nZero knowledge：存在一个PPT模拟器SSS对于PPT算法V∗\\mathcal{V}^*V∗，(x,w)∈R,pp←G(1λ)(x,w)\\in \\mathcal{R},pp\\leftarrow \\mathcal{G}(1^\\lambda)(x,w)∈R,pp←G(1λ)\n\nView(V∗(pp,x))≈SV∗(x)View(\\mathcal{V}^*(pp,x))\\approx \\mathcal{S}^{\\mathcal{V}^*}(x)\nView(V∗(pp,x))≈SV∗(x)\n我们说(G,P,V)(\\mathcal{G,P,V})(G,P,V)是简洁的，当P,V\\mathcal{P,V}P,V之间的总开销（证明大小）以及V\\mathcal{V}V的运行时间，是poly(λ,∣x∣,log∣R∣)poly(\\lambda,|x|,log|\\mathcal{R}|)poly(λ,∣x∣,log∣R∣)的，其中∣R∣|R|∣R∣是电路的大小\nzkBridge\n注意：zkBridge两个方向的操作是一致的。\nOverview\n为了让不同的应用程序都能轻松地与 zkBridge 集成，我们采用了模块化设计，将特定于应用程序的逻辑（如验证智能合约状态）与核心桥接功能（即转发区块头）分离开来。\n\n如图显示了zkBridge的架构和工作流程。核心桥接功能由一个区块头中继网络（仅在有效性方面受信任）提供，C1\\mathcal{C}_1C1​的中继块头提供正确性证明，C2\\mathcal{C}_2C2​的更新器合约验证和接收证明。\n更新器合约维护最新的区块头列表，并在验证中继节点提交的证明后对其进行适当更新；它公开了一个简单且与应用程序无关的应用程序接口，应用程序智能合约可以从中获取发送方区块链的最新区块头，并在此基础上构建特定于应用程序的逻辑。\n依赖于 zkBridge 的应用程序通常会在C1\\mathcal{C}_1C1​和C2\\mathcal{C}_2C2​上分别部署一对合约，即发送方合约和接收方合约。我们把它们统称为应用合约或依赖合约。接收者合约可以调用更新器合约来获取C1\\mathcal{C}_1C1​的块头，并在此基础上执行特定的应用任务。根据应用的不同，接收方合约可能还需要用户或第三方提供特定应用的证明，如智能合约状态的 Merkle 证明。\n如图展示了跨链代币转移的工作流程。\n假设用户u\\mathcal{u}u想要在另一个区块链C2\\mathcal{C}_2C2​上的交易所交易她在C1\\mathcal{C}_1C1​的资产，即将资金从C1\\mathcal{C}_1C1​转移到C2\\mathcal{C}_2C2​上。\n一对智能合约SClockSC_{lock}SClock​和SCmintSC_{mint}SCmint​分别部署在区块链C1C_1C1​和C2C_2C2​上。\n为了转移资金，用户将 $v 代币锁定在SClockSC_{lock}SClock​（图 1 中的步骤 1），然后请求SCmintSC_{mint}SCmint​发行 $v 代币。\nSCmintSC_{mint}SCmint​只应在且仅在用户已锁定C1C_1C1​上的代币时才发行新代币。这要求SCmintSC_{mint}SCmint​从不同的区块链读取SClockSC_{lock}SClock​的状态（U\\mathcal{U}U的余额，在步骤 2 中更新），但它不能直接这样做。\nzkBridge 通过将C1C_1C1​的区块头和证明一起转发给C2C_2C2​来实现这一点（步骤 3 和 4）。\nSCmintSC_{mint}SCmint​可以从智能合约前端（更新合约）获取区块头，检查用户U\\mathcal{U}U的余额是否确实为 $v（步骤 5 ），然后能铸造 $v 代币（步骤 6 ）。\n除了跨链代币转移，zkBridge 还能实现其他各种应用，如跨链抵押贷款、一般消息传递等。\ndetail\nsecurity and system model\n为了建模桥，我们将区块链C\\mathcal{C}C建模为区块编号索引的键值存储，表示为C[t]:K→V\\mathcal{C}[t]:\\mathcal{K}\\rightarrow \\mathcal{V}C[t]:K→V其中ttt是区块编号，K\\mathcal{K}K和 V\\mathcal{V}V分别是键和值空间。\n例如，以太坊中，V={0,1}256\\mathcal{V}=\\{0,1\\}^{256}V={0,1}256（每个地址存储32字节的值），密钥是智能合约标识符SC\\mathcal{SC}SC和每个智能合约存储地址K\\mathcal{K}K的连接。对于一个给定的合约SC\\mathcal{SC}SC，我们将存储在地址K\\mathcal{K}K区块编号ttt的值记作SC[t,K]\\mathcal{SC}[t,\\mathcal{K}]SC[t,K]，将SC[t,⋅]\\mathcal{SC}[t,\\cdot]SC[t,⋅]叫做SC\\mathcal{SC}SC在区块编号为ttt的状态\n我们关注于从SC1\\mathcal{SC}_1SC1​到SC2\\mathcal{SC}_2SC2​，记作BR[SC1→SC2]\\mathcal{BR}[\\mathcal{SC}_1\\rightarrow \\mathcal{SC}_2]BR[SC1​→SC2​]\nFunctional and security goals\n我们要求桥BR[SC1→SC2]\\mathcal{BR}[\\mathcal{SC}_1\\rightarrow \\mathcal{SC}_2]BR[SC1​→SC2​]正确及时地反映SC1\\mathcal{SC}_1SC1​的状态：\n正确性： 对于所有t,Kt,\\mathcal{K}t,K，SC2\\mathcal{SC}_2SC2​接受错误状态V≠SC1[t,K]\\mathcal{V}\\ne \\mathcal{SC}_1[t,\\mathcal{K}]V​=SC1​[t,K]的概率可忽略不计。\n有效性： 假设SC2\\mathcal{SC}_2SC2​需要验证SC1SC_1SC1​在(t,K)(t,K)(t,K)处的状态，桥最终会提供必要的信息。\nSecurity assumptions\n为了保证正确性，除了底层区块链的信任假设外，zkBridge 没有引入额外的信任假设。也就是说，我们假设发送方区块链和接收方区块链都是一致的和有效的（第 2 节），并且发送方链有一个轻客户端协议，可以快速验证区块头。对于这两个特性，我们假设中继网络中至少有一个诚实节点，并且所使用的 zk-SNARK 是可靠的。\nconstruction\n如第 3 节所述，桥接器BR[SC1→SC2]\\mathcal{BR}[\\mathcal{SC}_1\\rightarrow \\mathcal{SC}_2]BR[SC1​→SC2​]由三个部分组成：区块头中继网络、更新合约和一个或多个应用合约。下面我们将说明每个组件的协议。\n区块头中继网络：\n\n块标头中继网络中的节点以更新合约的当前状态（LCSr−1,blkHr−1LCS_{r-1},blkH_{r-1}LCSr−1​,blkHr−1​）为输入，运行 RelayNextHeader。\n中继节点连接到C1C_1C1​中的全节点，并获得继blkHr−1blkH_{r-1}blkHr−1​之后的块头blkHrblkH_rblkHr​。中继节点生成一个 ZKP π\\piπ，显示blkHrblkH_rblkHr​的正确性，主要证明blkHrblkH_rblkHr​在块blkHr−1blkH_{r-1}blkHr−1​之后被C1C_1C1​的轻客户端接受。\n它将 (π,blkHr\\pi,blkH_rπ,blkHr​) 发送给C2C_2C2​上的更新合约。\n为了避免因碰撞而浪费证明时间（注意，当多个中继节点同时发送时，只能接受一个证明），中继节点可以使用标准技术进行协调（例如，以循环方式发送）。\n为了激励区块头中继节点，证明者可以在验证其证明后获得费用奖励。激励机制的设计留待今后研究。\n我们注意到，这种设计依赖于发送者链的轻客户端验证器的安全性。例如，轻客户端验证器必须拒绝最终可能成为孤儿且不属于发件人链的有效块头。\n更新者合约\n\n更新器合约维护轻客户端的内部状态，包括 headerDAG 中C1C_1C1​的区块头列表。它有两个公开暴露的函数。HeaderUpdate 函数可以可由任何区块头中继节点调用，并提供下一个区块头和一个证明作为输入。如果证明与当前轻客户端状态 LCSLCSLCS 和 blkHr−1blkH_{r-1}blkHr−1​ 一致，合约将对轻客户端进行进一步检查，然后相应地更新状态。由于该函数的调用者必须支付一定费用，因此自然可以防止DoSDoSDoS攻击。\n接收合约可调用 GetHeader 函数来获取高度为 ttt 的区块头。接收方合约可以使用获得的区块头完成特定应用验证，可能需要用户或第三方的帮助。\nzkBridge 采用模块化设计，更新合约与应用程序无关。因此，在BR[SC1→SC2]\\mathcal{BR}[\\mathcal{SC}_1\\rightarrow \\mathcal{SC}_2]BR[SC1​→SC2​]中，由应用合约SC1SC_1SC1​和SC2SC_2SC2​决定桥接的信息是什么。一般来说，证明SC1[t,K]=VSC_1[t,K]=VSC1​[t,K]=V的过程非常简单：SC2SC_2SC2​可以请求获得与地址KKK对应的状态 Trie Tree 的叶子（位于区块编号 𝑡）的 Merkle 证明。接收方合约可以通过调用函数 GetHeader(t)GetHeader(t)GetHeader(t)，从更新方合约中获取blkHtblkH_tblkHt​。然后，它可以根据blkHtblkH_tblkHt​中的 Merkle 根验证SC1[t,K]=VSC_1[t,K]=VSC1​[t,K]=V\n下面的定理说明了 zkBridge 的安全性。\n由协议 1 和 2 实现的桥BR[SC1→SC2]\\mathcal{BR}[\\mathcal{SC}_1\\rightarrow \\mathcal{SC}_2]BR[SC1​→SC2​]同时满足一致性和有效性，假设以下条件成立：\n\n在区块头中继网络中至少有一个诚实节点；\n发送方链是一致和有效的；\n发送方链有一个定义 2.1 中的轻客户端验证器；以及\n简洁证明系统是健全的。\n\nApplication cases\nTransaction inclusion: a building block\n跨链应用的一个常见构件是验证另一个区块链上的交易包含性。\n具体来说，目的是使C2C_2C2​上的接收方合约SC2SC_2SC2​能够验证给定的交易trxtrxtrx已包含在高度为ttt的C1C_1C1​上的区块BtB_tBt​中。为此，接收方合约SC2SC_2SC2​需要用户或第三方服务为BtB_tBt​中的trxtrxtrx提供 Merkle 证明。然后，SC2SC_2SC2​将调用更新器合约，检索高度为ttt的C1C_1C1​的区块头，然后根据头中包含的 Merkle 根验证所提供的 Merkle 证明。\n消息传递和数据分享\n跨链消息传递是另一种常见的构建模块，可用于跨区块链共享链外数据等。消息传递可以通过在交易中嵌入消息，作为交易包含的简单扩展来实现。具体来说，要将C1C_1C1​的消息mmm传递到C2C_2C2​，用户可以将mmm嵌入事务trxmtrx_mtrxm​，将trxmtrx_mtrxm​发送到C1C_1C1​，然后执行上述事务包含证明。\n跨链交换资产\n在此应用中，用户可以在发送方区块链C1C_1C1​上注入一定数量的代币TAT_ATA​，并在接收方区块链C2C_2C2​上获得相同数量的代币TAT_ATA​（如果符合条件，用于原生资产转移）或一定数量的价值大致相同的代币TBT_BTB​（用于原生资产交换）。\n首先，开发者会在C1C_1C1​上部署一个锁合约SClockSC_{lock}SClock​，在SCSCSC上部署一个合约SCmintSC_{mint}SCmint​。如果用户想将nAn_AnA​的代币TAT_ATA​换成等值的代币TBT_BTB​。\n她将首先发送一个交易trxlocktrx_{lock}trxlock​，将nAn_AnA​的代币TAT_ATA​转移到SClockSC_{lock}SClock​，同时发送一个地址addrC2addr_{C_2}addrC2​​，以便在C2C_2C2​上接收代币TBT_BTB​。在区块BBB中确认trxlocktrx_{lock}trxlock​后，用户将向SCmintSC_{mint}SCmint​发送交易trxminttrx_{mint}trxmint​，其中包括足够的信息来验证是否包含trxlocktrx_{lock}trxlock​。根据trxminttrx_{mint}trxmint​中的信息，SCmintSC_{mint}SCmint​将验证C1C_1C1​上是否包含了trxlocktrx_{lock}trxlock​，并将相应的TBT_BTB​代币转移到trxlocktrx_{lock}trxlock​中指定的地址addrC2addr_{C_2}addrC2​​上。\n最后，SCmintSC_{mint}SCmint​将标记trxlocktrx_{lock}trxlock​为铸币，以完成转账。\nNFT的互操作\n在不可兑换代币（NFT）的互操作应用中，用户总是在发送方区块链上锁定/标记 NFT，并在接收方区块链上获得铸币的 NFT 或 NFT 衍生物。通过设计 NFT 衍生物，跨链协议可以在两个区块链系统上分离 NFT 的所有权和效用，从而支持在发送方区块链上锁定 NFT 的所有权，在接收方区块链上获取效用。\nefficient proof systems for zkBridge\n当发送链和接收链使用不同的加密实现时，开销的一个主要来源是不同椭圆曲线之间的字段转换，这在实践中很常见。\n为了使 zkBridge 实用化，我们提出了两个想法。\n利用 deVirgo 缩短证明时间。我们发现，用于验证多个签名的 ZKP 电路由一个子电路的多个副本组成。我们的第一个想法是利用这一特殊结构，在多个服务器之间分布式生成证明。我们提出了一种名为 deVirgo 的新型分布式 ZKP 协议。\n通过递归验证降低链上成本。虽然在普通 CPU 上验证 deVirgo 证明非常高效，但链上验证的成本仍然很高。为了进一步降低链上验证成本（计算和存储），我们使用递归验证：证明者递归地证明正确的证明。\n证明者使用对智能合约友好的零知识协议递归证明一个（可能很大的）Virgo 证明的正确性，从而得到一个小的、验证者效率高的证明。\nDistributed Proof Generation\n快速验证时间的机会来自于验证NNN签名的电路由相同子电路的NNN副本组成这一事实。这种电路被称为数据并行电路\n我们选择 Virgo 作为底层 ZKP 协议有两个原因：\n\n\nVirgo 不需要可信设置，而且是可信的后量子安全协议。\n\n\nVirgo 是最快的协议之一，验证时间简洁，证明规模简洁，可解决大规模问题。.\n\n\n我们为数据并行算术电路提出了一种新的分布式 Virgo 版本，它能在证明大小不增加任何开销的情况下实现最佳可扩展性。具体地说，在使用NNN台并行机器、具有NNN个副本的数据并行电路上，我们的 deVirgo 协议比原始 Virgo 快NNN倍，而证明大小保持不变。我们的方案具有独立的意义，可以用于其他基于 Virgo 的系统，以提高效率。\n假设证明者总共有NNN台机器，标记范围从P0P_0P0​到PN−1P_{N-1}PN−1​。\n假设P0P_0P0​是主节点，其他机器是普通节点。假设vvv是验证器。\n给定一个由NNN个相同结构组成的数据并行算术电路，分布式 Virgo 的简单算法是将每个子电路分配给一个单独的节点。然后，每个节点分别运行 Virgo 生成证明。𝑁 证明的合并即为最终证明。\n遗憾的是，这种天真算法的证明大小与子电路的数量成线性关系，这对于具有许多子副本的数据并行电路来说，可能大得令人望而却步。\n为了解决这个问题，我们的方法通过在分布式机器之间聚合信息和证明，消除了证明大小中的NNN附加因子。具体来说，Virgo 的原始协议由两个主要构件组成。一个是 GKR 协议 [53]，它由深度为ddd的电路的sumcheck 协议组成。另一个是多项式承诺（PC）方案。我们分别为求和检查和多项式承诺 (PC) 设计了分布式方案。\n在我们的分布式 sumcheck 协议中，主节点P0P_0P0​会汇总来自所有机器的信息，然后在每一轮将汇总后的信息发送给 vvv，而不是直接将来自所有机器的信息发送给 𝒱。我们的分布式 sumcheck 协议与原始 sumcheck 协议的证明大小完全相同，因此比原始分布式协议节省了NNN倍。此外，在我们的分布式 PC 协议中，我们优化了承诺阶段，让P0P_0P0​将NNN个承诺聚合成一个，而不是直接将NNN个承诺发送给vvv。在开局阶段，证明也可以聚合在一起，这样就能以多项式大小的对数因子来改善证明的大小。\n","categories":["论文阅读"],"tags":["cross-chain"]},{"title":"simulation","url":"/posts/cbda467b.html","content":"\nHow To Simulate It – A Tutorial on the Simulation Proof Technique\n本文将介绍如何通过模拟的思想去证明一个密码学系统的安全性。\n文档原文：https://eprint.iacr.org/2016/046.pdf\nIntroduction\n首先，我们需要理解什么是模拟–simulation。\n原文是这样描述的：\nSimulation is a way of comparing what happens in the “real world” to what happens in an “ideal world” where the primitive in question is secure by definition. \n也就是说，模拟是一种比较方式，将ideal world和real world进行比较。\n所谓的理想世界 (ideal world) 是一个理论模型，用于描述一个安全协议在理想条件下的行为。在这个模型中，存在一个被称为理想函数的抽象实体，它能够完美地执行协议应有的功能，而不会泄露任何额外的信息。同时，还有一个模拟器 (simulator)，它尝试模拟真实世界中敌手可能观察到的行为，但又不会使用任何真实的秘密信息。\n**现实世界（real world）**就是指我们设计和实施密码学协议的环境。现实世界中，协议需要与潜在的攻击者（Adversary）进行交互。\n这两个概念出现在UC（Universally Composable）安全框架中。在UC框架中，如果现实世界的协议能够被证明与理想世界中的理想功能等效，那么我们就可以说该协议是安全的。这意味着，即使在面对现实世界中的攻击者时，协议也能保持与理想功能相同的安全性。\n在理想世界中，既然对手什么也学不到，这就意味着在现实世界中，当对手收到密文时，也什么也学不到。\n原文提到了模拟器必须做的三个任务：\n1.\tIt must generate a view for the real adversary that is indistinguishable from its real view;2.\tIt must extract the effective inputs used by the adversary in the execution; and3.\tIt must make the view generated be consistent with the output that is based on this input.\n我们逐个分析一下：\n\n它必须为真实对手生成一个与其真实视图无法区分的视图。\n\n这里的“对手的视图”指的是对手通过分析交互过程中获得的信息所构建的关于系统状态的认知。简而言之，就是对手能够观察到的所有信息的集合。\n\n它必须提取对手在执行过程中使用的有效输入。\n\n有效输入是指对手为了达到其目的而输入到系统中的数据，这些数据可能会影响系统的行为或输出。\n\n必须使生成的视图与基于该输入的输出保持一致。\n\n这意味着模拟器生成的对手视图必须与对手在真实世界中根据其输入所期望的输出相匹配。\nPreliminaries and Notation\nS⊆{0,1}∗S\\subseteq \\{0,1\\}^*S⊆{0,1}∗：有限集合 SSS，表示集合S是由0和1组成的所有可能字符串的子集。如果我们有一个集合S，它包含的元素是由0和1组成的字符串，那么这个集合S就可以被认为是{0,1}∗\\{0,1\\}^*{0,1}∗的子集。这里的“有限集合”意味着集合中的元素数量是可数的，也就是说，我们可以数出集合中有多少个元素。\n举几个例子：\n\nS = {0, 1}：这个集合包含两个元素，分别是字符串&quot;0&quot;和&quot;1&quot;。\nS = {00, 01, 10, 11}：这个集合包含所有长度为2的由0和1组成的字符串。\nS = {ε, 0, 01, 110, 1110}：这个集合包含空字符串ε（表示没有任何字符），以及其他几个由0和1组成的字符串。\n\nx∈RSx\\in_R Sx∈R​S：表示 x 在集合 S 上均匀分布。\n具体来说，对于 {0,1}ⁿ，这个集合包含了所有可能的长度为 n 的二进制字符串。如果我们从这个集合中随机选择一个字符串，每个字符串被选中的概率都是 1/2ⁿ，因为总共有 2ⁿ 个可能的字符串。\n例如，如果 n=2，那么集合 {0,1}² 包含以下四个字符串：00、01、10 和 11。在均匀分布 U₂ 下，选择这四个字符串中的任何一个的概率都是相同的，即 1/4。\n再比如，如果 n=3，那么集合 {0,1}³ 就包含以下八个字符串：000、001、010、011、100、101、110 和 111。在均匀分布 U₃ 下，选择这八个字符串中的任何一个的概率都是相同的，即 1/8。\nμ(⋅)\\mu(\\cdot)μ(⋅)：一个表示概率上可忽略函数\np(⋅)p(\\cdot)p(⋅)：正多项式\nλ\\lambdaλ：空字符串\n计算不可区分性（Computational Indistinguishability）：\n概率集合X=X(a,n)a∈{0,1};n∈NX={X(a,n)}_{a\\in\\{0,1\\};n\\in N}X=X(a,n)a∈{0,1};n∈N​是以a∈{0,1}∗a\\in\\{0,1\\}^*a∈{0,1}∗和n∈Nn\\in Nn∈N为索引的随机变量的无限序列。aaa代表各方的输入，nnn代表安全参数。\n有点抽象，举两个例子：\n假设我们有一个概率实验，它可以产生一个二进制字符串，比如抛硬币序列。对于每个二进制字符串\naa\na\n和每个自然数\nnn\nn\n，我们定义一个随机变量\nX(a,n)X(a,n)\nX(a,n)\n它可能代表在这个实验中得到字符串\naa\na\n的概率，或者在\nnn\nn\n次实验中得到字符串\naa\na\n的次数。\n例如，如果我们抛一枚硬币两次，可能得到的二进制字符串有\n00,01,10,1100,01,10,11\n00,01,10,11\n对于每个字符串和每个自然数\nnn\nn\n我们可以定义一个随机变量来表示在\nnn\nn\n次实验中得到该字符串的次数。所以，如果我们把\nnn\nn\n设为2，那么\nX(00,2)X(00,2)\nX(00,2)\n可能表示在两次实验中都得到正面的次数，\nX(01,2)X(01,2)\nX(01,2)\n表示得到一次正面一次反面的次数，以此类推。\n让我们考虑一个与天气相关的概率集合的例子。\n假设我们有一个随机变量 X(a,n)X(a,n)X(a,n)，其中aaa是一个描述特定天气状况的字符串（例如 “晴天”、“雨天”、“多云” 等），而nnn是一个自然数，表示我们观察这种天气状况的天数。例如，如果我们关注的是 “晴天”，那么aaa就是 “晴天”，而nnn可以是任何自然数，比如 30。那么X(′Sunny′,30)X(&#x27;Sunny&#x27;,30)X(′Sunny′,30)就代表在观察的 30 天内，出现 “晴天” 的天数。这个概率集合XXX就包含了所有这些随机变量的无限序列，每个序列都与一个特定的天气状况和观察天数索引相关联。\n假设有两个这样的概率集合：\nX=X(a,n)a∈{0,1};n∈NX={X(a,n)}_{a\\in\\{0,1\\};n\\in N}X=X(a,n)a∈{0,1};n∈N​\nY=Y(a,n)a∈{0,1};n∈NY={Y(a,n)}_{a\\in\\{0,1\\};n\\in N}Y=Y(a,n)a∈{0,1};n∈N​\n如果对于每一个非统一多项式时间算法DDD，存在一个可忽略的函数μ(⋅)\\mu(\\cdot)μ(⋅)，使得对于每一个a∈{0,1}∗a∈\\{0,1\\}^*a∈{0,1}∗和每一个n∈Nn∈Nn∈N，都可以说X≡cYX\\stackrel{c}{\\equiv}YX≡cY在计算上是无差别的，用X≡cYX\\stackrel{c}{\\equiv}YX≡cY表示：\n∣Pr[D(X(a,n))=1]−Pr[D(Y(a,n))=1]≤μ(n)∣|Pr[D(X(a,n))=1]-Pr[D(Y(a,n))=1] \\le \\mu(n)|\n∣Pr[D(X(a,n))=1]−Pr[D(Y(a,n))=1]≤μ(n)∣\n原文中强调了：\nAll parties are assumed to run in time that is polynomial in the security parameter.\n这段话强调了在设计密码学算法时，需要考虑算法的效率和安全性，确保算法在可接受的时间内运行，同时保持足够的安全性。\n非均匀性（Non-uniformity）：\n如果对于每一个非均匀多项式时间算法DDD和每一个多项式p(⋅)p(\\cdot)p(⋅)都存在一个N∈N\\N\\in NN∈N，使得对于每一个n&gt;Nn &gt; Nn&gt;N 和每一个a∈{0,1}∗a\\in\\{0,1\\}^*a∈{0,1}∗都存在一个N∈N\\N\\in NN∈N，那么X≡cYX\\stackrel{c}{\\equiv}YX≡cY\n∣Pr[D(X(a,n))=1]−Pr[D(Y(a,n))=1]∣&lt;1p(n)|Pr[D(X(a,n))=1]-Pr[D(Y(a,n))=1]|&lt;\\frac{1}{p(n)}\n∣Pr[D(X(a,n))=1]−Pr[D(Y(a,n))=1]∣&lt;p(n)1​\n在计算机科学和密码学中，非均匀性（non-uniformity）指的是算法或计算模型可以访问与输入大小相关的额外信息或建议。这些额外信息通常以“建议字符串”（advice strings）的形式存在，它们不是由算法本身生成的，而是由外部提供。\n非均匀性意味着即使是非均匀的多项式时间算法（也就是可以访问建议字符串的算法），也不能有效地区分两个分布集合。\n这是一种更加强大条件的计算不可区分性。\n此外，原文还给出了另一个极端条件下的式子：\n存在一个DDD和一个多项式p(⋅)p(\\cdot)p(⋅)，对于无限多个nnn，存在一个a∈{0,1}∗a\\in \\{0,1\\}^∗a∈{0,1}∗ ，其中\n∣Pr[D(X(a,n))=1]−Pr[D(Y(a,n))=1]∣≥1p(n)|Pr[D(X(a,n))=1]-Pr[D(Y(a,n))=1]|\\ge \\frac{1}{p(n)}\n∣Pr[D(X(a,n))=1]−Pr[D(Y(a,n))=1]∣≥p(n)1​\n这两个定义看似矛盾，实际上描述了两种极端情况。第一个定义描述了当两个分布是计算不可区分的时候的情况，即没有算法能够有效地区分它们。第二个定义描述了当两个分布是可区分的时候的情况，即存在至少一个算法能够有效地区分它们。这两个定义之间的矛盾表明，计算不可区分性是一个非常强的属性，它要求对于几乎所有的输入大小和建议字符串，都没有算法能够区分两个分布。\n非均匀性算法的例子：\n一个典型的例子是在密码学中的非一致性敌手模型（non-uniform adversary model）。在这个模型中，敌手（即攻击者）可以利用一些额外的信息来增强其攻击能力。这些额外的信息可能是之前的攻击经验、特定的密码学结构的弱点，或者是通过某些方式预先计算出的有用信息。\n例如，考虑一个简单的加密方案，其中使用了一个伪随机函数（PRF）来生成密钥。在一个均匀的敌手模型中，敌手只能使用多项式时间的算法来尝试破解密钥。然而，在一个非一致性敌手模型中，敌手可能拥有一个与输入大小相关的建议字符串，这个字符串可能包含了一些关于伪随机函数内部结构的信息，从而使得敌手能够更有效地破解密钥。\n另一个例子是彩虹表攻击（rainbow table attack）。彩虹表是一种预先计算出的数据结构，它可以用来逆向工程哈希函数的输出。在一个非一致性敌手模型中，敌手可以使用彩虹表作为建议字符串，这样他们就可以快速地找到哈希函数的输入，即使哈希函数设计为均匀的算法也无法防止这种攻击。\n虽然非均匀性定义了一个更强大的安全模型，但在实际应用中，密码学算法和协议一般都是均匀性的，以确保它们在广泛的环境和条件下都能安全有效地工作。\n最后一段话还强调了在定义计算不可区分性时，量词的顺序非常重要。正确的定义要求对于所有的aaa，存在一个统一的可以忽略的函数，而不是对于每个aaa都有一个可能不同的可以忽略的函数。这保证了计算不可区分性的定义在密码学中的实用性和强度。\nThe Basic Paradigm – Semantic Security\nNothing is learned about the plaintext from the ciphertext.\n这句话很难形式化，但也是接下来的工作。\n首先，语义安全的定义允许明文的长度取决于安全参数，并允许明文的任意分布，此外，还允许信息的辅助函数hhh存在。\n对手的目的是从密文和所提供的辅助信息中学习明文的某个函数fff。\n根据该定义，仅从辅助信息（以及明文的长度）而不从密文中学习相同的信息应该是可能的。\n一个私钥加密方案(G,E,D)(G,E,D)(G,E,D)的安全性， 如果对于每个非统一概率多项式时间算法A\\mathcal{A}A，存在一个非统一概率多项式时间算法A′\\mathcal{A}^\\primeA′，使得对于每个概率集合{Xn}n∈N\\{X_n\\}_{n\\in N}{Xn​}n∈N​，∣Xn∣≤poly(n)|Xn| ≤ poly(n)∣Xn∣≤poly(n)，每一对多项式有界函数f,h：{0,1}∗→{0,1}∗f,h ： \\{0,1\\}*→\\{0,1\\}^∗f,h：{0,1}∗→{0,1}∗，每个正多项式p(⋅)p(\\cdot)p(⋅)和所有足够大的nnn：\nPrk←G(1n)[A(1n,Ek(Xn),1∣Xn∣,h(1n,Xn))=f(1n,Xn)]&lt;Pr[A(1n,1∣Xn∣,h(1n,Xn))=f(1n,Xn)]+1pn\\underset{k\\leftarrow G(1^n)}{Pr}[\\mathcal{A}(1^n,E_k(X_n),1^{|X_n|},h(1^n,X_n))=f(1^n,X_n)]\\lt Pr [\\mathcal{A}(1^n,1^{|X_n|},h(1^n,X_n))=f(1^n,X_n)] + \\frac{1}{p_n}\nk←G(1n)Pr​[A(1n,Ek​(Xn​),1∣Xn​∣,h(1n,Xn​))=f(1n,Xn​)]&lt;Pr[A(1n,1∣Xn​∣,h(1n,Xn​))=f(1n,Xn​)]+pn​1​\n这一段话其实阐明了一个道理：A\\mathcal{A}A（在给定密文的情况下）可以知道的任何信息都可以被A′\\mathcal{A}^\\primeA′（在不给定密文的情况下）知道。\n从模拟的角度来说，A′\\mathcal{A}^\\primeA′就是处在一个理想的世界，因为它所学到的任何东西都只来自辅助信息和明文长度，但是根据定义，我们知道A′\\mathcal{A}^\\primeA′和A\\mathcal{A}A能学习的东西一样多。\n这里提供了一个基于模拟器的证明过程：\nSimulator A′Simulator\\ \\mathcal{A}^\\primeSimulator A′：输入1n,1∣Xn∣,h=h(1n,Xn)1^n,1^{|X_n|},h=h(1^n,X_n)1n,1∣Xn​∣,h=h(1n,Xn​)，算法A′\\mathcal{A}^\\primeA′如下运行：\n\nA′\\mathcal{A}^\\primeA′运行G(1n)G(1^n)G(1n)得到密钥kkk\nA′\\mathcal{A}^\\primeA′计算c=Ek(0∣Xn∣)c=E_k(0^{|X_n|})c=Ek​(0∣Xn​∣)作为加密垃圾\nA′\\mathcal{A}^\\primeA′运行A(1n,c,1∣Xn∣,h)\\mathcal{A}(1^n,c,1^{|X_n|},h)A(1n,c,1∣Xn​∣,h)并且输出A\\mathcal{A}A输出的。\n\n在这个模拟证明中，“垃圾”加密的定义是指一个看起来像有效加密的数据，但实际上是无意义的。这种加密的目的是测试算法 (A\\mathcal{A}A) 是否能够区分真正的加密和无意义的加密。如果 (A\\mathcal{A}A) 不能区分这两者，那么我们可以说加密算法是安全的，因为即使攻击者得到了加密数据，他们也无法确定它是否包含有用的信息。\nSecure Computation – Simulation for Semi-Honest Adversaries\nBackground\n在密码学中，半诚实的敌手（也称为被动敌手或静态敌手）是指在两方计算中，控制一方的攻击者。这种敌手遵循协议的规定执行所有步骤，但会尝试通过分析它接收到的消息记录和内部状态来获取更多信息。这是一个相对较弱的敌手模型，因为它不会主动破坏协议，只是被动地收集信息。\n半诚实的敌手模型的特点包括：\n\n静态：敌手在计算开始时就确定，并且在整个计算过程中控制同一方。\n遵循协议：敌手精确地按照协议规定的步骤执行，不会做出任何违反规定的行为。\n信息收集：敌手的目标是通过观察通信过程中的消息来学习额外的信息，而不是直接破坏协议。\n\n尽管这是一个弱敌手模型，但如果协议能在半诚实敌手的存在下保证安全，那么它至少可以保证没有无意的信息泄露。这种安全性对于那些基本信任对方但又想确保自己的输入不会被记录的场景是足够的。此外，为半诚实敌手设计的安全协议通常是构建更强安全性协议的第一步。\nDefining Security for Semi-Honest Adversaries\n两方计算\n两方计算允许两个参与方（通常称为Alice和Bob）协作计算某个函数，而无需泄露各自的输入信息。\n原文这样定义了两方计算：\nf:{0,1}∗×{0,1}∗→{0,1}∗×{0,1}∗,where f=(f1,f2),x,y∈{0,1}nf:\\{0,1\\}^* \\times \\{0,1\\}^* \\rightarrow \\{0,1\\}^* \\times \\{0,1\\}^*, where\\ f = (f_1, f_2), x,y \\in \\{0,1\\}^n\nf:{0,1}∗×{0,1}∗→{0,1}∗×{0,1}∗,where f=(f1​,f2​),x,y∈{0,1}n\n其中一方输入xxx，输出f1(x,y)f_1(x,y)f1​(x,y)\n另一方输入yyy，输出f2(x,y)f_2(x,y)f2​(x,y)\n隐私通过模拟（Privacy by Simulation）\n如果参与协议的一方可以计算的任何内容都只能根据协议的输入和输出来计算，那么该协议就是安全的。\n在这个定义中，模拟器将会被给予参与方一方的输入与输出（之所以是输入与输出，而不仅仅是输入，是因为，我们想要证明的是即使在协议执行过程中，参与方也无法学到任何超出其输入和预定输出之外的信息。为了做到这一点，模拟器需要重现参与方在协议执行中的视图，这包括了它们的输入和它们从协议中获得的输出。）\n值得注意的是，参与计算的双方都是半诚实的。在半诚实模型中，因为参与方遵循协议并使用他们的真实输入，所以输出 ( f(x,y)f(x,y)f(x,y) ) 是可以预先定义的。这意味着模拟器可以被给予 ( f(x,y)f(x,y)f(x,y) ) 这个值来生成参与方的视图，而不需要考虑对手可能的行为。\n与此相反的是，恶意敌手（malicious adversaries）。半诚实参与方和恶意敌手的主要区别在于他们对协议的遵守程度。半诚实参与方会遵循协议规则，使用真实的输入，这使得输出是可预测和明确定义的。而恶意敌手可能会违反规则，使用不同的输入，这使得输出不再是固定的，而是取决于敌手的选择。\nDefinition of security\n\n函数f=(f1,f2)f=(f_1,f_2)f=(f1​,f2​)，双方协议π\\piπ\nviewiπ(x,y,n)view_i^\\pi(x,y,n)viewiπ​(x,y,n)表示第iii方执行协议π\\piπ的视图，参数为(x,y,n)，其等同于(w,ri;m1i,...,mti)(w,r^i;m_1^i,...,m_t^i)(w,ri;m1i​,...,mti​)，w∈{x,y}w\\in\\{x,y\\}w∈{x,y}，rir^iri代表第iii方的磁带，mjim_j^imji​代表其收到的第jjj条消息\n第iii方的输出表示为outputiπ(x,y,n)output_i^\\pi(x,y,n)outputiπ​(x,y,n)，两方的联合输出表示为outputπ(x,y,n)=(output1π(x,y,n),output2π(x,y,n))output^\\pi(x,y,n)=(output_1^\\pi(x,y,n),output_2^\\pi(x,y,n))outputπ(x,y,n)=(output1π​(x,y,n),output2π​(x,y,n))\n\nDefinition 4.1: f=(f1,f2)f=(f_1,f_2)f=(f1​,f2​)，如果存在概率多项式时间算法S1S_1S1​和S2S_2S2​，我们说协议π\\piπ能够安全计算fff，即使在静态半诚实敌手的情况下：\n{(S1(1n,x,f1(x,y)),f(x,y))}x,y,n≡c{(view1π(x,y,n),outputπ(x,y,n))}x,y,n{(S2(1n,y,f2(x,y)),f(x,y))}x,y,n≡c{(view2π(x,y,n),outputπ(x,y,n))}x,y,n\\{(S_1(1^n,x,f_1(x,y)),f(x,y))\\}_{x,y,n}\\stackrel{c}{\\equiv} \\{(view_1^\\pi(x,y,n),output^\\pi(x,y,n))\\}_{x,y,n}\\\\\n\\{(S_2(1^n,y,f_2(x,y)),f(x,y))\\}_{x,y,n}\\stackrel{c}{\\equiv} \\{(view_2^\\pi(x,y,n),output^\\pi(x,y,n))\\}_{x,y,n}\n{(S1​(1n,x,f1​(x,y)),f(x,y))}x,y,n​≡c{(view1π​(x,y,n),outputπ(x,y,n))}x,y,n​{(S2​(1n,y,f2​(x,y)),f(x,y))}x,y,n​≡c{(view2π​(x,y,n),outputπ(x,y,n))}x,y,n​\n其中x,y∈{0,1}∗,∣x∣=∣y∣,n∈Nx,y\\in\\{0,1\\}^*,|x|=|y|,n\\in Nx,y∈{0,1}∗,∣x∣=∣y∣,n∈N\n模拟器的输出和功能输出f(x,y)=(f1(x,y),f2(x,y))f(x,y) = (f_1(x,y),f_2(x,y))f(x,y)=(f1​(x,y),f2​(x,y))的联合分布必须与(viewiπ(x,y,n),outputπ(x,y,n))(view_i^\\pi(x,y,n),output^\\pi(x,y,n))(viewiπ​(x,y,n),outputπ(x,y,n))不可区分\n现在，我们来考虑一个更简单的安全定义，它只将模拟器生成的分布与对手的观点（而不是联合分布）进行比较：\n{(S1(1n,x,f1(x,y))}x,y,n≡c{(view1π(x,y,n)}x,y,n{(S2(1n,x,f2(x,y))}x,y,n≡c{(view2π(x,y,n)}x,y,n\\{(S_1(1^n,x,f_1(x,y))\\}_{x,y,n}\\stackrel{c}{\\equiv} \\{(view_1^\\pi(x,y,n)\\}_{x,y,n}\\\\\n\\{(S_2(1^n,x,f_2(x,y))\\}_{x,y,n}\\stackrel{c}{\\equiv} \\{(view_2^\\pi(x,y,n)\\}_{x,y,n}\\\\\n{(S1​(1n,x,f1​(x,y))}x,y,n​≡c{(view1π​(x,y,n)}x,y,n​{(S2​(1n,x,f2​(x,y))}x,y,n​≡c{(view2π​(x,y,n)}x,y,n​\n根据这一定义，上述安全计算双方相同输出的协议是安全的。这是因为每一方的视图都是由x⋃yx\\bigcup yx⋃y的随机样本组成的，而这个视图是可以模拟的。\nA simpler formulation for deterministic functionalities：\n该定义有两个要求：(a) 正确性，即各方的输出都是正确的；\n(b) 私密性，即各方的观点都可以（单独）模拟。\n从形式上看，正确性要求存在一个可忽略的函数μ\\muμ，使得对于每个x,y∈{0,1}∗x,y\\in \\{0,1\\}^*x,y∈{0,1}∗和每个nnn，\nPr[outputπ(x,y,n)≠f(x,y)]≤μ(n)Pr[output^\\pi(x,y,n)\\ne f(x,y)]\\le \\mu(n)\nPr[outputπ(x,y,n)​=f(x,y)]≤μ(n)\n隐私性要求，存在概率多项式时间算法S1,S2S_1,S_2S1​,S2​\n{(S1(1n,x,f1(x,y))}x,y∈{0,1}∗;n∈N≡c{(view1π(x,y,n)}x,y∈{0,1}∗;n∈N{(S2(1n,x,f2(x,y))}x,y∈{0,1}∗;n∈N≡c{(view2π(x,y,n)}x,y∈{0,1}∗;n∈N\\{(S_1(1^n,x,f_1(x,y))\\}_{x,y\\in\\{0,1\\}^*;n\\in N}\\stackrel{c}{\\equiv} \\{(view_1^\\pi(x,y,n)\\}_{x,y\\in\\{0,1\\}^*;n\\in N}\\\\\n\n\\{(S_2(1^n,x,f_2(x,y))\\}_{x,y\\in\\{0,1\\}^*;n\\in N}\\stackrel{c}{\\equiv} \\{(view_2^\\pi(x,y,n)\\}_{x,y\\in\\{0,1\\}^*;n\\in N}\\\\\n{(S1​(1n,x,f1​(x,y))}x,y∈{0,1}∗;n∈N​≡c{(view1π​(x,y,n)}x,y∈{0,1}∗;n∈N​{(S2​(1n,x,f2​(x,y))}x,y∈{0,1}∗;n∈N​≡c{(view2π​(x,y,n)}x,y∈{0,1}∗;n∈N​\n区分者为了得到集合的索引x,yx,yx,y，可以自己计算f(x,y)f(x,y)f(x,y)，从而有\n{(S1(1n,x,f1(x,y))}x,y∈{0,1}∗;n∈N≡c{(view1π(x,y,n)}x,y∈{0,1}∗;n∈N{(S1(1n,x,f1(x,y)),f(x,y))}x,y∈{0,1}∗;n∈N≡c{(view1π(x,y,n),f(x,y))}x,y∈{0,1}∗;n∈N\\{(S_1(1^n,x,f_1(x,y))\\}_{x,y\\in\\{0,1\\}^*;n\\in N}\\stackrel{c}{\\equiv} \\{(view_1^\\pi(x,y,n)\\}_{x,y\\in\\{0,1\\}^*;n\\in N}\\\\\n\n\\{(S_1(1^n,x,f_1(x,y)),f(x,y))\\}_{x,y\\in\\{0,1\\}^*;n\\in N}\\stackrel{c}{\\equiv} \\{(view_1^\\pi(x,y,n),f(x,y))\\}_{x,y\\in\\{0,1\\}^*;n\\in N}\\\\\n{(S1​(1n,x,f1​(x,y))}x,y∈{0,1}∗;n∈N​≡c{(view1π​(x,y,n)}x,y∈{0,1}∗;n∈N​{(S1​(1n,x,f1​(x,y)),f(x,y))}x,y∈{0,1}∗;n∈N​≡c{(view1π​(x,y,n),f(x,y))}x,y∈{0,1}∗;n∈N​\n正确性要求保证输出outputπ(x,y,n)output^\\pi(x,y,n)outputπ(x,y,n)与f(x,y)f(x,y)f(x,y)在计算上无差别，这意味着\n{(view1π(x,y,n),f(x,y))}x,y∈{0,1}∗;n∈N≡c{(view1π(x,y,n),outputπ(x,y,n}x,y∈{0,1}∗;n∈N\\{(view_1^\\pi(x,y,n),f(x,y))\\}_{x,y\\in\\{0,1\\}^*;n\\in N}\\stackrel{c}{\\equiv} \\{(view_1^\\pi(x,y,n),output^\\pi(x,y,n\\}_{x,y\\in\\{0,1\\}^*;n\\in N}\\\\\n{(view1π​(x,y,n),f(x,y))}x,y∈{0,1}∗;n∈N​≡c{(view1π​(x,y,n),outputπ(x,y,n}x,y∈{0,1}∗;n∈N​\n因此，我们有：\n{(S1(1n,x,f1(x,y)),f(x,y))}x,y∈{0,1}∗;n∈N≡c{(view1π(x,y,n),outputπ(x,y,n}x,y∈{0,1}∗;n∈N\\{(S_1(1^n,x,f_1(x,y)),f(x,y))\\}_{x,y\\in\\{0,1\\}^*;n\\in N}\n\\stackrel{c}{\\equiv} \\{(view_1^\\pi(x,y,n),output^\\pi(x,y,n\\}_{x,y\\in\\{0,1\\}^*;n\\in N}\\\\\n{(S1​(1n,x,f1​(x,y)),f(x,y))}x,y∈{0,1}∗;n∈N​≡c{(view1π​(x,y,n),outputπ(x,y,n}x,y∈{0,1}∗;n∈N​\nTriviality for semi-honest adversaries\n我们注意到，在半诚信对手的情况下，许多问题都变得微不足道。例如，零知识，“承诺”，抛掷硬币问题\nAuxiliary information\n辅助输入在定义中是隐含的，因为针对非均匀对手的计算不可区分性是必需的，运行协议的对手无需提供任何辅助信息，因为它是半诚实的，因此无论有无辅助输入，都会遵循完全相同的指令。\nOblivious Transfer for Semi-Honest Adversaries\n不经意传输（OT, oblivious transfer）\nf((b0,b1),σ)=(λ,bσ),where b0,b1,σ∈{0,1}f((b_0,b_1),\\sigma)=(\\lambda,b_{\\sigma}),where\\ b_0,b_1,\\sigma\\in\\{0,1\\}\nf((b0​,b1​),σ)=(λ,bσ​),where b0​,b1​,σ∈{0,1}\nP1：(b0,b1)(b_0,b_1)(b0​,b1​)，没有任何输出\nP2：σ\\sigmaσ\n抽象地讲，就是A给B发消息，A却不知道B收到的是啥，一般的思路就是A要多发一些消息然后让B去选择有需要的，如果是这样的话，同时还应该保证B不会多知道他本不应该知道的消息。\n增强型陷门排列（enhanced trapdoor permutations）：一种特殊的双射函数，随机取样的函数很难在随机取样值上反转，然而存在一个陷门，可以在给定情况下有效反转。\n陷门排列集合是{fα}α\\{f_\\alpha\\}_\\alpha{fα​}α​的集合，包括四个概率多项式函数I,S,F,F−1I,S,F,F^{-1}I,S,F,F−1\nI(1n)I(1^n)I(1n)：随机选取n比特下标为α\\alphaα的排列fαf_\\alphafα​\nI(1n)I(1^n)I(1n) selects a random n-bit index α\\alphaα of a permutation fαf_\\alphafα​ along with a corresponding trap door τ\\tauτ. Denote by I1(1n)I_1(1^n)I1​(1n) the α\\alphaα-part of the output.\nS(α)S(\\alpha)S(α)：随机采样S(α;r)S(\\alpha;r)S(α;r)\nF(α,x)=fα(x)F(\\alpha,x)=f_\\alpha(x)F(α,x)=fα​(x)\nF−1(τ,y)=fα−1(y)F^{-1}(\\tau,y)=f_\\alpha^{-1}(y)F−1(τ,y)=fα−1​(y)\n加强陷门排列：\nPr[A(1n,α,r)=fα−1(S(α;r))]≤μ(n)Pr[\\mathcal{A}(1^n,\\alpha,r)=f_\\alpha^{-1}(S(\\alpha;r))]\\le \\mu(n)\nPr[A(1n,α,r)=fα−1​(S(α;r))]≤μ(n)\n敌手A\\mathcal{A}A将拥有α,r\\alpha,rα,r，可以计算y=S(α;r)y=S(\\alpha;r)y=S(α;r)，其主要目的是反转yyy\n硬核谓词BBB\nPr[A(1n,α,r)=B(α,fα−1(S(α;r)))]≤12+μ(n)Pr[\\mathcal{A}(1^n,\\alpha,r)=B(\\alpha,f_\\alpha^{-1}(S(\\alpha;r)))]\\le \\frac{1}{2}+\\mu(n)\nPr[A(1n,α,r)=B(α,fα−1​(S(α;r)))]≤21​+μ(n)\n前一个公式表示敌手逆转的可能微乎其微，后一个公式表示敌手逆转后，判断自己的结果是否正确与猜测（12\\frac{1}{2}21​）无异\nThen, the family is a collection of enhanced trapdoor permutations if for every non-uniform probabilistic polynomial time adversary A\\mathcal{A}A there exists a negligible function μ\\muμ such that for every nnn\nPr[A(1n,α,r)=fα−1(S(α;r))]≤μ(n)Pr[\\mathcal{A}(1^n,\\alpha,r)=f_\\alpha^{-1}(S(\\alpha;r))]\\le \\mu(n)Pr[A(1n,α,r)=fα−1​(S(α;r))]≤μ(n)\nwhere α←I1(1n)\\alpha \\leftarrow I_1(1^n)α←I1​(1n) and r∈R{0,1}nr\\in_R\\{0,1\\}^nr∈R​{0,1}n is random. Observe that given α\\alphaα and rrr, A can compute y=S(α,r)y=S(\\alpha,r)y=S(α,r). Thus, A\\mathcal{A}A’s task is to invert yyy, when it is also given the random coins used by SSS to sample yyy.\nWe will also refer to a hard-core predicate BBB of a family of enhanced trapdoor permutations. We say that BBB is a hard-core predicate of (I,S,F,F−1)(I,S,F,F^{-1})(I,S,F,F−1) if for every non-uniform probabilistic-polynomial time adversary A\\mathcal{A}A there exists a negligible function μ\\muμ such that for every nnn:\nPr[A(1n,α,r)=B(α,fα−1(S(α;r)))]≤12+μ(n)Pr[\\mathcal{A}(1^n,\\alpha,r)=B(\\alpha,f_\\alpha^{-1}(S(\\alpha;r)))]\\le \\frac{1}{2}+\\mu(n)Pr[A(1n,α,r)=B(α,fα−1​(S(α;r)))]≤21​+μ(n)\n所谓的predicate，就是一个值域为{0,1}\\{0,1\\}{0,1}的函数\n不经意传输的步骤：\nInputs:P1:b0,b1∈{0,1};P2:σ∈{0,1},(I,S,F,F−1)P_1:b_0,b_1\\in\\{0,1\\};P_2:\\sigma \\in\\{0,1\\},(I,S,F,F^{-1})P1​:b0​,b1​∈{0,1};P2​:σ∈{0,1},(I,S,F,F−1)\nProtocol:\n\nP1P_1P1​运行I(1n)I(1^n)I(1n)得到(α,τ)(\\alpha,\\tau)(α,τ)，把α\\alphaα发送给P2P_2P2​\nP2P_2P2​运行S(α)S(\\alpha)S(α)两次，得到xσ,y1−σx_\\sigma,y_{1-\\sigma}xσ​,y1−σ​，计算yσ=F(α,xσ)=fα(xσ)y_\\sigma=F(\\alpha,x_\\sigma)=f_{\\alpha}(x_\\sigma)yσ​=F(α,xσ​)=fα​(xσ​)，发送y0,y1y_0,y_1y0​,y1​给P1P_1P1​\nP1P_1P1​计算x0=F−1(α,y0)=fα−1(y0),x1=F−1(α,y1)=fα−1(y1)x_0=F^{-1}(\\alpha,y_0)=f_{\\alpha}^{-1}(y_0),x_1=F^{-1}(\\alpha,y_1)=f_\\alpha^{-1}(y_1)x0​=F−1(α,y0​)=fα−1​(y0​),x1​=F−1(α,y1​)=fα−1​(y1​)\n\n计算掩码β0=B(α,x0)⊕b0,β1=B(α,x1)⊕b1\\beta_0=B(\\alpha,x_0)\\oplus b_0,\\beta_1=B(\\alpha,x_1)\\oplus b_1β0​=B(α,x0​)⊕b0​,β1​=B(α,x1​)⊕b1​\nP1P_1P1​发送(β0,β1)(\\beta_0,\\beta_1)(β0​,β1​)给P2P_2P2​\n\nP2P_2P2​计算bσ=B(α,xσ)⊕βσb_\\sigma=B(\\alpha,x_\\sigma)\\oplus\\beta_\\sigmabσ​=B(α,xσ​)⊕βσ​\n\nTheorem\nAssume that (I,S,F,F−1)(I,S,F,F^{-1})(I,S,F,F−1) constitutes a family of enhanced trapdoor permutations with a hard-core predicate BBB. Then, Protocol  securely computes the functionality f((b0,b1),σ)=(λ,bσ)f((b_0,b_1),σ) = (λ,b_σ)f((b0​,b1​),σ)=(λ,bσ​) in the presence of static semi-honest adversaries.\nProof\n模拟器：S1,S2S_1,S_2S1​,S2​\n首先考虑 P1 被破坏的情况。\nP1P_1P1​没有输出，因此我们只需要证明模拟器可以生成P1P_1P1​收到的传入信息的视图。协议中，P1P_1P1​输入(y0,y1)(y_0,y_1)(y0​,y1​)，S1S_1S1​输入(b0,b1,1n)(b_0,b_1,1^n)(b0​,b1​,1n)并按照以下步骤工作：\n\nS1S_1S1​为P1P_1P1​选择一个均匀分布的随机磁带rrr（比特序列）\nS1S_1S1​运行(α,τ)←I(1n;r)(\\alpha,\\tau)\\leftarrow I(1^n;r)(α,τ)←I(1n;r)\nS1S_1S1​运行S(α)S(\\alpha)S(α)两次，采样值分别为y0,1y_0,_1y0​,1​\nS1S_1S1​输出((b0,b1),r;(y0,y1))((b_0,b_1),r;(y_0,y_1))((b0​,b1​),r;(y0​,y1​))\n\n由于S1S_1S1​不知道P2P_2P2​的输入σ\\sigmaσ，因此无法像诚实的P2P_2P2​那样对y0,y1y_0,y_1y0​,y1​进行采样。尽管如此，根据陷阱门排列集合的定义，S(α)S(\\alpha)S(α)输出的值几乎均匀分布在f(α)f(\\alpha)f(α)的域（域等于范围，因为它是排列）中。根据定义，F(α,S(α))F(α,S(α))F(α,S(α)) 的分布在统计上接近于 S(α)S(α)S(α) 的分布。这意味着：\n(F(α,x0),y1)≡c(y0,y1)≡c(y0,F(α,x1)){(F(\\alpha,x_0),y_1)}\\stackrel{c}{\\equiv}{(y_0,y_1)}\\stackrel{c}{\\equiv}{(y_0,F(\\alpha,x_1))}\n(F(α,x0​),y1​)≡c(y0​,y1​)≡c(y0​,F(α,x1​))\n其中 a∈Ia \\in Ia∈I，x0,x1,y0,y1x_0,x_1,y_0,y_1x0​,x1​,y0​,y1​都是S(α)S(\\alpha)S(α)的采样\n当P2P_2P2​的输入为σ=0\\sigma = 0σ=0时，P1P_1P1​看到的正是一对(F(α,x0),y1)(F(\\alpha,x_0),y_1)(F(α,x0​),y1​)\n(y0,y1)(y_0,y_1)(y0​,y1​)是模拟器生成的视图\n当P2P_2P2​的输入为σ=1\\sigma = 1σ=1时，P1P_1P1​看到的正是一对(y0,F(α,x1))(y_0,F(\\alpha,x_1))(y0​,F(α,x1​))\n因此，对于每一个σ∈{0,1}\\sigma \\in \\{0,1\\}σ∈{0,1}\n{S1(1n,(b0,b1))}≡c{view1π((b0,b1),σ)}\\{S_1(1^n,(b_0,b_1))\\}\\stackrel{c}{\\equiv}\\{view_1^\\pi((b_0,b_1),\\sigma)\\}\n{S1​(1n,(b0​,b1​))}≡c{view1π​((b0​,b1​),σ)}\n接下来，我们讨论P2P_2P2​被破坏的情况。\n我们需要构建一个视图，使该视图定义的输出等同于协议的真实输出。S2S_2S2​接收P2P_2P2​的输入和输出，因此能够实现上述功能。在本协议中，实现这一点的方法是让 S2 设置βσ=B(α,xσ)⊕bσ\\beta_\\sigma=B(\\alpha,x_\\sigma)\\oplus b_\\sigmaβσ​=B(α,xσ​)⊕bσ​，就像真正的P1P_1P1​一样。相比之下，S2S_2S2​无法正确计算 β1−σ\\beta_{1-\\sigma}β1−σ​\nS2S_2S2​的输入包括1n1^n1n和P2P_2P2​的输入和输出(σ,bσ)(\\sigma,b_\\sigma)(σ,bσ​)\n\n为保证随机性，S2S_2S2​ 运行S(α)S(\\alpha)S(α)两次\nS2S_2S2​运行I(1n)I(1^n)I(1n)得到(α,τ)(\\alpha,\\tau)(α,τ)\nS2S_2S2​计算sσ=S(α;rσ),y1−σ=S(α;r1−σ),x1−σ=F−1(τ,y1−σ)s_\\sigma=S(\\alpha;r_\\sigma),y_{1-\\sigma}=S(\\alpha;r_{1-\\sigma}),x_{1-\\sigma}=F^{-1}(\\tau,y_{1-\\sigma})sσ​=S(α;rσ​),y1−σ​=S(α;r1−σ​),x1−σ​=F−1(τ,y1−σ​)\nS2S_2S2​计算βσ=B(α,xσ)⊕bσ\\beta_\\sigma=B(\\alpha,x_\\sigma)\\oplus b_\\sigmaβσ​=B(α,xσ​)⊕bσ​，其中bσb_\\sigmabσ​来自于P2P_2P2​的输出\nS2S_2S2​计算β1−σ=B(α,x1−σ)\\beta_{1-\\sigma}=B(\\alpha,x_{1-\\sigma})β1−σ​=B(α,x1−σ​)\nS2S_2S2​输出(σ,r0,r1;α,(β0,β1))(\\sigma,r_0,r_1;\\alpha,(\\beta_0,\\beta_1))(σ,r0​,r1​;α,(β0​,β1​))\n\n如果把σ\\sigmaσ放在第一位，那么P2P_2P2​的视图可以写作：\nview2π((b0,b1),σ)=(σ,r0,r1;α,(B(α,x1−σ)⊕b1−σ))view_2^\\pi((b_0,b_1),\\sigma)= (\\sigma,r_0,r_1;\\alpha,(B(\\alpha,x_{1-\\sigma})\\oplus b_{1-\\sigma}))\nview2π​((b0​,b1​),σ)=(σ,r0​,r1​;α,(B(α,x1−σ​)⊕b1−σ​))\n模拟器的输出会被写作：\nS2(1n,σ,bσ)=(σ,r0,r1;α,(B(α,xσ)⊕bσ,B(α,x1−σ)))S_2(1^n,\\sigma,b_{\\sigma})=(\\sigma,r_0,r_1;\\alpha,(B(\\alpha,x_\\sigma)\\oplus b_\\sigma,B(\\alpha,x_{1-\\sigma})))\nS2​(1n,σ,bσ​)=(σ,r0​,r1​;α,(B(α,xσ​)⊕bσ​,B(α,x1−σ​)))\n当b1−σ=0b_{1-\\sigma}=0b1−σ​=0时，对于每一个σ,bσ∈{0,1}\\sigma,b_\\sigma \\in\\{0,1\\}σ,bσ​∈{0,1}和每一个nnn：\nS2(1n,σ,bσ)≡{view2π((b0,b1),σ)}S_2(1^n,\\sigma,b_{\\sigma}) \\equiv \\{view_2^\\pi((b_0,b_1),\\sigma)\\}\nS2​(1n,σ,bσ​)≡{view2π​((b0​,b1​),σ)}\n因此，我么们只需要证明在b1−σ=1b_{1-\\sigma}=1b1−σ​=1的情况下，viewviewview是不可区分的，二者的唯一区别在于β1−σ=B(α,x1−σ)\\beta_{1-\\sigma}=B(\\alpha,x_{1-\\sigma})β1−σ​=B(α,x1−σ​), or β1−σ=B(α,x1−σ)⊕1\\beta_{1-\\sigma}=B(\\alpha,x_{1-\\sigma})\\oplus 1β1−σ​=B(α,x1−σ​)⊕1，因此，我们需要证明σ,bσ∈{0,1}\\sigma, b_\\sigma\\in\\{0,1\\}σ,bσ​∈{0,1}：\n{(σ,r0,r1;α,(B(α,xσ)⊕bσ,B(α,x1−σ)))}≡c{(σ,r0,r1;α,(B(α,xσ)⊕bσ,B(α,x1−σ)⊕1))}\\{(\\sigma,r_0,r_1;\\alpha,(B(\\alpha,x_\\sigma)\\oplus b_\\sigma,B(\\alpha,x_{1-\\sigma})))\\} \\stackrel{c}{\\equiv} \\\\\n\\{(\\sigma,r_0,r_1;\\alpha,(B(\\alpha,x_\\sigma)\\oplus b_\\sigma,B(\\alpha,x_{1-\\sigma})\\oplus 1))\\}\n{(σ,r0​,r1​;α,(B(α,xσ​)⊕bσ​,B(α,x1−σ​)))}≡c{(σ,r0​,r1​;α,(B(α,xσ​)⊕bσ​,B(α,x1−σ​)⊕1))}\n这个式子的左边是S2S_2S2​生成的分布，式子的右边是b1−σb_{1-\\sigma}b1−σ​所处的真实世界。\n假设存在一个非统一概率多项式时间区分器DDD、一个多项式p(⋅)p(\\cdot)p(⋅)和一个无穷序列的元组(σ,bσ,n)(\\sigma,b_\\sigma,n)(σ,bσ​,n)，使得\nPr[D(σ,r0,r1;α,(B(α,xσ)⊕bσ,B(α,x1−σ)))=1]−Pr[D(σ,r0,r1;α,(B(α,xσ)⊕bσ,B(α,x1−σ)⊕1))=1]≥1p(n)Pr[D(\\sigma,r_0,r_1;\\alpha,(B(\\alpha,x_\\sigma)\\oplus b_\\sigma,B(\\alpha,x_{1-\\sigma})))=1]\\\\\n-Pr[D(\\sigma,r_0,r_1;\\alpha,(B(\\alpha,x_\\sigma)\\oplus b_\\sigma,B(\\alpha,x_{1-\\sigma})\\oplus 1))=1]\\\\\n\\ge \\frac{1}{p(n)}\nPr[D(σ,r0​,r1​;α,(B(α,xσ​)⊕bσ​,B(α,x1−σ​)))=1]−Pr[D(σ,r0​,r1​;α,(B(α,xσ​)⊕bσ​,B(α,x1−σ​)⊕1))=1]≥p(n)1​\n在不失一般性的前提下，我们假设对于无穷多个nnn，DDD在接收到B(α,x1−σ)B(\\alpha,x_1-\\sigma)B(α,x1​−σ)时输出 1 的概率大于或等于接收到B(α,x1−σ)⊕1B(\\alpha,x_1-\\sigma)\\oplus 1B(α,x1​−σ)⊕1时输出 1 的概率\n我们构建一个算法A\\mathcal{A}A\nA\\mathcal{A}A的输入包括σ,bσ,(1n,α,r)\\sigma,b_\\sigma,(1^n,\\alpha,r)σ,bσ​,(1n,α,r)，其目标是猜出B(α,fα−1(S(α;r)))B(\\alpha,f_\\alpha^{-1}(S(\\alpha;r)))B(α,fα−1​(S(α;r)))\n首先通过设置r1−α=rr_{1-\\alpha}=rr1−α​=r，计算出x1−α=fα−1(S(α;r))x_{1-\\alpha}=f_\\alpha^{-1}(S(\\alpha;r))x1−α​=fα−1​(S(α;r))\n接下来A\\mathcal{A}A选取一个随机值rσr_\\sigmarσ​并且计算xσ=S(α;rσ),βσ=B(α,xσ)⊕bσx_\\sigma=S(\\alpha;r_\\sigma),\\beta_\\sigma=B(\\alpha,x_\\sigma)\\oplus b_\\sigmaxσ​=S(α;rσ​),βσ​=B(α,xσ​)⊕bσ​\n最后A\\mathcal{A}A选取随机值β1−σ\\beta_{1-\\sigma}β1−σ​，输入(σ,r0,r1;α,(βσ,β1−σ))(\\sigma,r_0,r_1;\\alpha,(\\beta_\\sigma,\\beta_{1-\\sigma}))(σ,r0​,r1​;α,(βσ​,β1−σ​))进算法DDD中，并且输出β1−σ\\beta_{1-\\sigma}β1−σ​如果DDD输出1，否则输出1−β1−σ1-\\beta_{1-\\sigma}1−β1−σ​\n观察到，如果A\\mathcal{A}A正确地猜出β1−σ\\beta_{1-\\sigma}β1−σ​，那么就会在DDD上输入(σ,r0,r1;α,(B(α,xσ)⊕bσ,B(α,x1−σ)))(\\sigma,r_0,r_1;\\alpha,(B(\\alpha,x_\\sigma)\\oplus b_\\sigma,B(\\alpha,x_{1-\\sigma})))(σ,r0​,r1​;α,(B(α,xσ​)⊕bσ​,B(α,x1−σ​)))，否则会在DDD上输入(σ,r0,r1;α,(B(α,xσ)⊕bσ,B(α,x1−σ)⊕1))(\\sigma,r_0,r_1;\\alpha,(B(\\alpha,x_\\sigma)\\oplus b_\\sigma,B(\\alpha,x_{1-\\sigma})\\oplus 1))(σ,r0​,r1​;α,(B(α,xσ​)⊕bσ​,B(α,x1−σ​)⊕1))\n因此，如果D\\mathcal{D}D输出1，可以认为A\\mathcal{A}A猜对了β1−σ\\beta_{1-\\sigma}β1−σ​\nAlgorithm A\\mathcal{A}A is given σ,bσ\\sigma,b_\\sigmaσ,bσ​ on its advice tape, and receives (1n,α,r)(1^n,\\alpha,r)(1n,α,r) for input. A\\mathcal{A}A’s aim is to guess B(α,fα−1(S(α;r)))B(\\alpha,f_\\alpha^{-1}(S(\\alpha;r)))B(α,fα−1​(S(α;r))). In order to do this, implicitly and without knowing its actual value,  A\\mathcal{A}A sets x1−α=fα−1(S(α;r))x_{1-\\alpha}=f_\\alpha^{-1}(S(\\alpha;r))x1−α​=fα−1​(S(α;r)) by setting r1−α=rr_{1-\\alpha}=rr1−α​=r (from its input).  Next, algorithm A\\mathcal{A}A chooses a random rσr_\\sigmarσ​, and computes xσ=S(α;rσ),βσ=B(α,xσ)⊕bσx_\\sigma=S(\\alpha;r_\\sigma),\\beta_\\sigma=B(\\alpha,x_\\sigma)\\oplus b_\\sigmaxσ​=S(α;rσ​),βσ​=B(α,xσ​)⊕bσ​. Finally A\\mathcal{A}A chooses a random β1−σ\\beta_{1-\\sigma}β1−σ​, invokes DDD on input (σ,r0,r1;α,(βσ,β1−σ))(\\sigma,r_0,r_1;\\alpha,(\\beta_\\sigma,\\beta_{1-\\sigma}))(σ,r0​,r1​;α,(βσ​,β1−σ​)) and outputs β1−σ\\beta_{1-\\sigma}β1−σ​ if DDD outputs 1, otherwise outputs 1−β1−σ1-\\beta_{1-\\sigma}1−β1−σ​. Observe that if A\\mathcal{A}A correctly guesses β1−σ\\beta_{1-\\sigma}β1−σ​, then it invokes DDD on (σ,r0,r1;α,(B(α,xσ)⊕bσ,B(α,x1−σ))(\\sigma,r_0,r_1;\\alpha,(B(\\alpha,x_\\sigma)\\oplus b_\\sigma,B(\\alpha,x_{1-\\sigma}))(σ,r0​,r1​;α,(B(α,xσ​)⊕bσ​,B(α,x1−σ​)), otherwise it invokes DDD on (σ,r0,r1;α,(B(α,xσ)⊕bσ,B(α,x1−σ)⊕1))(\\sigma,r_0,r_1;\\alpha,(B(\\alpha,x_\\sigma)\\oplus b_\\sigma,B(\\alpha,x_{1-\\sigma})\\oplus 1))(σ,r0​,r1​;α,(B(α,xσ​)⊕bσ​,B(α,x1−σ​)⊕1)) . Thus, if DDD outputs 1, then A\\mathcal{A}A assumes that it guessed β1−σ correctly\n设置x=x1−σx=x_{1-\\sigma}x=x1−σ​，我们有：\nPr[A(1n,α,r)=B(α,x)]=12⋅Pr[A(1n,α,r)=B(α,x)∣β1−σ=B(α,x)]+12⋅Pr[A(1n,α,r)=B(α,x)∣β1−σ≠B(α,x)]=12⋅Pr[D(σ,r0,r1;α,(B(α,xσ)⊕bσ,B(α,x1−σ)))=1]+12⋅Pr[D(σ,r0,r1;α,(B(α,xσ)⊕bσ,B(α,x1−σ)⊕1))=0]=12⋅Pr[D(σ,r0,r1;α,(B(α,xσ)⊕bσ,B(α,x1−σ)))=1]+12⋅(1−Pr[D(σ,r0,r1;α,(B(α,xσ)⊕bσ,B(α,x1−σ)⊕1))=1])=12+12⋅Pr[D(σ,r0,r1;α,(B(α,xσ)⊕bσ,B(α,x1−σ)))=1]−12⋅Pr[D(σ,r0,r1;α,(B(α,xσ)⊕bσ,B(α,x1−σ)⊕1))=1]≥12+12p(n)Pr[\\mathcal{A}(1^n,\\alpha,r)=B(\\alpha,x)] \\\\\n=\\frac{1}{2}\\cdot Pr[\\mathcal{A}(1^n,\\alpha,r)=B(\\alpha,x) | \\beta_{1-\\sigma}=B(\\alpha,x)]\\\\\n+ \\frac{1}{2}\\cdot Pr[\\mathcal{A}(1^n,\\alpha,r)=B(\\alpha,x) | \\beta_{1-\\sigma}\\ne B(\\alpha,x)]\\\\\n=\\frac{1}{2}\\cdot Pr[D(\\sigma,r_0,r_1;\\alpha,(B(\\alpha,x_\\sigma)\\oplus b_\\sigma,B(\\alpha,x_{1-\\sigma})))=1]\\\\\n+ \\frac{1}{2}\\cdot Pr[D(\\sigma,r_0,r_1;\\alpha,(B(\\alpha,x_\\sigma)\\oplus b_\\sigma,B(\\alpha,x_{1-\\sigma})\\oplus 1))=0] \\\\\n= \\frac{1}{2}\\cdot Pr[D(\\sigma,r_0,r_1;\\alpha,(B(\\alpha,x_\\sigma)\\oplus b_\\sigma,B(\\alpha,x_{1-\\sigma})))=1] \\\\\n+ \\frac{1}{2}\\cdot (1-Pr[D(\\sigma,r_0,r_1;\\alpha,(B(\\alpha,x_\\sigma)\\oplus b_\\sigma,B(\\alpha,x_{1-\\sigma})\\oplus 1))=1])\\\\\n=\\frac{1}{2} + \\frac{1}{2}\\cdot Pr[D(\\sigma,r_0,r_1;\\alpha,(B(\\alpha,x_\\sigma)\\oplus b_\\sigma,B(\\alpha,x_{1-\\sigma})))=1]\\\\\n-\\frac{1}{2}\\cdot Pr[D(\\sigma,r_0,r_1;\\alpha,(B(\\alpha,x_\\sigma)\\oplus b_\\sigma,B(\\alpha,x_{1-\\sigma})\\oplus 1))=1]\\\\\n\\ge \\frac{1}{2} + \\frac{1}{2p(n)}\nPr[A(1n,α,r)=B(α,x)]=21​⋅Pr[A(1n,α,r)=B(α,x)∣β1−σ​=B(α,x)]+21​⋅Pr[A(1n,α,r)=B(α,x)∣β1−σ​​=B(α,x)]=21​⋅Pr[D(σ,r0​,r1​;α,(B(α,xσ​)⊕bσ​,B(α,x1−σ​)))=1]+21​⋅Pr[D(σ,r0​,r1​;α,(B(α,xσ​)⊕bσ​,B(α,x1−σ​)⊕1))=0]=21​⋅Pr[D(σ,r0​,r1​;α,(B(α,xσ​)⊕bσ​,B(α,x1−σ​)))=1]+21​⋅(1−Pr[D(σ,r0​,r1​;α,(B(α,xσ​)⊕bσ​,B(α,x1−σ​)⊕1))=1])=21​+21​⋅Pr[D(σ,r0​,r1​;α,(B(α,xσ​)⊕bσ​,B(α,x1−σ​)))=1]−21​⋅Pr[D(σ,r0​,r1​;α,(B(α,xσ​)⊕bσ​,B(α,x1−σ​)⊕1))=1]≥21​+2p(n)1​\n因此，可以说S2S_2S2​的输出与P2P_2P2​在实际执行中的视图在计算上是无差别的。\nDiscussion这个协议是一个很好的例子，说明了在半诚实对手存在的情况下，如果被破坏的一方行为不完全诚实，那么安全性就得不到任何保证。如果P2P_2P2​通过选择x0,x1x_0,x_1x0​,x1​并计算y0=F(α,x0),y1=F(α,x1)y_0 = F(\\alpha,x_0), y_1 = F(\\alpha,x_1)y0​=F(α,x0​),y1​=F(α,x1​)来生成 y0,y1y_0,y_1y0​,y1​，那么它将同时学习到b0,b1b0,b1b0,b1。P1P_1P1​根本无法检测到这一点。\n","categories":["密码学基础"],"tags":["密码学基础"]},{"title":"markdown语法","url":"/posts/f134a8e5.html","content":"\nmarkdown常用数学公式和符号\n如何插入公式：行内公式(此时插入公式需要修改markdown配置文件，打开偏好设置中的内联公式)\n\n$数学公式$\n行间公式\n$$公式xxx$$\n常见公式和符号\n希腊字母\n\n\n\n\n\n\n\n\n\n\n\n显示\n命令\n显示\n命令\n\n\nα\n\\alpha\nβ\n\\beta\n\n\nγ\n\\gamma\nδ\n\\delta\n\n\nε\n\\epsilon\nζ\n\\zeta\n\n\nη\n\\eta\nθ\n\\theta\n\n\nι\n\\iota\nκ\n\\kappa\n\n\nλ\n\\lambda\nμ\n\\mu\n\n\nν\n\\nu\nξ\n\\xi\n\n\nπ\n\\pi\nρ\n\\rho\n\n\nσ\n\\sigma\nτ\n\\tau\n\n\nυ\n\\upsilon\nφ\n\\phi\n\n\nχ\n\\chi\nψ\n\\psi\n\n\nω\n\\omega\n\n\n\n\n\n矩阵\n\npmatrix ：小括号边框\nbmatrix ：中括号边框\nBmatrix ：大括号边框\nvmatrix ：单竖线边框\nVmatrix ：双竖线边框\n横省略号：\\cdots\n竖省略号：\\vdots\n斜省略号：\\ddots\n\n不带括号的矩阵\n$  \\begin&#123;matrix&#125;   1 &amp; 2 &amp; 3 \\\\\\   4 &amp; 5 &amp; 6 \\\\\\   7 &amp; 8 &amp; 9  \\end&#123;matrix&#125;$\n\n  \\begin{matrix}\n   1 &amp; 2 &amp; 3 \\\\\\\n   4 &amp; 5 &amp; 6 \\\\\\\n   7 &amp; 8 &amp; 9\n  \\end{matrix}\n\n带括号{}的矩阵\n$ \\begin&#123;Bmatrix&#125;   1 &amp; 2 &amp; 3 \\\\\\   4 &amp; 5 &amp; 6 \\\\\\   7 &amp; 8 &amp; 9  \\end&#123;Bmatrix&#125;$\n带括号[]的矩阵\n$ \\begin&#123;bmatrix&#125;   1 &amp; 2 &amp; 3 \\\\\\   4 &amp; 5 &amp; 6 \\\\\\   7 &amp; 8 &amp; 9  \\end&#123;bmatrix&#125;$\n带省略号的矩阵\n$\\left[\\begin&#123;matrix&#125; 1      &amp; 2      &amp; \\cdots &amp; 4      \\\\\\ 7      &amp; 6      &amp; \\cdots &amp; 5      \\\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\ 8      &amp; 9      &amp; \\cdots &amp; 0      \\\\\\\\end&#123;matrix&#125;\\right]$\n方程组\n$\\begin&#123;cases&#125;a_1x+b_1y+c_1z=d_1\\\\\\a_2x+b_2y+c_2z=d_2\\\\\\a_3x+b_3y+c_3z=d_3\\\\\\\\end&#123;cases&#125;$\n集合\n属于运算，符号：\\in，如：x∈yx \\in yx∈y\n不属于运算，符号：\\notin，如：x∉yx \\notin yx∈/​y\n不属于运算，符号：\\not\\in，如：x∉yx \\not\\in yx​∈y\n子集运算，符号：\\subset，如：x⊂yx \\subset yx⊂y\n子集运算，符号：\\supset，如：x⊃yx \\supset yx⊃y\n真子集运算，符号：\\subseteq，如：x⊆yx \\subseteq yx⊆y\n非真子集运算，符号：\\subsetneq，如：x⊊yx \\subsetneq yx⊊y\n真子集运算，符号：\\supseteq，如：x⊇yx \\supseteq yx⊇y\n非真子集运算，符号：\\supsetneq，如：x⊋yx \\supsetneq yx⊋y\n非子集运算，符号：\\not\\subset，如：x⊄yx \\not\\subset yx​⊂y\n非子集运算，符号：\\not\\supset，如：x⊅yx \\not\\supset yx​⊃y\n并集运算，符号：\\cup，如：x∪yx \\cup yx∪y\n交集运算，符号：\\cap，如：x∩yx \\cap yx∩y\n差集运算，符号：\\setminus，如：x∖yx \\setminus yx∖y\n同或运算，符号：\\bigodot，如：x⨀yx \\bigodot yx⨀y\n同与运算，符号：\\bigotimes，如：x⨂yx \\bigotimes yx⨂y\n实数集合，符号：\\mathbb&#123;R&#125;，如：\\mathbb&#123;R&#125;\n自然数集合，符号：\\mathbb&#123;Z&#125;，如：\\mathbb&#123;Z&#125;\n空集，符号：\\emptyset，如：∅\\emptyset∅\n数学符号\n无穷，符号：\\infty，如：∞\\infty∞\n虚数，符号：\\imath，如：ı\\imathı\n虚数，符号：\\jmath，如：ȷ\\jmathȷ\n数学符号，符号\\hat&#123;a&#125;，如：a^\\hat{a}a^\n数学符号，符号\\check&#123;a&#125;，如：aˇ\\check{a}aˇ\n数学符号，符号\\breve&#123;a&#125;，如：a˘\\breve{a}a˘\n数学符号，符号\\tilde&#123;a&#125;，如：a~\\tilde{a}a~\n数学符号，符号\\bar&#123;a&#125;，如：aˉ\\bar{a}aˉ\n矢量符号，符号\\vec&#123;a&#125;，如：a⃗\\vec{a}a\n数学符号，符号\\acute&#123;a&#125;，如：aˊ\\acute{a}aˊ\n数学符号，符号\\grave&#123;a&#125;，如：aˋ\\grave{a}aˋ\n数学符号，符号\\mathring&#123;a&#125;，如：a˚\\mathring{a}a˚\n一阶导数符号，符号\\dot&#123;a&#125;，如：a˙\\dot{a}a˙\n二阶导数符号，符号\\ddot&#123;a&#125;，如：a¨\\ddot{a}a¨\n上箭头，符号：\\uparrow，如：↑\\uparrow↑\n上箭头，符号：\\Uparrow，如：⇑\\Uparrow⇑\n下箭头，符号：\\downarrow，如：↓\\downarrow↓\n下箭头，符号：\\Downarrow，如：⇓\\Downarrow⇓\n左箭头，符号：\\leftarrow，如：←\\leftarrow←\n左箭头，符号：\\Leftarrow，如：⇐\\Leftarrow⇐\n右箭头，符号：\\rightarrow，如：→\\rightarrow→\n右箭头，符号：\\Rightarrow，如：⇒\\Rightarrow⇒\n底端对齐的省略号，符号：\\ldots，如：1,2,…,n1,2,\\ldots,n1,2,…,n\n中线对齐的省略号，符号：\\cdots，如：x12+x22+⋯+xn2x_1^2 + x_2^2 + \\cdots + x_n^2x12​+x22​+⋯+xn2​\n竖直对齐的省略号，符号：\\vdots，如：⋮\\vdots⋮\n斜对齐的省略号，符号：\\ddots，如：⋱\\ddots⋱\n","categories":["markdown"],"tags":["markdown"]},{"title":"zkp2","url":"/posts/86ac9353.html","content":"ZKP2-ZK Whiteboard\nWhat is a SANRK\nSNARK: a succinct proof that a certain statrment is true\nmany blockchain applications:\nPrivate Tx on a public blockchain:\n\nTornadao cash, Zcash. IronFish\nPrivate Dapps: Aleo\n\nCompliance:\n\nprivate proofs of solvency and compliance\nZero-knowledge taxes\n\nScalability:\nRollup systems with validity proofs\nCryptographic Background\narithmetic circuits\n\nFix a finite field F={0,...,p−1}F=\\{0,...,p-1\\}F={0,...,p−1} for some prime p&gt;2p &gt; 2p&gt;2\n\nArithmetic circuit: C:Fn→FC:F^n\\rightarrow FC:Fn→F\n\n\ndirected acyclic graph (DAG) where internal nodes are labeled +,−,×+,-,\\times+,−,×\ninputs are labeled 1,x1,...,xn1,x_1,...,x_n1,x1​,...,xn​\n\n\ndefines an n-variate polynomial with an evaluation recipe\n\n\nArgument systems\npublic arithmetic circuit C(x,w)→FC(x,w)\\rightarrow FC(x,w)→F\n"},{"title":"simulationPart2","url":"/posts/313791a0.html","content":"\nHow To Simulate It – A Tutorial on the Simulation Proof Technique-Part2\nSimulating the View of Malicious Adversaries– Zero Knowledge\n零知识仿真考虑的是恶意对手（尤其是恶意验证者），他们的行为可能是任意的，不一定符合协议规范。零知识中没有私人输入或输出，模拟器需要在证明中生成验证者的观点，而不需要考虑输入和输出的额外复杂性。\n恶意的验证者：在零知识证明系统中，确实主要考虑的是恶意的验证者，而不是恶意的证明者。这是因为零知识证明的目标是让证明者向验证者证明某件事情，而不泄露任何额外的信息。因此，系统需要确保即使验证者是恶意的，也无法从证明中获取任何额外的信息。证明者通常被假设为诚实的，因为如果证明者是恶意的，他们可以随意伪造证明，这样整个系统就失去了意义。\n模拟器需要生成验证者在证明中的视图：这句话的意思是，模拟器需要生成一个与验证者在实际证明过程中看到的内容相同的视图。具体来说，模拟器需要生成验证者在与证明者交互时所看到的所有消息和数据，但不依赖于任何实际的秘密信息。这是为了证明即使验证者是恶意的，他们也无法从证明中获取任何额外的信息，因为模拟器可以在没有任何秘密信息的情况下生成相同的视图。\nDefining Zero Knowledge\nNotation\nAAA：概率多项式时间机器\nA(x,y,r)A(x,y,r)A(x,y,r)：机器A在输入xxx，辅助输入yyy和随即磁带rrr上的输出。\nn=∣x∣n=|x|n=∣x∣：语句xxx的长度\noutputB(A(x,y,rA),B(x,y,rB))output_B(A(x,y,r_A),B(x,y,r_B))outputB​(A(x,y,rA​),B(x,y,rB​))：表示乙方在公共输入xxx上与甲方交互执行的输出，其中甲方有辅助输入yyy和随机磁带rAr_ArA​，乙方有辅助输入zzz和随机磁带rBr_BrB​\noutputB(A(x,y),B(x,z)),outputB(A(x,y,Um),B(x,z,Um′))output_B(A(x,y),B(x,z)),output_B(A(x,y,U_m),B(x,z,U_m^\\prime))outputB​(A(x,y),B(x,z)),outputB​(A(x,y,Um​),B(x,z,Um′​))\nmmm：是 A（或B）在大小为∣x∣|x|∣x∣的输入上使用的随机比特数。\nThe definition\n语言LLL的交互式证明系统包括一个证明者PPP和一个验证者VVV，在共同输入xxx时，证明者PPP试图让验证者VVV相信x∈Lx \\in Lx∈L。这样的证明系统具有以下两个特性：\n\n完备性：这说明，当诚实的PPP和VVV就共同输入x∈Lx\\in Lx∈L进行交互时，那么VVV确信x∈Lx\\in Lx∈L这一语句的正确性（但最多可忽略的概率除外）。\n健全性：这说明当VVV在共同输入x∈Lx \\in Lx∈L上与任何（作弊的）证明者PPP交互时，VVV将以最多可忽略的概率被说服。(因此，VVV不可能被骗去接受一个错误的陈述）。\n\n如果存在一个模拟器，可以仅从语句生成验证者的观点，那么这个证明就是零知识。我们要指出的是，被破坏的验证者可以输出任何它想输出的东西，包括它的观点。\n在本文定义中，我们仅考虑黑盒情况和NPNPNP语言情况\nDefinition 5.1 Let (P,V)(P,V)(P,V) be an interactive proof system for an NP−languageLNP-language LNP−languageL, and let RLR_LRL​ be the associated NP−relationNP-relationNP−relation. We say that (P,V)(P,V)(P,V)is black-box computational zero knowledge if there exists a probabilistic-polynomial time oracle machine SSS such that for every non-uniform probabilisticpolynomial time algorithm V∗V^*V∗ it holds that:\n{outputV∗(P(x,w),V∗(x,z))}(x,w)∈RL,z∈{0,1}∗≡c{SV∗(x,z,r,⋅)}(x)x∈L,z∈{0,1}∗\\{output_{V^*}(P(x,w),V^*(x,z))\\}_{(x,w)\\in R_L, z\\in \\{0,1\\}^*}\\stackrel{c}{\\equiv} \\{S^{V^*(x,z,r,\\cdot)} \\}(x)_{x\\in L,z \\in \\{0,1\\}^*}\n{outputV∗​(P(x,w),V∗(x,z))}(x,w)∈RL​,z∈{0,1}∗​≡c{SV∗(x,z,r,⋅)}(x)x∈L,z∈{0,1}∗​\nwhere rrr is uniformly distributed, and where V∗(x,z,r⋅)V^*(x,z,r\\cdot)V∗(x,z,r⋅) denotes the next-message function of the interactive machine V∗V^*V∗ when the common input xxx, auxiliary input zzz and random-tape rrr are fixed (i.e., the next message function of V∗V^*V∗ receives a message history m′m^\\primem′ and outputs V∗(x,z,r,m′))V^∗(x,z,r,m^\\prime))V∗(x,z,r,m′)).\n定义5.1：设 (P,V)(P,V)(P,V) 是一个 NPNPNP 语言 LLL 的交互式证明系统，RLR_LRL​ 是相关的 NPNPNP 关系。如果存在一个概率多项式时间的预言机器 SSS，使得对于每一个非一致的概率多项式时间算法 V∗V^*V∗，都有以下等价关系成立：\n{outputV∗(P(x,w),V∗(x,z))}(x,w)∈RL,z∈{0,1}∗≡c{SV∗(x,z,r,⋅)}(x)x∈L,z∈{0,1}∗\\{output_{V^*}(P(x,w),V^*(x,z))\\}_{(x,w)\\in R_L, z\\in \\{0,1\\}^*}\\stackrel{c}{\\equiv} \\{S^{V^*(x,z,r,\\cdot)} \\}(x)_{x\\in L,z \\in \\{0,1\\}^*}\n{outputV∗​(P(x,w),V∗(x,z))}(x,w)∈RL​,z∈{0,1}∗​≡c{SV∗(x,z,r,⋅)}(x)x∈L,z∈{0,1}∗​\n其中 rrr 是均匀分布的，V∗(x,z,r⋅)V^*(x,z,r\\cdot)V∗(x,z,r⋅) 表示当公共输入 xxx、辅助输入 zzz 和随机带 rrr 固定时，交互式机器 V∗V^*V∗ 的下一条消息函数（即 V∗V^*V∗ 的下一条消息函数接收一个消息历史 m′m^\\primem′ 并输出 V∗(x,z,r,m′)V^∗(x,z,r,m^\\prime)V∗(x,z,r,m′)）。\n这段话的意思是，对于一个 NPNPNP 语言的交互式证明系统 (P,V)(P,V)(P,V)，我们称它为黑盒计算零知识，如果存在一个概率多项式时间的预言机器 SSS，使得对于任何非一致的概率多项式时间算法 V∗V^*V∗，系统的输出与 SSS 机器的输出在计算上是不可区分的。这里的 “不可区分” 指的是，即使有一个强大的对手，也无法有效地区分两个输出集合的差异。\n在这个定义中，PPP 是证明者，VVV 是验证者，V∗V^*V∗ 是一个可能的恶意验证者。xxx 是公共输入，www 是证明者的私有见证，zzz 是辅助输入，rrr 是随机带。预言机器 SSS 被用来模拟证明者 PPP 的行为，以产生一个与实际交互过程中验证者 V∗V^*V∗ 观察到的输出在计算上不可区分的输出。\n简而言之，这个定义说明了一个交互式证明系统是零知识的，如果存在一个模拟器 SSS，它可以在不知道证明者私有见证 www 的情况下，仅仅通过与恶意验证者 V∗V^*V∗ 的交互，生成一个与真实交互过程中 V∗V^*V∗ 观察到的输出在计算上不可区分的输出。这保证了即使验证者尝试作弊，也无法获得关于证明者私有见证的任何信息。\nPreliminaries– Commitment Schemes\nc=Comn(x;r)c=Com_n(x;r)c=Comn​(x;r)：通过使用随机字符串rrr和安全参数nnn对xxx的承诺\nif c=Comn(x;r),decom(c)=(x,r)if\\ c=Com_n(x;r), decom(c)=(x,r)if c=Comn​(x;r),decom(c)=(x,r)\nperfect binding 是一个重要的概念，它确保了一个承诺方案（commitment scheme）的安全性。承诺方案允许一个人承诺一个值而不立即透露它，同时确保该值在未来可以被验证。\nfor all x1≠x2,Cx1∩Cx2,where Cx1={c∣∃r:c=Com(x1;r},Cx2={c∣∃r:c=Com(x2;r}for\\ all\\ x_1 \\ne x_2, C_{x_1}\\cap C_{x_2}, where\\ C_{x_1}=\\{c|\\exist r:c=Com(x_1;r\\},C_{x_2}=\\{c|\\exist r:c=Com(x_2;r\\}for all x1​​=x2​,Cx1​​∩Cx2​​,where Cx1​​={c∣∃r:c=Com(x1​;r},Cx2​​={c∣∃r:c=Com(x2​;r}\nComputational hiding对于任何有限计算能力的攻击者来说，对不同字符串的承诺在计算上是无法区分的。换句话说，即使攻击者使用所有可用的计算资源，他们也无法确定承诺是对哪个字符串做出的。\nC0≡cC1,Cb={Com(b;Un}n∈NC_0\\stackrel{c}{\\equiv}C_1, C_b=\\{Com(b;U_n\\}_{n\\in N}C0​≡cC1​,Cb​={Com(b;Un​}n∈N​\nLR-security of commitments\nLR−oracleLR-oracleLR−oracle（Left or Right oracleLeft\\ or\\ Right\\ oracleLeft or Right oracle）的定义是通过向对手提供一个甲骨文来实现的，这个预言机接收两个等长输入，要么总是返回对第一个（左）输入的承诺，要么总是返回对第二个（右）输入的承诺。对手的任务就是确定它收到的是左承诺还是右承诺。\n我们将其定义为\nLRComb(x0,x1)={Com(xb),if∣x0∣=∣x1∣{⊥,otherwiseLR_{Com}^b(x_0,x_1)=\\{Com(x_b), if |x_0|=|x_1|\\\\ \\{\\perp, otherwise\nLRComb​(x0​,x1​)={Com(xb​),if∣x0​∣=∣x1​∣{⊥,otherwise\n其中敌手A\\mathcal{A}A要么被给予LRCom0LR_{Com}^0LRCom0​要么被给予LRCom1LR_{Com}^1LRCom1​并且要尝试能够区分这两个。\nExperiement LR−commitCom,A(1n)LR-commit_{Com,\\mathcal{A}}(1^n)LR−commitCom,A​(1n)\n\nChoose a random b←{0,1}b\\leftarrow \\{0,1\\}b←{0,1}\nSet b′←ALRComb(⋅,⋅)(1n)b^\\prime \\leftarrow \\mathcal{A}^{LR_{Com}^b(\\cdot,\\cdot)}(1^n)b′←ALRComb​(⋅,⋅)(1n)\nOutput 1 if and only b′=bb^\\prime=bb′=b\n\n如果ComComCom是一个非交互式完全约束承诺方案，对非均匀对手具有安全性，那么对于每个非均匀概率-多项式时间对手A\\mathcal{A}A，都存在一个可忽略的函数μ\\muμ，使得\nPr[LR−commitCom,A(1n)=1]≤12+μ(n)Pr[LR-commit_{Com,\\mathcal{A}}(1^n)=1]\\le \\frac{1}{2}+\\mu(n)\nPr[LR−commitCom,A​(1n)=1]≤21​+μ(n)\n我们将在下文中指出，非均匀安全性是必需的。\nNon-Constant Round Zero Knowledge\n考虑零知识证明中的三着色问题和汉密尔顿性。\n这类协议通常包含着三部分：\n\nPPP发送承诺（commitment）\nVVV发送挑战（challenge），并要求PPP打开承诺\nPPP发送合适的回应（decommitment）\n\n考虑三色问题，这类问题要求证明，在一个图GGG中，要求为GGG中每一个顶点涂色，使得相邻两个顶点的颜色不同。证明者承诺一个随机的有效着色，验证者要求打开与一条边相关的颜色。图中必须至少有一条边能为证明者承诺着色的边的两个端点分配相同的颜色。如果验证者要求打开这条边的颜色，那么证明者就会被发现作弊。因此，证明者作弊的概率最多为1∣E∣\\frac{1}{|E|}∣E∣1​，其中EEE是边的合集\n通过重复证明 n⋅∣E∣n\\cdot |E|n⋅∣E∣次（其中nnn是图的个数），我们可以得出证明者作弊的概率最多(1−1∣E∣)n⋅∣E∣&lt;e−n(1-\\frac{1}{|E|})^{n\\cdot |E|} &lt; e^{-n}(1−∣E∣1​)n⋅∣E∣&lt;e−n可以忽略不计。因此，这个证明是正确的。\n对于这个问题的模拟器证明思路，如果模拟器提前知道要查询的边，那么它就可以在该边的端点上随机承诺不同的颜色，而在其他地方承诺垃圾颜色。根据承诺方案的隐藏特性，这将是无法区分的。我们将看到，模拟器只需重复猜测要提前查询的边，直到猜对为止。\nThe rewinding technique (with commitments as envelopes)\n首先，我们将描述如何构建一个模拟器，当我们把承诺建模为完美的信封时，信封在打开之前什么也不会显示。\n构建模拟器的关键工具是重绕（rewind）。\n模拟器调用验证器，并猜测一条随机边e=(vi,vj)∈REe=(v_i,v_j)\\in_R Ee=(vi​,vj​)∈R​E，希望验证器能查询这条边。\n然后，模拟器会向验证者发送着色承诺。\n如果验证者回复边e′=ee^\\prime=ee′=e，那么模拟器就为eee中的节点打开信封，本次迭代的模拟就完成了。否则，模拟器会将验证器倒退到迭代的起点并再次尝试，这次选择一条新的随机边。如此反复，直到e′=ee^\\prime = ee′=e，模拟器就成功了。\n这种倒退不同于一般的倒退，它存在一定的失忆性，也就是不会记录失败的情形，就如同虚拟机的快照功能，可以快速回到某个时刻的某种状态。不失一般性的情况下，模拟器选择边的概率是1∣E∣\\frac{1}{|E|}∣E∣1​，期望次数为∣E∣|E|∣E∣，当执行超过n⋅∣E∣n\\cdot|E|n⋅∣E∣次rewinding后，能够确保模拟器以极大的概率最终通过挑战。\n这种设计下，验证者在模拟中的视图分布与其在实际执行中的视图分布完全相同。两者之间的区别在于，在真实证明中没有rewinding。\n模拟器是如何实现rewind功能的\n具体来说，模拟器可以从Oracle中获取验证者的下一个信息函数V∗(x,z,r,⋅)V^*(x,z,r,\\cdot)V∗(x,z,r,⋅)。这意味着，它提供了一份传入信息的副本m⃗=(m1,m2,...)\\vec{m}=(m_1,m_2,...)m=(m1​,m2​,...)，并在V∗V^*V∗具有输入xxx、辅助输入zzz、随机磁带rrr和传入信息m⃗\\vec{m}m时，接收回发送的下一条信息。现在，倒带实质上就是SSS用(r,(m1,m2,m3))(r,(m_1,m_2,m_3))(r,(m1​,m2​,m3​))调用其甲骨文，然后再用(r,(m1,m2,m⃗))(r,(m_1,m_2,\\vec{m}))(r,(m1​,m2​,m))调用，以此类推。\n零知识属性与健全性不矛盾\n模拟器可以在不知道证明者的情况下证明定理，作弊者不可以，因为模拟器拥有证明者所不具备的额外能力，rewind。\n上述承诺模型过于简单，我们还需要证明：\n首先，必须证明验证者的视图在模拟和实际执行中是不可分的。\n需要证明模拟在n∣E∣n|E|n∣E∣次尝试内成功停止，除非概率可以忽略不计。\n关于中止情况的处理\n在模拟阶段，如果V∗V^*V∗没有返回某条有效的边，可以让真正的验证者将任何无效回复解释为默认边。\nTheorem：Let ComComCom be a perfectly-binding commitment scheme with security for non-uniform adversaries. Then, the 3-coloring protocol of is black-box computational zero knowledgecomputational\\ zero\\ knowledgecomputational zero knowledge.\nProof：\nSSS是一个模拟器，给定一个图G=(V,E),V={v1,...,vn}G=(V,E),V=\\{v_1,...,v_n\\}G=(V,E),V={v1​,...,vn​}，以及对某个个概率多项式时间V∗(x,z,r,⋅)V^*(x,z,r,\\cdot)V∗(x,z,r,⋅)的访问\n工作原理如下：\n1.SSS将消息历史副本m⃗\\vec{m}m初始化为空字符串λ\\lambdaλ\n2.以下步骤重复n⋅∣E∣n\\cdot |E|n⋅∣E∣次\n（a）SSS设置j=1j=1j=1\n（b）SSS随机选择一条边(vk,vl)∈RE(v_k,v_l)\\in_RE(vk​,vl​)∈R​E并给两个点不同颜色。形式上，SSS选择ϕ(k)∈R{1,2,3}\\phi(k)\\in_R\\{1,2,3\\}ϕ(k)∈R​{1,2,3}并且\\phi(v_l)\\in_R\\{1,2,3\\} \\textbackslash {\\phi(v_k)}。对于其余的v_i \\in V \\textbackslash {v_k,v_l}，SSS设置ϕ(vi)=0\\phi(v_i)=0ϕ(vi​)=0\n（c）对于i=1,...,ni=1,...,ni=1,...,n，SSS计算ci=Com(ϕ(vi))c_i=Com(\\phi(v_i))ci​=Com(ϕ(vi​))\n（d）SSS发送(c1,...,cn)(c_1,...,c_n)(c1​,...,cn​)给V∗V^*V∗。形式上，SSS查询与该向量连接的m⃗\\vec{m}m，并让e∈Ee\\in Ee∈E作为回复\n（e）如果e=(vk,vl)e=(v_k,v_l)e=(vk​,vl​)，那么SSS将承诺(c1,...,cn)(c_1,...,c_n)(c1​,...,cn​)和(decom(ck),decom(cl))(decom(c_k),decom(c_l))(decom(ck​),decom(cl​))发送给m⃗\\vec{m}m。形式上，SSS更新字符串m⃗←(m⃗,(c1,...,cn),(decom(ck),decom(cl)))\\vec{m}\\leftarrow (\\vec{m},(c_1,...,c_n),(decom(c_k),decom(c_l)))m←(m,(c1​,...,cn​),(decom(ck​),decom(cl​)))\n（f）如果e≠(vk,vl)e \\ne (v_k,v_l)e​=(vk​,vl​)，那么SSS设置j←j+1j \\leftarrow j+1j←j+1。如果j=n⋅∣E∣j = n\\cdot |E|j=n⋅∣E∣，则SSS输出失败符号⊥\\perp⊥，否则返回第2b步。\n3.SSS输出V∗V^*V∗的任何结果。\n为了证明模拟器SSS，我们构建一个新的模拟器S′S^\\primeS′，它每次都知道正确的着色方法。\n我们强调S′S^\\primeS′并不是一个有效的模拟器，因为它得到的是ϕ\\phiϕ。相反，它是用于证明的思想实验。\n现在，S′S^\\primeS′的工作方式与SSS完全相同，只是在每次迭代中，它都会在{1,2,3}\\{1,2,3\\}{1,2,3}上随机选择一个置换π\\piπ，设置ϕ(v)=π(ϕ(v))\\phi(v) = \\pi(\\phi(v))ϕ(v)=π(ϕ(v))，并对所有iii计算ci=Com(ϕ(vi))c_i = Com(\\phi(v_i))ci​=Com(ϕ(vi​))，这与真正的证明者完全相同。\n我们要首先证明，模拟器S′S^\\primeS′和V∗V^*V∗的输出是一致的，即对于每个V∗,(G,ϕ)∈RL,z∈{0,1}∗V^*,(G,\\phi)\\in R_L,z\\in \\{0,1\\}^*V∗,(G,ϕ)∈RL​,z∈{0,1}∗：\n{outputV∗(P(G,ϕ),V∗(G,z))}≡{S′V∗{G,z,r,⋅}(G,ϕ)∣S′V∗{G,z,r,⋅}(G,ϕ)≠⊥}\\{output_{V^*}(P(G,\\phi),V^*(G,z))\\}\\equiv \\{S^{\\prime V^*\\{G,z,r,\\cdot\\}}(G,\\phi)|S^{\\prime V^*\\{G,z,r,\\cdot\\}} (G,\\phi)\\ne \\perp\\}\n{outputV∗​(P(G,ϕ),V∗(G,z))}≡{S′V∗{G,z,r,⋅}(G,ϕ)∣S′V∗{G,z,r,⋅}(G,ϕ)​=⊥}\n由于二者都是对有效着色的随机排列的承诺，因此两者的分布是相同的。唯一不同的是，S′S^\\primeS′提前选择了一条边eee，并且只有当V′V^\\primeV′发送的查询等与eee时才结束迭代。\n接下来证明，S′S^\\primeS′最多以可忽略的概率输出⊥\\perp⊥。在一次循环中，n⋅∣E∣n\\cdot |E|n⋅∣E∣次都没选中eee的概率是\n(1−1∣E∣)n⋅∣E∣&lt;e−n(1-\\frac{1}{|E|})^{n\\cdot |E|} &lt; e^{-n}(1−∣E∣1​)n⋅∣E∣&lt;e−n，对于n⋅∣E∣n\\cdot|E|n⋅∣E∣轮循环中，概率不会超过n⋅∣E∣⋅e−nn\\cdot|E|\\cdot e^{-n}n⋅∣E∣⋅e−n，也就满足\n{S′V∗(G,z,r,⋅)(G,ϕ)∣S′V∗(G,z,r,⋅)(G,ϕ)≠⊥}≡{S′V∗(G,z,r,⋅)(G,ϕ)}\\{S^{\\prime V^*(G,z,r,\\cdot)}(G,\\phi)|S^{\\prime V^*(G,z,r,\\cdot)}(G,\\phi)\\ne \\perp\\}\\equiv \\{S^{\\prime V^*(G,z,r,\\cdot)}(G,\\phi)\\}\n{S′V∗(G,z,r,⋅)(G,ϕ)∣S′V∗(G,z,r,⋅)(G,ϕ)​=⊥}≡{S′V∗(G,z,r,⋅)(G,ϕ)}\n最终，我们得到SSS和S′S^\\primeS′是不可区分的：\n{S′V∗(G,z,r,⋅)(G,ϕ)}≡c{SV∗(G,z,r,⋅)(G,ϕ)}\\{S^{\\prime V^*(G,z,r,\\cdot)}(G,\\phi)\\} \\stackrel{c}{\\equiv} \\{S^{ V^*(G,z,r,\\cdot)}(G,\\phi)\\}\n{S′V∗(G,z,r,⋅)(G,ϕ)}≡c{SV∗(G,z,r,⋅)(G,ϕ)}\n假设存在一个概率多项式时间验证器V∗V^*V∗、一个概率多项式时间区分器DDD和一个多项式p(⋅)p(\\cdot)p(⋅)，对于一个无限序列(G,ϕ,z),(G,ϕ)∈R,z∈{0,1}∗(G,\\phi,z),(G,\\phi)\\in R,z\\in\\{0,1\\}^*(G,ϕ,z),(G,ϕ)∈R,z∈{0,1}∗\n∣Pr[D(G,ϕ,z,S′V∗(G,z,r,⋅)(G,ϕ))=1]−Pr[D(G,ϕ,z,SV∗(G,z,r,⋅)(G,ϕ))=1]∣≥1p(n)|Pr[D(G,\\phi,z,S^{\\prime V^*(G,z,r,\\cdot)}(G,\\phi))=1]-Pr[D(G,\\phi,z,S^{ V^*(G,z,r,\\cdot)}(G,\\phi))=1]| \\ge \\frac{1}{p(n)}\n∣Pr[D(G,ϕ,z,S′V∗(G,z,r,⋅)(G,ϕ))=1]−Pr[D(G,ϕ,z,SV∗(G,z,r,⋅)(G,ϕ))=1]∣≥p(n)1​\n我们利用LR−commitLR-commitLR−commit实验作为证明方法，攻击者A\\mathcal{A}A接收(G,ϕ,z)(G,\\phi,z)(G,ϕ,z)作为辅助输入\n1.A\\mathcal{A}A输入G,z,rG,z,rG,z,r，初始化V∗V^*V∗\n2.然后A\\mathcal{A}A输入(G,ϕ),V∗(x,z,r;⋅)(G,\\phi),V^*(x,z,r;\\cdot)(G,ϕ),V∗(x,z,r;⋅)，但算法A\\mathcal{A}A需要一些改动\n（1）对于随机选择的边e=(vk,vl)e=(v_k,v_l)e=(vk​,vl​)，生成承诺ck=Com(ϕ(vk)),cl=Com(ϕ(vl))c_k=Com(\\phi(v_k)),c_l=Com(\\phi(v_l))ck​=Com(ϕ(vk​)),cl​=Com(ϕ(vl​))\n（2）对于其他的所有点，攻击者以(0,ϕ(i))(0,\\phi(i))(0,ϕ(i))来询问LR−oracleLR-oracleLR−oracle，用cic_ici​作为返回值\n3.当算法S′S^\\primeS′结束后，算法A\\mathcal{A}A调用区分器DDD并把S′S^\\primeS′的输出作为区分器的输入，区分器输出什么，算法A\\mathcal{A}A输出什么\n此时我们发现，当LR−oracleLR-oracleLR−oracle随机选择bit是1的时候，承诺与S′S^\\primeS′相同，0的时候，与SSS相同。\nPr[LR−commitCom,A(1n)=1∣b=1]=Pr[D(G,z,S′V∗(G,z,r,⋅)(G,ϕ))=1]Pr[LR-commit_{Com,\\mathcal{A}}(1^n)=1|b=1]=Pr[D(G,z,S^{\\prime V^*(G,z,r,\\cdot)}(G,\\phi))=1]\nPr[LR−commitCom,A​(1n)=1∣b=1]=Pr[D(G,z,S′V∗(G,z,r,⋅)(G,ϕ))=1]\nPr[LR−commitCom,A(1n)=1∣b=0]=Pr[D(G,z,S′V∗(G,z,r,⋅)(G,ϕ))=0]Pr[LR-commit_{Com,\\mathcal{A}}(1^n)=1|b=0]=Pr[D(G,z,S^{\\prime V^*(G,z,r,\\cdot)}(G,\\phi))=0]\nPr[LR−commitCom,A​(1n)=1∣b=0]=Pr[D(G,z,S′V∗(G,z,r,⋅)(G,ϕ))=0]\n于是我们有：\nPr[LR−commitCom,A(1n)=1]≥12+12p(n)Pr[LR-commit_{Com,\\mathcal{A}}(1^n)=1]\\ge \\frac{1}{2}+\\frac{1}{2p(n)}\nPr[LR−commitCom,A​(1n)=1]≥21​+2p(n)1​\n最终，我们得到：\n{outputV∗P(G,ϕ),V∗(G,z)}≡c{SV∗(G,z,r,⋅)(G)}\\{output_{V^*}P(G,\\phi),V^*(G,z)\\} \\stackrel{c}{\\equiv} \\{S^{V*(G,z,r,\\cdot)}(G)\\}\n{outputV∗​P(G,ϕ),V∗(G,z)}≡c{SV∗(G,z,r,⋅)(G)}\n关于证明技巧的讨论。\n首先够造模拟器，然后找到模拟器与现实证明者之间的区别，如果这些区别能够一次证明不可区分，那就一步即可证明，如果不能的话，就将这些区别划分成多个能够证明的不可区分。然后逐步调整不同点，从模拟器到真实情况一点一点地变换过去。这种技术也被称为混合论证（hybrid argument）。除了模拟证明以外，还有一种经典的证明方式是游戏证明（game-based proof）。模拟证明与游戏证明的区别在于，模拟证明是从先构造模拟器，然后从理想情况一点点转移到真实情况中，而游戏证明是从真实情况一点点转移到一个理想的情况中。\nConstant-Round Zero-Knowledge\n我们将三着色问题进行修改，将其变成一个常数轮的协议。\n当我们简单地考虑并行运行n⋅∣E∣n\\cdot |E|n⋅∣E∣轮协议的时候，但我们根本无法证明这仍然是零知识。\n当并行时，证明者一次性发送n⋅∣E∣n\\cdot |E|n⋅∣E∣份承诺，验证者一次性向证明者发送n⋅∣E∣n\\cdot |E|n⋅∣E∣条随机的边，但此时rewind不再适用，在并行下，模拟器一次想要猜对的概率是∣E∣−n∣E∣|E|^{-n|E|}∣E∣−n∣E∣。因此，对于这种没有合适的证明方法的方案，可以通过修改协议来使得能够证明成功。这也是一种设计密码学方案的小技巧，有的时候可以通过一些小改变来使得一个方案满足可证明安全。\n修改后的协议具体细节如下：\n1.证明者选定相关perfectly-hiding承诺的信息并发送给验证者，用ComhCom_hComh​表示\n2.VVV选择N=n⋅∣E∣N=n\\cdot |E|N=n⋅∣E∣条随机的边，e1,...,eN∈REe_1,...,e_N\\in_REe1​,...,eN​∈R​E，q=(e1,...,eN)q=(e_1,...,e_N)q=(e1​,...,eN​)是query字符串，VVV用ComhCom_hComh​来隐藏qqq\n3.PPP准备NNN份像非常数论的协议的承诺，ComComCom发送给PPP\n4.VVVdecommit qqq\n5.如果验证者的decommit是无效的，那么证明者直接abort。否则证明者对于query的每一条边都decommit。\n6.验证者当且仅当所有的检查都通过的时候，输出1。\n其中值得注意的是，验证者发给证明者的承诺是perfectly hiding的，而证明者发给验证者的承诺是perfectly binding的。\n经过这样修改的协议可以确保验证者在承诺后是无法更改选择的边的，于是模拟器在验证者decommit字符串qqq后就会知道所有挑战值，然后rewind到验证者发完承诺的时候，此时模拟器就相当于提前知道了所有的挑战值，于是模拟器就可以很容易通过挑战了。\n但是除此以外还有一些细节需要说明，也就是对于发生中止的情况要单独考虑进来。首先要考虑的就是验证者在decommit字符串qqq的时候是无效的，所以会发生abort。这存在的问题是，验证者的decommit阶段是在rewind之后，那么可能会出现，验证者第一次decommit是正常的，模拟器也从中获得了所有挑战值，但是在模拟器rewind以后，第二次验证者decommit无效导致模拟器中止。看似这种情况并不会对协议产生影响，但是这样会导致模拟器产生abort的概率与真实情况下产生abort的概率不同（因为模拟器需要两次都通过才能不abort），那么势必会导致产生的分布是可区分的。更糟糕的是，无法像非常数轮那样，即使验证者发送的decommit无效，证明者也继续运行，并将无效的边视为某一条默认的边。因为如果这样做的话，如果验证者decommit无效，模拟器就没有办法准备正确的挑战边，那么一次rewind将无法保证能够顺利通过挑战。因此，解决这个问题的方法是如果第一次abort了，那模拟器就直接abort，如果第一次没abort，那么无论接下来就不去理会验证者发来的commitment是否能够decommit成功（如果decommit不成功就继续循环直到成功），因为此时已经知道了对应的挑战值。\n剩下的需要关注的点在于，verifier使用的commitment scheme是perfectly hiding的，所以最多只能是computationally binding，也就意味着V∗V^*V∗有可能decommit出有效的值q′=qq^\\prime=qq′=q，但此时simulation就失效了。因此需要把这部分情况考虑进来，用归约的方式把这部分证明。\n另一个需要注意的问题在于，模拟器的运行时间可能并不是期望多项式时间的。假设验证者V∗V^*V∗不abort的概率为ϵ\\epsilonϵ，那么我们可以估算出模拟器的运行时间大概为poly(n)⋅(1−ϵ(n)+ϵ(n)⋅1ϵ(n))poly(n)\\cdot(1-\\epsilon(n)+\\epsilon(n)\\cdot\\frac{1}{\\epsilon(n)})poly(n)⋅(1−ϵ(n)+ϵ(n)⋅ϵ(n)1​) ，但实际上需要考虑到commitment并不是perfectly hiding的，所以一旦恶意验证者是可以区分commitment的话，那么验证者可以只要判断收到的是garbage commitment就可以一直abort，令模拟器永远无法通过挑战。所以真正计算运算时间的时候应该把这部分概率考虑进去，即poly(n)⋅(1−ϵ(n)+ϵ(n)⋅1ϵ(n)−μ(n))poly(n)\\cdot(1-\\epsilon(n)+\\epsilon(n)\\cdot\\frac{1}{\\epsilon(n)-\\mu(n)})poly(n)⋅(1−ϵ(n)+ϵ(n)⋅ϵ(n)−μ(n)1​) 。看似这个式子仍然可以满足期望多项式时间，但如果ϵ(n)\\epsilon(n)ϵ(n)的概率值与μ(n)\\mu(n)μ(n)的概率过于接近的话，运行时间将可能会是指数级别的。有关运行时间的问题是一个共性问题，一旦rewind前后的分布是不同的（即使不可区分），而且想要整个模拟继续运行下去需要攻击者达到某种条件（比如，攻击者不能abort），那么就都可能会面临这个问题。\n安全性证明\n令ComhCom_hComh​是一个perfectly-hiding承诺机制， ComComCom是一个perfectly- binding 承诺机制，它们都具有对于non-uniform概率多项式时间攻击者算法下的安全性。那么上述常数轮的协议满足黑盒计算零知识安全性（模拟器的运行时间是期望多项式时间）\n证明：\n我们给出模拟器的构造\n\n\n模拟器SSS调用V∗V^*V∗并选定相关承诺的信息输入进去。\n\n\n模拟器SSS得到验证者V∗V^*V∗的commitmentccc。\n\n\n模拟器SSS发送给V∗V^*V∗garbage commitments然后获得V∗V^*V∗的decommitment输出。\n\n\n如果decommitment是无效的，那么直接中止。否则，把decommited的字符串表示为q=(e1,...en)q=(e_1,...e_n)q=(e1​,...en​)，并执行以下步骤。\n\n\n模拟器 SSS rewind到最开始并获得了commitment ccc （因为 𝑉∗ 的random tape是固定的，所以 ccc 是一样的，那么就能确保 qqq 是一致的）：\n\n\n\n模拟器 SSS 生成 NNN 个承诺向量 c1⃗,...,cN⃗\\vec{c_1},...,\\vec{c_N}c1​​,...,cN​​ 。选择验证者挑战的边设置为不同的着色，其余的着色均是0（garbage值）。模拟器将承诺向量发送给验证者V∗V^*V∗，并得到回复。\n如果 V∗V^*V∗ 没有生成有效的decommitment，那么模拟器 SSS 回退到前一步（用新的随机性）。\n如果 V∗V^*V∗ 生成有效的decommitment但是 q′≠qq^\\prime \\ne qq′​=q ，那么模拟器 SSS 输出ambiguous并中止。\n否则，V∗V^*V∗ 退出循环并进行到下一步。\n\n\n\n模拟器 SSS 向 V∗V^*V∗ 继续发送对应点的decommitment，然后输出 V∗V^*V∗ 的输出。\n\n\n然而目前的模拟器构造还不够，因为还没有解决运行时间超过期望多项式时间的问题。\n","categories":["密码学基础"],"tags":["密码学基础"]},{"title":"zkp入门","url":"/posts/e769b1ef.html","content":"\nZKP入门\n交互式证明是可验证计算概念的核心概念。最重要的是，交互式证明理论为非交互式零知识证明 (NIZK)、简洁非交互式知识论证 (SNARK) 或简洁透明知识论证 (STARK) 奠定了基础。\n简介\n什么是证明系统\n交互式证明系统是一种抽象的机器，它将通过计算建模为双方之间交换信息，分别称为证明者PPP和验证者VVV。\n证明者无所不能，拥有无限的计算资源，但不可信任。\n验证者的计算能力有限。\n验证者和证明者之间会不断发送消息，直到验证者能够验证或伪造某个陈述。\n所有交互式证明系统都具有两个关键属性：\n完整性：当陈述是真实的，诚实的验证者可以通过诚实的证明者确认这一事实。\n健全性：当陈述是错误的，除去可忽略不计的概率，没有恶意的证明者可以欺骗验证者。\n零知识保护隐私\n证明系统的第三个属性：\n**零知识：**如果陈述为真，那么没有任何作弊验证者会了解除此事实之外的任何其他信息。\n零知识的阿里巴巴洞穴：\n有一个洞穴，它的路径一分为二。这两条路径由一扇门连接，这扇门只能用密码打开。一个人叫爱丽丝，想向另一个人鲍勃证明她知道密码，而不会泄露它。为此，双方首先将自己置于洞穴的入口处。然后爱丽丝进入洞穴，沿着两条路径中的一条走——这取决于她自己。鲍勃从入口无法判断爱丽丝选择了哪条路。\n然后鲍勃进入洞穴，跑到岔路口。他选择两条路径中的一条，并称这条路径进入洞穴。爱丽丝的任务是通过这条路径找到鲍勃。如果她成功了，她就离向鲍勃证明她知道秘密单词的目标更近了一步。\n如果 Alice 选择了 Bob 选择的路径，她就不需要密码。只有当她选择相反的路径时，她才必须通过门才能走上正确的路径。这意味着，一个心怀恶意的 Alice（她不知道密码）在一次运行该协议时只能说服 Bob 50%。（这就是为什么 Alice 和 Bob 必须重复执行该协议以降低健全性错误概率的原因。）该协议是一个零知识证明，因为无论 Alice 和 Bob 重复该过程多少次，如果 Alice 知道密码，她将始终遵循 Bob 选择的路径。与此同时，Bob 对秘密一无所知。\n识别方案\n身份识别方案的根本思想是，Alice 知道一些秘密（与她的身份直接相关），并且她向 Bob 证明自己知道这些秘密。为了防止将来有恶意的 Bob 冒充 Alice，协议要求 Bob 不得了解有关 Alice 秘密的任何部分信息。反之亦然。\n正式定义\n我们用图灵机来正式定义这个证明系统。\n交互式图灵机\n交互式图灵机 (ITM) 是一种（确定性）多磁带图灵机。\n磁带包括一盘只读输入磁带、一盘只读随机磁带、一盘读写工作磁带、一盘只写输出磁带、一对通信磁带，以及由单个单元组成的读写切换磁带。一盘通信磁带是只读的，另一盘是只写的。\n输入磁带的内容称为输入，随机磁带的内容称为随机输入，终止时输出磁带的内容称为输出。\n\n两台交互式图灵机\n我们称交互式图灵机M1M_1M1​为证明者PPP，M2M_2M2​为验证者VVV，所使用的语言为LLL。\n正确陈述：(x,w)∈L(x,w)\\in L(x,w)∈L，错误陈述：(x,w)∉L(x,w)\\notin L(x,w)∈/​L\n其中，值xxx是公开的，P,VP,VP,V都知道，参数www（见证）是私有的，只有证明者知道。\n语言LLL被定义为某个有限字母表上的一组字符串，并根据一组特定的规则形成。\n例如Σ={0,1,2,−,=}\\Sigma=\\{0,1,2,-,=\\}Σ={0,1,2,−,=}上的语言LLL具有以下语法：\n\n所有不包含-和=且不以0开头的非空字符串都在LLL\n包含“=”的字符串在LLL中当且仅当存在一个“=”，并且它将L中的两个有效字符串分隔开\n\n交互式证明系统\n一对交互式图灵机(P,V)(P,V)(P,V)被称为语言LLL的交互式证明系统，应当满足以下条件：\n\n完整性：对于语言L,(x,w)L,(x,w)L,(x,w)，证明者PPP能够说服验证者VVV的概率十分大：\n\n∀(x,w)∈L,Pr[&lt;P(x,w).V(x)&gt;=1]≤1−negl\\forall (x,w)\\in L,Pr[&lt;P(x,w).V(x)&gt;=1] \\le 1-negl\n∀(x,w)∈L,Pr[&lt;P(x,w).V(x)&gt;=1]≤1−negl\n\n健全性，对于所有不属于语言L,(x,w)L,(x,w)L,(x,w)，证明者P′P^\\primeP′通过作弊的手段说服验证者VVV的概率可以忽略不计。\n\nforall(x,w)∉L,Pr[&lt;P′(x),V(x)&gt;=1]≤neglforall (x,w)\\notin L, Pr[&lt;P^\\prime(x),V(x)&gt;=1] \\le negl\nforall(x,w)∈/​L,Pr[&lt;P′(x),V(x)&gt;=1]≤negl\n\n特殊健全性，对于L,(x,w)L,(x,w)L,(x,w)，都能在一个多项式时间算法EEE，使得可以从P,VP,VP,V的有效对话中提取出证据www\n\n∀(x,w)∈L,∃E:Pr[E&lt;P(x,w),V(x)&gt;=w]≤1−negl\\forall (x,w)\\in L, \\exist E:Pr[E&lt;P(x,w),V(x)&gt;=w]\\le 1-negl\n∀(x,w)∈L,∃E:Pr[E&lt;P(x,w),V(x)&gt;=w]≤1−negl\n\n零知识：对于L,(x,w)L,(x,w)L,(x,w)，对于所有验证者，都存在一个模拟器SSS，使得没有多项式时间区分器DDD可以区分模拟协议的执行与P,VP,VP,V之间的真实交互的执行。\n\nforall(x,w)∈L,∀V∃S,Pr[D(P(x,w),V(x))=1]−Pr[D(S(x))=]forall (x,w)\\in L, \\forall V \\exist S,Pr[D(P(x,w),V(x))=1]-Pr[D(S(x))=] \nforall(x,w)∈L,∀V∃S,Pr[D(P(x,w),V(x))=1]−Pr[D(S(x))=]\nSchnorr协议\nSchnorr协议有三轮，定义在qqq阶循环群GGG上，生成器ggg，语言L={(x,w):x=gw}L=\\{(x,w):x=g^w\\}L={(x,w):x=gw}\n\nSchnorr协议\nSetting\n\nPPP有秘密输入www和公开输入x=gwx=g^wx=gw\nVVV只有公开输入x=gwx=g^wx=gw\nP,VP,VP,V都有公共参数g,qg,qg,q\n\nProtocol\n\nPPP生成一个随机群元素hhh并且采样一个随机数rrr，然后发送a=gra=g^ra=gr给VVV\nVVV选择一个随机挑战e∈0,...,q−1e\\in {0,...,q-1}e∈0,...,q−1并发送给PPP\nPPP回应挑战z=r+ewz=r+ewz=r+ew\n当且仅当gz=axeg^z=ax^egz=axe，VVV才接收响应。\n\n安全性分析\n完整性\n∀r,e:gz=gx+ew=gzgwe=a\\forall r,e: g^z=g^{x+ew}=g^zg^{we}=a\n∀r,e:gz=gx+ew=gzgwe=a\n","categories":["密码学基础"],"tags":["密码学基础"]},{"title":"一个简单的通信游戏","url":"/posts/f95d038c.html","content":"\n从本文开始，我们将开启密码学的历程。\n\n一个简单的通信游戏\n第一个应用实例\n我们给出密码学的第一个应用实例\n这是个简单的问题，两个朋友Alice和Bob，他们在玩一个叫做抛硬币的游戏。\n如果Alice对Bob说，“你选一面，我抛硬币并告诉你结果”，显然Bob不能同意，因为他不能验证抛硬币的结果。\n为了解决这个问题，便有了这样的想法：\n为此我们先了解一个奇妙函数f(x)f(x)f(x)\n奇妙函数f1) 对任意整数x计算f(x)是容易的，给出f(x)计算x是不可能的2) 不可能找到一对整数(x,y)，满足x!=y且f(x)=f(y)\n在这个基础上，我们可以得到第一个密码协议：\n\n安全性分析\n首先，由于性质2）Alice无法找到两个数x和y，其中一个是奇数另一个是偶数，满足f(x)=f(y)f(x)=f(y)f(x)=f(y)，因此，一旦Alice告诉Bobf(x)f(x)f(x)的值，她就完成了抛硬币的过程。\n其次，由于fff具有性质1），Bob不能判断Alice使用的x是奇数还是偶数，因此他不得不把其猜测真是地给出。\n虽然这个协议听上去十分简单，但它的确是一个合格的密码协议，因为协议中使用了现代密码学的一个基本要素——单向函数。\n密码学的新作用——保证游戏的公平性\n密码学一度曾为政府所独占，军事和外交部门使用它来保密消息。\n\n图一：《模仿游戏》（The Imitation Game）是一部2014年英美合拍的历史剧情片。讲述英国数学家、逻辑学家、密码分析学家和计算机科学家艾伦·图灵在二战中帮助盟军破译纳粹德国的军事密码的真实故事。\n可是今天，密码学除了用于对信息进行保密外，还有一个新的用途：在有大量“玩家”的“游戏”中保证公平性，正如我们刚才讨论过的通信游戏。\n在一个娱乐场所进行判决可能不是一件大不了的事情，因而通过电话掷硬币来做决定只可能被看成是一种取乐的通信游戏。可是，有很多通信“游戏&quot;必须更加认真地对待。随着越来越多的事务处理和电子商务活动在开放的网络中以电子方式开展，我们通信中的许多实例将会涉及各种各样的“游戏&quot;。\n一般来说,这种“游戏”的“玩家&quot;往往彼此物理上相距很远，要依靠不安全的开放网络进行通信。物理距离和缺少安全性组合到一块儿，有助于和/或激励一些“玩家”(甚至一些未受邀请的玩家)以某种聪明的方式挫败游戏规则。违背规则的企图是为了获得某种未授权的优势，例如造成秘密信息的泄露、改变数据而不被发现、伪造证据、责任否认、破坏审计和信任、降低可用性或完全不提供服务等。现代通信在事务处理、商业运作、提供服务(以及很多其他方面，如公司业务、个人信息、军事活动和国家事务的保密)方面的重要性意味着要求不遵守游戏规则的玩家不应该获得任何未授权的优势。\n密码系统和协议的准则\n我们应当从一个基本的问题开始：什么是好的密码系统和协议？\n显然，这个问题不好答，各有各的说法，每个人对于好的定义是不一样的。有说难以计算的，有说不易察觉的。本博客的主要任务就是对这个基本问题给出更深入的答案。\n简单来说它应该有以下特点：\n\n保护的程度与应用需求相符合：不应该去设计过于复杂的密码系统来保护价值不匹配的信息，好的密码系统复杂程度应该刚刚好。\n对安全性的信心要依据所建立的“种系”：对于一个密码协议或系统，攻破它的困难性应该归结于某个困难的数学问题\n实际效率：我们所说的数学问题应该是高效可解的，该问题能在问题规模的多项式时间内可解。\n采用实际的和可用的原型和服务：\n明确性：要明确所需要的所有假定，要明确所提供的确切的安全服务，要明确数学方面的一些特殊情况\n\n\n","categories":["密码学基础"],"tags":["密码学基础"]},{"title":"simulationPart3","url":"/posts/4630a136.html","content":"\nHow To Simulate It – A Tutorial on the Simulation Proof Technique-Part3\nDefining Security for Malicious Adversaries\nMotivation\n相比半诚实敌手下的安全性定义，恶意敌手会更难一些，因为恶意敌手可能会做出任何偏离协议规定的行为，只要求存在一个模拟器，能根据其规定的输入和输出生成被破坏方的视图就足够了。\n但是，相较于之前的敌手，攻击者可能不使用给定的输入去输出，此外，除了要考虑到攻击者会从中获取额外的信息以外，还应当考虑到攻击者对于输出所带来的影响。\n我们在分析协议的安全性时，会将对手在协议中能做的事情与在理想情况下能做的事情进行比较，而理想情况下的协议根据定义是安全的。此外，我们会设计一个不可篡改的可信第三方，各方将其输入发送给该第三方。受信任方计算输入的功能，并向各方返回各自的输出。\n我们假设总是有一方被破坏。\nThe Definition\n理想模型允许理想执行中的对手中止执行或在诚实方未获得输出的情况下获得输出。\n参与方P1,P2P_1,P_2P1​,P2​，敌手A\\mathcal{A}A，函数f:{0,1}∗×{0,1}∗→{0,1}∗×{0,1}∗f:\\{0,1\\}^*\\times \\{0,1\\}^* \\rightarrow \\{0,1\\}^*\\times \\{0,1\\}^*f:{0,1}∗×{0,1}∗→{0,1}∗×{0,1}∗的理想执行如下：\n输入：x(P1),y(P2),z(A)x(P_1),y(P_2),z(\\mathcal{A})x(P1​),y(P2​),z(A)，安全参数1n1^n1n\n向可信方发送输入：诚实参与方PjP_jPj​直接发送既定的输入给可信第三方。恶意参与方PiP_iPi​可能会发送abort（通过发送一个abortiabort_iaborti​的特殊消息）、发送既定的输入、发送等长的其他输入。这个决定由攻击者决定，可能是由PiP_iPi​的输入值和辅助值zzz所影响的。定义发送给可信第三方的输入对为(x′,y′)(x^\\prime,y^\\prime)(x′,y′)。\n提前终止选项：如果可信第三方收到了输入abortiabort_iaborti​，那么可信第三方发送abortiabort_iaborti​给PjP_jPj​并结束执行。\n可信方发送输出给攻击者：此时可信第三方计算得到f1(x′,y′),f2(x′,y′)f_1(x^\\prime,y^\\prime),f_2(x^\\prime,y^\\prime)f1​(x′,y′),f2​(x′,y′)然后发送fi(x′,y′),f_i(x^\\prime,y^\\prime),fi​(x′,y′),给恶意参与方PiP_iPi​\n攻击者命令可信方继续或中止： 攻击者A\\mathcal{A}A发送comtinuecomtinuecomtinue或者abortiabort_iaborti​给可信第三方。如果发送的是continuecontinuecontinue，那么可信第三方把fj(x′.y′)f_j(x^\\prime.y^\\prime)fj​(x′.y′)发送给诚实参与方PjP_jPj​。如果攻击者A\\mathcal{A}A发送的是abortiabort_iaborti​，那么可信第三方发送abortiabort_iaborti​给诚实参与方PjP_jPj​。\n输出：诚实参与方直接输出他从可信第三方中得到的输出值。恶意参与方什么都不输出。攻击者A\\mathcal{A}A根据恶意参与方的既定输入值、攻击者的辅助值、从可信第三方得到的输出fj(x′,y′)f_j(x^\\prime,y^\\prime)fj​(x′,y′)，输出任意的结果。\n因此，一个理想执行的输出表示为IDEALf,A(z)IDEAL_{f,\\mathcal{A}(z)}IDEALf,A(z)​\n在真实模型中的执行中，不存在可信的第三方，对手A\\mathcal{A}A代替被破坏的一方发送所有信息，并且可以遵循任意多项式时间策略。与此相反，诚实的一方遵循协议π\\piπ的指令\n真实协议的执行被记作REALπ,A(z),i(x,y,n)REAL_{\\pi,\\mathcal{A}(z),i}(x,y,n)REALπ,A(z),i​(x,y,n)\n其中，π\\piπ是协议，当 P1 和 P2 都诚实时，两方在分别输入 x 和 y 的情况下执行 π\\piπ 后分别输出 f1(x,y)f_1(x,y)f1​(x,y) 和 f2(x,y)f_2(x,y)f2​(x,y)，安全参数是nnn，辅助输入是zzz\n形式化定义\n令 fff 是一个两方的functionality，令 π\\piπ 是一个两方的协议用于计算fff。如果对于现实模型下的所有的non-uniform概率多项式时间攻击者 A\\mathcal{A}A ，都存在一个对于理想模型下的non-uniform概率多项式时间的攻击者 SSS ，满足对于 i∈{1,2}i \\in \\{1,2\\}i∈{1,2}\n{IDEALf,S(z),i(x,y,n}x,y,z,n≡c{REALπ,A(z),i(x,y,n}x,y,z,n\\{IDEAL_{f,S(z),i}(x,y,n\\}_{x,y,z,n}\\stackrel{c}{\\equiv}\\{REAL_{\\pi,\\mathcal{A}(z),i}(x,y,n\\}_{x,y,z,n}\n{IDEALf,S(z),i​(x,y,n}x,y,z,n​≡c{REALπ,A(z),i​(x,y,n}x,y,z,n​\n其中x,y∈{0,1}∗.∣x∣=∣y∣,z∈{0,1}∗,n∈Nx,y\\in\\{0,1\\}^*.|x|=|y|,z\\in \\{0,1\\}^*,n\\in Nx,y∈{0,1}∗.∣x∣=∣y∣,z∈{0,1}∗,n∈N\n那么则认为协议 π\\piπ 能够securely compute fff with abort in the presence of static malicious adversaries。\n在本教程中，我们只考虑中止的安全性。因此，在后文中，当我们说 “安全地计算 ”时，其意图始终是终止计算。\n请注意，上述式子包含了正确性和隐私性，因为理想分布和真实分布都包含了被破坏方和诚实方的输出。\nModular Sequential Composition\n只要执行是按顺序进行的（即每次执行结束后才开始下一次执行），在顺序组合下安全的协议在多次运行时仍能保持其安全性。\n模块化顺序组合：模块化顺序组合定理表述的基本思想是证明可以设计一个将理想功能作为子程序的协议，然后分析受信任方计算该功能时协议的安全性。\n混合模型：双方运行一个协议π\\piπ，该协议包含对可信方的 “理想调用”，该调用计算一些功能 f1,...,fp(n)f_1,...,f_{p(n)}f1​,...,fp(n)​。这些理想调用只是向可信方发送输入的指令。收到受信任方的输出后，协议π\\piπ继续执行。协议π\\piπ规定，每iii次调用fif_ifi​之前都要调用fi+1f_{i+1}fi+1​。诚实方在同一轮中向可信方发送其输入，在收到其输出之前不会发送其他信息。\n协议π\\piπ的hybrid执行被记作\nHYBRIDπ,A(z),if1,...,fp(n)(x,y,n)HYBRID_{\\pi,\\mathcal{A}(z),i}^{f_1,...,f_{p(n)}}(x,y,n)HYBRIDπ,A(z),if1​,...,fp(n)​​(x,y,n)\n其中，x，y是输入，x是辅助输入\n设p(n)p(n)p(n)为多项式，设f1、...、fp(n)f_1、...、f_{p(n)}f1​、...、fp(n)​为双方概率多项式时间功能，设ρ\\rhoρ为协议，使得每个ρi\\rho_iρi​都能在存在恶意对手的情况下安全地计算fif_ifi​。让ggg是一个双方功能，让π\\piπ是一个在f1,...,fp(n)f_1,...,f_{p(n)}f1​,...,fp(n)​混合模型中，在存在恶意对手的情况下安全计算ggg的协议。那么，πρ1,...,ρp(n)\\pi_{\\rho_1,...,\\rho_{p(n)}}πρ1​,...,ρp(n)​​就能在存在恶意对手的情况下安全地计算 ggg。\nAdvanced Topics\nComposition and Universal Composability\n在现实世界中，许多安全和不安全的协议都是并发运行的，因此我们希望在这种情况下也能保证安全性。最流行的定义是通用可组合性（UC）\n这个定义扩展了之前的定义，增加了一个环境机，它本质上是一个交互式区分器。环境机将输入写入各方的输入磁带，并读取它们的输出。此外，在整个执行过程中，它还与对手进行外部交互。环境的 “目标 ”是区分真实协议执行和理想执行。这一定义的一个非常重要的缺陷是，模拟器不能再在模拟中倒退对手。这是因为真正的对手实际上什么也做不了，只能执行环境的指令。现在，由于环境是真实对手和理想对手相互作用的外部机器，这意味着模拟器必须为外部对手进行模拟。由此可见，如果没有一个诚实的多数人，就不可能在没有任何可信设置的情况下安全地计算 UC 框架中的一大类功能。\n一般 UC 框架相当复杂，因为它几乎可以为任何任务和任何环境建模。\nProofs in the Random Oracle Model\n在许多情况下，随机Oracle模型被用来获得更高的效率或其他无法获得的特性。其中一个问题是，区分者是否能获得随机Oracle，如果能，又是如何获得的。在 UC 框架中，随机Oracle可以建模为计算随机函数的理想功能。\nAdaptive Security\n在本教程中，我们只考虑了静态对手的情况，即被破坏方的子集在协议执行开始前就已固定。与此相反，自适应对手可以根据所查看的信息，在整个协议过程中选择破坏哪一方。\n对于适应性对手的情况，人们主要考虑了两种模型。第一种模式假定各方无法安全地删除数据，这被称为无删除模式。因此，一旦数据被擦除，敌方就会获得对方的全部信息–其输入、随机磁带和传入信息。\n自适应安全性的一个较弱模型是假定各方可以安全地擦除数据；这被称为擦除模型。在这种情况下，各方有可能擦除部分数据。这使得模拟更容易，因为不需要生成整个视图，而只需要生成当前状态。\n","categories":["密码学基础"],"tags":["密码学基础"]},{"title":"公钥加密方案在选择密文攻击下的不可区分性","url":"/posts/20dbd7e1.html","content":"\nIND-CPA安全仅保证敌手是完全被动情况的安全，不能保证敌手主动情况（如向网络中注入消息）的安全。\n为了描述敌手的主动攻击，前人提出一种选择密文攻击（Chosen Ciphertext Attack，CCA）的概念，其中敌手在获得目标密文以前，可以访问解密喻言机。敌手获得目标密文后，希望获得目标密文对应的明文的部分信息。\n公钥加密方案在选择密文攻击下的IND游戏如下：\n（1）初始化。挑战者产生系统Π\\mathcal{\\Pi}Π，敌手获得系统的公开钥。\n（2）训练。敌手向挑战者做解密询问，即取密文CT给挑战者，挑战者解密后，将明文给敌手。\n（3）挑战，敌手输出两个长度相同的消息M0,M1M_0,M_1M0​,M1​，再从挑战者接收MβM_{\\beta}Mβ​的密文，其中随机值β←R{0,1}\\beta \\larr _R\\{0,1\\}β←R​{0,1}。\n（4）猜测，敌手输出β′\\beta^{\\prime}β′，如果β′=β\\beta^{\\prime}=\\betaβ′=β，则敌手攻击成功。\n以上攻击过程称为午餐时间攻击，相当于有一个执行解密运算的黑河，掌握黑盒的人在午餐时间离开后，敌手能使用黑河对自己选择的密文解密。午餐过后，给敌手一个目标密文，敌手试图对目标密文解密，但不能再使用黑盒。\n敌手的优势定义为安全参数K\\mathcal{K}K的函数：\nAdvΠ,ACCA(A)=∣Pr[β′=β]−12∣Adv_{\\mathcal{\\Pi},\\mathcal{A}}^{CCA}(\\mathcal{A})=|Pr[\\beta^{\\prime}=\\beta]-\\frac{1}{2}|\nAdvΠ,ACCA​(A)=∣Pr[β′=β]−21​∣\n如果对任何多项式时间的敌手A\\mathcal{A}A，存在一个可忽略函数ϵ(K)\\epsilon (\\mathcal{K})ϵ(K)，使得AdvΠ,ACCA(A)≤ϵ(K)Adv_{\\mathcal{\\Pi},\\mathcal{A}}^{CCA}(\\mathcal{A}) \\le \\epsilon (\\mathcal{K})AdvΠ,ACCA​(A)≤ϵ(K)，那么我们就称这个加密算法Π\\mathcal{\\Pi}Π在选择密文攻击下具有不可区分性，或者称为IND-CCA安全。\n","categories":["密码学基础"],"tags":["密码学基础"]},{"title":"关于评价指标","url":"/posts/58c2e786.html","content":"关于评价指标\n本文将介绍识别/匹配类论文中常出现的几种评价指标：TPR,FPR,TAR,FAR,FRR,ERR\nTPR：True Positive Rate，真阳性，分类器正确分类且本身为正例\nTNR：True Negative Rate，真阴性，分类器正确分类且本身为负例\nFPR：False Positive Rate，假阳性，分类器错误分类本身为负例\nFNR：False Negative Rate，假阴性，分类器错误分类本身为正例\nTPR=TP/(TP+FN),即正确识别的正例数据占据总的正例数据的比例，为召回率；\nFPR=FP/(FP+TN),即实际值为负例数据，将负例数据预测为正例的百分比；\nROC\nROC曲线（Receiver Operating Characteristic）：受试者工作特征曲线\n在分类任务中，我们使用分类器对样本进行分类，分类器会给出样本为正例的概率，我们可以针对此来设定一个阈值，当某个sample被判断为正例的概率大于这个阈值时，认为该sample为正例，小于则为负例。根据阈值-正负例概率，我们可以得到若干个(TPR , FPR)对。\n当阈值越大时，越多的样本被分为负例，而这些样本中其实也有正例的存在。这会导致TPR下降，FPR也下降（负类数据更不会被分为正例，但是影响要比TPR小，所以斜率呈上升趋势）。阈值越小时，越多的样本被分为正例，而这些样本中可能包含是正例，却被分为负例的样本以及是负例却被分为正例的样本，这样一来TPR上升（更多的正例样本被分为正例），FPR上升（更多的负例样本被分为正例，影响更大，所以斜率呈下降趋势）。\n\nTAR(True Accept Rate)表示正确接受比例，FAR(False Accept Rate)表示错误接受比例，所谓的接受比例可以表示说，在iot设备配对中，两个设备被认为是合法的配对。\nFalse Accept Rate：通过给定一个阈值T，如果两台设备的相似度大于T，则被认为同一成功配对，反之则为失败配对。无论将T设置为任何值，均会出现FAR一定的错误接受比例。但是，FAR越小，说明系统的匹配精确度越高。\nTAR：在比对设备匹配的时候，把相同环境/正确匹配识别正确的比例，即正确接受比例。相比于FAR相比，TAR越高意味着模型的鲁棒性越好。\nFRR：错误拒绝率，FRR=1-TAR\nEER：即等误率，即在某一值时，FRR=FAR\n"},{"title":"分布式机器学习","url":"/posts/59707b04.html","content":"\n\n分布式机器学习介绍\n分布式机器学习也称为分布式学习，是指利用多个计算节点（也可称为工作者，worker）进行机器学习或者深度学习的算法和系统，旨在提高性能，保护隐私，并可扩展至更大规模的训练数据和更大的模型。如图所示。训练数据被分为不相交的数据分片并被发送给各个工作者，工作者将在本地执行随机梯度下降（Stochastic Gradient Descent，SGD）。工作者将梯度∇Wi\\nabla W^i∇Wi或者模型参数WiW^iWi发送至服务器。参数服务器对收到的梯度或者模型参数进行聚合，从而得到全局梯度∇W\\nabla W∇W或全局模型参数WWW。\n\n面向扩展性的DML\n大规模机器学习\n在大数据时代，ML面临的主要问题是如何处理大规模的高纬度数据集，随着大趋势的变化，ML社区正面临着计算性能和好事与数据规模不匹配的挑战，这使得大规模的训练样本中耗费合理的计算代价和时间进行学习变得愈加不可能。\n内存短缺\n传统ML方法只在一块独立内存中对训练样本进行所有的操作，因此，可能出现：训练模型可能不能收敛或性能低下（低准确率和召回率）。\n不合理的训练时间\nML算法中的一些优化过程可能不能匹配训练样本的规模。因此，当处理大规模训练样本时，在训练处理中耗费的时间可能过长，在模型训练过程中，如果需要尝试多种不同的参数设置，ML模型的超参调校也将耗费大量时间。\n面向扩展性的DML方法\n数据并行\n将训练数据划分为多个子集，然后将各子集置于多个计算实体中，之后并行地训练同一个模型。目前，主要有两种基于数据并行的分布式训练方法，同步训练和异步训练。\n模型并行\n随着模型变得越来越大，我们可能会面临一个模型不能加载到单一计算节点内存中的问题。对于这种情况，我们需要分割模型，并将各部分置于不同的计算节点中。尽管将各个部分置于不同计算设备中确实能够改善执行时间，但模型并行的主要目的是避免内存容量限制。\n任务并行\n任务并行也叫做以任务为中心的方法，指的是计算机程序在同一台或多台机器上的多个处理器上执行，它着力并行执行不同的操作以最大化利用处理器或内存等计算单元。\n面向隐私保护的DML\n对于隐私保护的ML系统，它通常能保护下列的信息：训练数据输入，预测标签输出，模型信息（包括模型参数，结构和损失函数）和身份识别信息（如记录的数据来源站点，出处和拥有者）。\n隐私保护方法\n在面向隐私的DML中，常用的用于保护数据隐私的方法大概分为以下两类：\n（1）模糊处理。随机化，添加噪声或修改数据使其拥有某一级别的隐私。\n（2）密码学方法。通过不将输入值传给其他参与方的方式或者不以明文方式传输，使分布式计算过程安全话。\n","categories":["联邦学习"],"tags":["联邦学习"]},{"title":"区块链中的前沿技术","url":"/posts/64d2edde.html","content":"\n元宇宙\n头号玩家：献给所有游戏玩家的一封情书\n在头号玩家中，令人惊叹的“绿洲”让人向往，那么这一世界是怎么实现的呢？这就体现区块链技术在另一个方向的发展：元宇宙。\n根据维基百科，Metaverse 被定义为“一个集体虚拟共享空间，由虚拟增强的物理现实和物理持久的虚拟空间融合而创造，包括所有虚拟世界、增强现实和互联网的总和。”\n这是另一个与我们物理世界平行的虚拟世界——一个我们可以通过互联网和兼容的硬件设备自由访问的世界，并在其中进行互动。\n元宇宙是真实和虚拟之间的桥梁，可以扩展我们的视觉、声音和触觉，将数字物品融入物理世界，让我们随时进入完全沉浸式的3D 环境。\n元宇宙虽然不像科幻小说和影视作品中描绘的那样奇幻，但却有可能成为新的计算平台和内容媒体，产生数万亿美元的价值。元宇宙确实可以作为网络功能的“继承者”——覆盖范围更大、花费的时间更长、商业活动更多——经济优势也有可能更大。\n更广泛地说，元宇宙**将改变现代资源的分配和货币化方式。**在元宇宙的模式下，居住在“一线发达市区”以外的潜在劳动力将通过虚拟劳动参与“高价值”经济。作为极具生命力的新事物，元宇宙源源不断地创造着新就业机会。\n元宇宙的应用和赛道实在是太多太多，目前主要存在四个大赛道：\n\nVR/AR等硬件设备\n游戏\n3D渲染等技术\n虚拟人\n\n发展挑战：\n\n知识产权，在某种程度上，元宇宙将颠覆原有的产权问题，随之而来的是一些新问题，比如信息景观和虚拟创造物是否有资格获得法律保护和所有权；建立在第三方信息底层的内容是否属于用户作品等。\n法律概念：元宇宙会带来对传统法律概念的改变。通过消除现实世界的物理性，元宇宙将我们人类社会从几个长期持有的法律概念中转移出来\n\nNFT\n一个非常有意思的新闻：\n[Stephen Curry最近刚刚花费 55 ETH（约合 180,000 美元）购买了Bored Ape Yacht Club NFT。](https://hypebeast.com/2021/8/stephen-curry-bored-ape-yacht-club-nft-55-ethereum-purchase)\n如今，NFT 应用的用例十分广泛，包括：收藏品、游戏、艺术、虚拟资产、现实世界资产代币化等等。NFT 还能灵活地存储、控制和保护与个人身份相关信息。\n那么，NFT 到底是什么？\nNFT，全称为Non-Fungible Token，指非同质化代币，是用于表示数字资产（包括jpg和视频剪辑形式）的唯一加密货币令牌。现实世界中，不存在表现出完全相似特征或价值的两种商品，所以被称为非同质化货物，即指唯一的、无法替代的商品。\n现实世界中，真实资产拥有所有权证书，同样，在区块链世界中，NFT 代币可以保持所有权记录和真实性证明。\n每个NFT 之间无论是价值还是属性都各不相同。每个代币都有区别于其他代币的数字哈希值；因此，NFT 可以作为出处证明。NFT的价值：它不仅能证明原创艺术品和游戏代币等知识产权的所有权和真实性，还能代表股票、房地产等实际资产。在游戏和藏品领域，NFT 也被称为数字藏品。\n在现有的市场中，NFT的产品包括：收藏品，游戏资产，虚拟世界，加密艺术品，金融，功能型NFT等。\n例如：游戏NFT，加密猫https://www.cryptokitties.co/?startMeow=visible\n一款基于以太坊开发的NFT资产类游戏，每个NFT，也就是每只猫都有不同的属性，玩家购买NFT后，就可以开始小猫繁殖的游戏。\n\n孵化出来的小猫的基因一部分遗传自上一代，一部分随机生成，孵化的小猫卖出变现，实现在游戏中边玩边赚。简单来说，就是电子养猫，每只猫都有一定的价值。\n在最开始的时候，CryptoKitties最初构想是通过游戏，让普通用户了解什么是区块链及加密货币。这是一个很好的出发点。游戏2017年上线，架设在以太坊网络上，当时年初以太坊价格才几十美元，年底涨到最高800多美元，当时用以太坊作为手续费，玩家还可以接受。现在以太坊价格已经涨到3k多美元，每次交易手续费就是挺大的成本了。\n另一方面，它的价格波动也出现了传统加密货币的毛病：\n在2017年顶峰的日活超过1.4万，然后刺激了区块链游戏赛道的发展（投资），这一度让CryptoKitties价格水涨船高。然而，在2018年，大量资本退出区块链市场，这个价格也达到很低。在最近几年，随着牛市以及NFT概念的火爆，CryptoKitties再度翻红。可以说，这种畸形的价格波动是NFT乃至加密货币市场存在的一个巨大问题。\nDeFi\nDeFi，去中心化金融，是与传统的金融机构以及工作原理所相反的一种经济方式。\n传统的银行，作为金融业的巨头，为个人、企业、其它金融机构甚至政府提供便捷的支付、储蓄与信贷等服务。在全球前十大银行中，它们的市值加起来高达2万亿美元。\n虽然银行毫无疑问成为社会中最重要的支柱，但是，银行是由人来管理并会受政策监管，因而容易遭受与人相关的风险，比如管理不善和腐败。DeFi试图利用新兴的互联网和区块链技术创建一个更好的金融环境，它对传统的银行系统的三个关键部分进行了优化：\n\n支付和清算：传统的转账，当你在国内想要给国外的人支付一笔费用，这通常包含三种手续费：你的银行汇率，国际电汇汇出手续费以及国际电汇汇入手续费，并且正常的银行系统需要几个工作日才能处理完这笔交易。在DeFi中，加密货币允许你绕过转账过程中撷取大份额利润的中间人，这不仅能够节省大量时间，（通常一笔交易只需要15s到5min），而且还只需要很少的手续费。\n可获取性：现实中可能大部分人都有一个自己的银行账户，但是根据世界银行估计，全世界大约有17亿人，其中大部分来自于发展中国家，没有在金融机构持有账户，主要原因包括：贫穷，地理位置和信任问题。在DeFi中，代表着一场旨在推行无国界、无审查、无障碍金融产品的运动。DeFi协议不会歧视任何人，而且会为每个人营造公平的参与环境。\n中心化和透明度：银行是导致金融体系崩溃的中心节点之一，让权力和资金集中于银行手中是十分危险的。透明度也与此紧密相关——普通投资者无法充分了解金融机构的运作。DeFi在这方面会有所不同。建立在公共区块链（如以太坊）上的DeFi协议大都是开源的，便于审计和提升透明度。这些协议通常会有去中心化的治理组织来确保每个人都清楚发生了什么，并确保没有恶意行为者能够单独地做出恶意决策。\n\n去中心化金融（DeFi）是一场能够让用户在无需依靠中心化实体的情况下使用诸如借贷和交易等金融服务的运动。DeFi不是单个产品或公司，而是一系列替代银行、保险、债券和货币市场等机构的产品和服务。\n跨链\n跨链是目前区块链最前沿的技术，也是未来发展的重要方向之一\n当前的区块链底层技术平台百花齐放，不同的业务、不同的技术底层的区块链之间缺乏统一的互联互通的机制，这极大限制了区块链技术和应用生态的健康发展。这也是跨链技术产生的原因。\n简单来说，由于每个区块链都有其自己的规则和机制，不同的区块链之间通常就缺乏跨链通讯机制，例如你不能简单地在以太坊（Ethereum）上的DeFi平台直接使用比特币（Bitcoin）。 但是，你可以想象不同的区块链网络为不同的国家，而跨链就是在着些国家当中建立桥梁，隧道等通道。\n**跨链技术本质上是⼀种将A链上的数据D（或信息I，或消息M）安全可信地转移到B链并在B链上产生预期效果的⼀种技术。**因为区块链系统本来就是⼀种特殊的分布式账簿数据库系统，所以这个转移的数据，最常见的就是资产的数据，如代币余额。\n目前主流的跨链技术为：公证人机制、哈希锁定、侧链&amp;中继链。目前最有名的跨链项⽬有Cosmos和Polkadot，两者采⽤的都是基于中继链的多链多层架构。\n针对一项技术，尤其是这种设计多个区块链，影响价值巨大的技术，我们要考虑它的安全性问题。\n截至 2022 年第三季，针对跨链桥的攻击已有13 次，被偷取的加密货币折合总值约20亿美元。资料来源：Chainalysis.\n\n跨链桥的安全问题，关键之一在于跨链桥的信任机制，特别是跨链桥上交易和资产托管（custodian）的验证过程。\n跨链桥的信任机制设计各有不同。当中一种常见的跨链桥类型是中心化（centralised）的跨链桥。中心化跨链桥依赖一小群组织或机构来验证交易、并充当跨链资产的保管人（custodian）。保管人负责在涉及的区块链上确认用户有存入代币，负责进行锁定代币和铸造代币等操作。这种设计往往造成单点故障（single point of failure）的情况，容易出现漏洞和风险。\n但是，随着区块链逐渐向多链并行的方向发展，跨链解决方案打通不同区块链生态系统，显然可以为整体区块链生态提升应用价值。对用户而言，跨链技术可以让“各自为政”的区块链可以互联互通，自然可以让用户扩大手上加密货币资产的价值。毕竟，价值不是一潭死水，只有流通的价值才可以创造出更多的价值\n","categories":["区块链"],"tags":["区块链"]},{"title":"区块链","url":"/posts/89374c81.html","content":"\n区块链基础\n区块链究竟是什么？狭义地说，区块链就是比特币的底层技术；不过，经过7年的发展，区块链已经不再“依附于”比特币，而是独立地发展成为了一种革命性的技术，比特币则是区块链最大、最成功的应用。\n\n从技术层面来看，区块链是一个基于共识机制、去中心化的公开数据库。共识机制是指在分布式系统中保证数据一致性的算法；去中心化是指参与区块链的所有节点都是权力对等的，没有高低之分，同时也指所有人都可以平等自由地参与区块链网络，唯一的限制就是个人自己的选择；公开数据库则意味着所有人都可以看到过往的区块和交易，这也保证了无法造假和改写。基于以上特性，可以总结得出：区块链由许多对等的节点组成，通过共识算法保证区块数据和交易数据的一致性，从而形成一个统一的分布式账本。\n从价值层面来看，区块链是一个价值互联网，用于传递价值。目前的互联网仅用来传递消息，但是还不能可靠地传递价值；而比特币区块链却可以在全球范围内自由地传递比特币，并且能够保证不被双花、不被冒用。从这个角度来说，区块链是记录价值、传递消息和价值本身转移的一个可信账本。\n以区块链技术为核心的系统包括如下四大最主要的特点。\nDistributed（分布式的）\n区块链是全球化的，系统上的节点是运行在太平洋某个小岛的笔记本电脑上还是运行在中国某个小镇的服务器上，对系统本身来说都是一样的，除了网络连接速度有区别之外，其他没有任何区别。区块链没有中心节点，数据分布式地存储在各个节点上，即使绝大部分节点毁灭了，只要还有1个节点存在，就可以重新建立并还原区块链数据。\nAutonomous（自治的）\n区块链是一种去中心化的、自治的交易体系，这种自治性表现在两个方面：1）所有节点都是对等的，每个节点都可以自由加入和离开，并且这一行为对整个区块链系统的运行没有任何影响。所有的节点都是按照相同的规则来达成共识，且无需其他节点的参与。2）区块链系统本身一旦运行起来，就可自行产生区块并且同步数据，无需人工参与。\nContractual（按照合约执行的）\n区块链是按照合约执行的，第一体现在各个节点的运行规则（指的是交易、区块链或协议）上，按照既定的规则执行，一旦出现违背规则的行为，就会被其他节点所抛弃；第二体现在智能合约上，智能合约是一种可程序化的合同条款、规则或规定，包含在每个交易中，交易验证时必须先运行智能合约，只有通过了验证的交易才能被接受。\nTrackable（可追溯的）\n区块链的数据是公开透明的，不能被篡改，而且相关交易之间有一定的关联性，因而很容易被追溯。比如比特币区块链，每一枚比特币都有其特定的来源，通过输入可以追溯到上一个交易，或者通过输出追溯到下一个交易。此外，区块链代码本身也是可追溯的，区块链系统是开源软件，其对于所有的人都是公开的，因此任何人都可以查看并修改这些代码，不过修改后的代码需要经过开源社区上其他程序员的审核。\n交易合交易链\n交易是签过名的数据结构，该数据结构会在区块链网络中广播，并被收集到区块中。它会引用以前的交易，从该交易中发送特定数量的比特币到一个或多个公钥中（即比特币地址），并且交易未被加密（比特 币体系中没有加密任何数据）。多个交易可组成一个区块（block）， 这些区块同样也会在区块链网络中传播，一个区块会引用上一个区块。\n区块链就是由区块（block）用某种方式组织起来的链条 （chain）。\n比特币地址\n比特币地址是一个由数字和字母组成的字符串，可以与任何想给你 比特币的人分享。由公钥（一个同样由数字和字母组成的字符串）生成 的比特币地址以数字“1”开头。例子：\n1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy\n在交易中，比特币地址通常是以收款方的形式出现。比特币地址可以代表一对公钥和私钥的所有者，也可以代表其他东西。\n比特币地址是由公钥经过单向的Hash函数生成的。用户通常所见到 的比特币地址是过“Base58Check”编码的，这种编码使用了58个字 （一种Base58数字系统）和校验码，提高了可读性、避免了歧义，并有效地防止了在地址转录和输入中产生错误。\n交易的本质\n交易实质上就是包含一组输入列表和输出列表的数据结构，也可称之为转账记录，这其中就包括了交易金额、来源和收款人等信息。\n输入和输出\n输入是对其他交易输出的引用，一个交易中通常列有多个输入。所有被引用的输出值相加，得出的总和值会在该交易A的输出中用到。\nPrevious tx：以前交易的Hash值\nIndex：被引用交易的特定输出号\nScriptSig：一个脚本的前一半\n脚本包含两个部分，一个签名和一个公钥，公钥属于交易输出的收款人，并且表明交易创建者允许收款人获得的输出金额；另一个部分是 ECDSA签名，是通过对交易的Hash值进行ECDSA签名而得到的。\n输出中包含了发送比特币的指令，金额（Value）是以聪（Satoshi,1BTC=100000000聪）为单位的数值。ScriptPubKey是脚本的另一半（这点将在后文中详细讨论），可以有多个输出，它们共享了输入金额。\n交易类型\n根据目标地址的不同，可以把交易分为如下几种类型：\n\n支付到公钥Hash\n\n一个比特币地址只是一个Hash值，因而发送者无法在scriptPubKey 中提供完整的公钥，当要赎回比特币时，接收者需要同时提供签名scriptSig和公钥scriptPubKey，脚本系统会验证公钥的Hash值与scriptPubKey中的Hash值是否匹配，同时还会检查公钥和签名是否匹配。\n\n支付到脚本Hash\n\n该类交易非常有意义，未来应该会在某些场合频繁使用。该类交易的接受地址不是通常意义上的地址，而是一个多签地址，以3开头。比如，三对公钥对可以生成一个多签地址。\n地址以3开头，可以实现多方管理资产，极大地提高安全性，也可以轻松实现基于比特币原生的三方交易担保支付。一个m-of-n的模式如下：\nm &#123;pubkey&#125;...&#123;pubkey&#125; n OP_CHECKMULTISIG\n其中，m和n需要满足：1≤n≤20，m≤n。\n1 of 3，最大程度私钥冗余。防丢私钥损失，3把私钥中任意一把即可签名发币，即使丢失2把也可以保障不受损失。\n2 of 3，提高私钥冗余度的同时解决单点信任问题。3把私钥中的任 意2把私钥可签名发币，对于三方不完全信任的情形，即中介交易，非常适用。\n3 of 3，最大程度解决资金信任问题，无私钥冗余。必须3把私钥全部签名才能发币，适用于多方共同管理的重要资产，但是任何一方遗失私钥均会造成严重损失。\n\n挖矿交易\n\n挖矿（coinbase）交易用于凭空产生比特币。\n挖矿交易只有一个输 入，该输入有一个“coinbase”参数，没有scriptSig，“coinbase”中的数据可以是任意内容，它不会被使用。\n挖矿交易的输出金额在一段时间内是固定值，现在是12.5个比特币。输出地址可以是任何地址，一般是矿工或矿池的比特币地址。\n找零地址\n在实际的交易中，假设A有一个比特币地址，并且包含着没有花费的10个比特币，B也有一个比特币地址，里面一分钱没有。当A向B支付10个比特币时，此时就不需要找零钱的问题。\n假设A的地址上有35个比特币（如图1-2所示），当A想向B支付8个 比特币时，如图所示，只需要使用包含着20个比特币的那一笔未消费支出，并设置好要支持的金额即可，剩下的12个比特币则会返回给A，以便A在将来可以继续使用。\n\n这样就有了一个找零机制，实际上，比特币在交易时会把消费时所用的地址（消费地址）的余额设置为零。当需要支付的金额小于可用余额时，在交易信息中必须告诉比特币网络零钱将要被发送至哪个地址， 即“找零地址”。找零地址可能是也可能不是原先的发送地址。\n隐私的保证 根据设计，每一笔比特币交易将在一个称为“区块链”的全球性的公共总账上永久可见，这就意味着任何人随时都可以在上面进行跟踪查询。通过将某个比特币地址与其使用者关联起来，好事者都可以据此绘制关于这个人与他人之间的资金转移的关系图。但如果是将找回的零钱发送至一个新创建的地址，那么就可以让这种追踪变得更加困难。\n假设从地址A发送比特币到地址B后，零钱返回地址为A，则区块链会揭示地址A向地址B支付了一笔钱。 同样的道理，如果有两个或两个以上地址参与其中，任何涉及这个接收零钱的找零地址都会揭示A作为支付方的交易。假如某个控制着的任何接收地址或付款地址的人其身份是众所周知的，那么其他有过交易往来的各方的身份也有可能被推断出来。\n但加入说交易后的找零地址是新的C地址，如果没有更多的信息，其他人所能知道的，只有一个差分了地址A的余额至地址B和C，而地址B或C的主人可能是也可能不是A。\n\n区块和区块链\n比特币网络中，数据会以文件的形式被永久记录，我们称这些文件为区块。一个区块是一些或所有最新比特币交易的记录集，且未被其他先前的区块记录。\n区块结构\n每个区块都包括了一个被称为“魔法数”的常数0xD9B4BEF9、区块的大小、区块头、区块所包含的交易数量及部分或所有的近期新交易。\n在每个区块中，对整个区块链起决定作用的是区块头。\n\n区块头描述：\n每个 区块都必须要指向前一个区块，否则无法通过验证。这个区块链条会一 直追溯到源头，也就是指向创世区块。很显然，创世区块的hashPrevBlock的值为零或为空。在区块头中，最关键的一个数据项是一个随机数Nonce，这串数字是一个答案，而这个答案对于每一个区块来说都是唯一的。它的特点如下：\n\n\n这个答案很难获得。\n\n\n有效答案有多个，不过我们只需要找到一个答案就可以了。\n\n\n其他节点对有效答案的验证很容易。\n\n\n没有固定的算法可以求出答案，所以唯一 的做法就是不断尝试，找寻这个答案的做法就是“挖矿”。\n区块内包含许多交易，他们通过Mekle根节点间接被散列，以保证矿工能及时追踪一个正在打包的区块内交易的变化情况。Merkle树是Hash的二叉树，在比特币中会两次使用SHA-256算法来生成Merkle树，如果叶子个数为奇数，则要重复计算最后一个叶子的两次SHA-256值。\n举例来说，有啊a,b,c三笔交易，Merkle根的生成过程如下：\nd1 = dhash(a)d2 = dhash(b)d3 = dhash(c)d4 = dhash(c) #奇数，计算两边d5 = dhash(d1 concat d2)d6 = dhash(d3 concat d4)d7 = dhash(d5 concat d6)\n创世块\n创世块（Genesis Block）是指区块链的第一个区块，创世块的收益花不掉：比特币客户端把区块和交易分别存储在两个数据库中，当客户端发现区块数据库为空时，就会用代码直接生成一个创世块，但是没有把创世交易存储到交易数据库中，比特币网络一旦受到要花掉创世交易输出的交易时，因为在交易数据库中找不到创世交易，因而都会被拒绝。\n区块链原理\n区块链是所有比特币节点共享的交易数据库，这些节点基于比特币 协议参与到比特币网络中来。\n由于每个区块包含前一个区块的Hash值，这就使得从创世块到当前 块形成了一条块链，每个区块必定按时间顺序跟随在前一个区块之后。\n\n如果一个区块是最长块链的最后一个区块，那么诚实的矿工只会在 这个区块的基础上生成后续块。如果一个区块链中的所有区块和交易均有效，则该区块链有效，并且要以创世块开头。当两个区块产生的时间仅相差几秒时，可能会产生包含一个区块的分叉，当出现以上现象时，矿工节点会根据收到区块的时间，在先收到的区块的基础上继续挖矿。\n挖矿和矿池\n挖矿原理与区块的产生\n比特币的挖矿和节点软件是基于对等网络、数字签名来发起和验证交易的。节点向网络广播交易，这些广播出来的交易需要经过矿工的验证，矿工们会用自己的工作证明结果来表达确认，确认后的交易会被打包到数据块中，数据块回春起来形成连续的数据块链。\n每一个比特币的节点都会收集所有尚未确认的交易，并且会将其归集到一个数据块中，这个数据块将和前面一个数据块集成在一起。矿工节点会附加一个随机调整数，并计算前一个数据块的SHA-256Hash运算 值。挖矿节点不断进行重复尝试，直到它找到的随机调整数使得产生的 Hash值低于某个特定的目标为止。\n当挖矿时，你会经常对区块头进行散列，你正在挖的区块也会时常进行更新。\n网络调整时间 如果当前区块的时间戳大于前11个区块的平均时间戳，并且小于“网络调整时间（Network-Adjusted Time）”+2小时，则认 为该时间戳是有效的。其中的“网络调整时间”是指与你相连接的所有节点的平均时间。当节点A连接到节点B时，A将从B处得到一个UTC的时间戳，A先将其转换成本地UTC并保存起来，网络调整时间等于所有节点的本地UTC时间+所有相连节点的偏移量平均值，然而，该网络时间永远不会调整到超过本地系统时间70分钟以上。\nNonce随机数通常都不会相同，但是它以严格的线性方式在增长，从0开始，每次执行散列时都会增长，当Nonce溢出时（此事经常发生），挖矿交易的extraNonce项就会增长，其将改变Merkle树的根节点。\n挖矿难度\n挖矿难度是对挖矿困难程度的度量，即指计算符合给定目标的一个Hash值的困难程度。比特币网络有一个全局的区块难度，有效的区域必须有一个Hash值，该Hash值必须小于给定的目标Hash值，矿池也会有一个自定义的共享难度。\n难度每过2016块就会改变一次，计算公式为： difficulty=difficulty_1_target/current_target\n其中，目标（target）是一个256位长的数值。\n矿池原理与商业模式\n为了激励计算力较低的用户继续参与挖矿，矿池就出现了。在一个矿池里，许多不同的人贡献出自己的计算力来生成一个区块，然后再根据每个人的贡献比例来分发奖励。\n矿池是比特币（Bitcoin）等P2P密码学虚拟货币开采所必需的基础设施，一般是对外开放的团队开采服务器。其存在的意义是提升比特币开采的稳定性，使矿工薪酬趋于稳定。关于矿池挖矿的方式，目前存在有Slush,Pay-per-Share,Luke-Jr,Triplemining,P2Pool,Puddinpop,其中有代表性的两个是：\nPay-Per-Share:该方式为立即支付每一个share支付报酬，该支付来源于矿池现有的比特币资金，因此可以立即取现，但将风险转移给了矿池的运营者\nP2Pool：P2Pool的挖矿节点工作在类似于比特币区块链的一种shares链上没由于没有中心，不会受到DoS攻击，99%的奖励（50BTC+交易费用）会平均分配给矿工，另外0.5%会奖励给生成区块的人。\n脚本系统\n比特币在交易中使用脚本系统脚本是简单的、基于堆栈的，并且是从左向右处理的。\n一个典型的发送比特币到目标地址D的脚本，要求接收者提供以下两个条件，才能花掉发给他的比特币：\n1）一个公钥，当进行散列生成比特币地址时，生成的地址是嵌入在脚本中的目标地址ID\n2）一个签名，用于证明接收者保存了与上述公钥相对应的私钥。\n原先发送比特币的一方，控制脚本运行，以便比特币在下一个交易中使用。想花掉币的另一方必须把以前记录的运行为真的脚本，放到输入区。\n换句话说：在一个交易中，输出脚本是数学题，输入脚本是题解，但不是这道数学题的题解。\n假设有这么一系列交易，如下：\n\n这一系列交易具有如下特征：\n\n都是单输入单输出交易\n每个输入交易输出交易中，都包含对应的脚本\n交易a为A转给B，交易b为B转给C，交易c为C转给D\n当前交易的输入都引用前一个交易的输出，如交易b的输入就是引用交易a的输出\n\n合约应用案例\n每个交易都有一个锁定时间，使得该交易处于特定状态并且可被新 交易替换，直至锁定时间来临。\n示例1：提供押金证明\n假设你注册了一个账号在某个网站，你希望在网站运营者出建立你的信用，一个可行的方法就是向网站付点钱购买信用，但如果你关闭了账号，可能想要回这部分钱，你对该网站的信任程度不足一将钱存到该网站，另一方面，该网站某天会消失。\n建立信用度的目的是你做出某种贡献，让网站知道你不是一个垃圾机器人。对于该问题，可以通过合约来解决：\n1）用户和网站相互发送各自新生成的公钥。\n2）用户创建交易TX1（支付交易），该交易支出10个BTC到网站 地址，用户创建了TX1但不广播。\n3）用户把TX1交易的Hash值发送给网站。\n4）网站使用TX1的Hash值创建交易TX2（合约），TX2花掉TX1的 钱并且支付到用户地址。nLocKt ime被设置成未来时间（比如六个月之后），输入的序列号为0。\n5）最终，这个不完整的交易TX2（一半已签名）被回送给用户， 用户检查合约是否如预期的一样在执行，即六个月后10BTC最终会回到 他的地址（除非情况有变）。\n6）用户先广播TX1，再广播TX2。\n在这个阶段，用户和网站都不能单独得到10BTC。六个月之后，合 约完成，即使网站消失了，用户也能得到币。\n如果用户想要提早关闭账号，又该怎么处理呢？网站创建新版的 TX2，nLocKt ime设为0，并且输入的序列号设为UINT＿MAX，重新签 名，把该交易发回用户，用户签名后广播该交易，就能提早结束合约并 且释放10BTC。\n如果该用户被证明是存在恶意行为的（例如：垃圾邮件发送 者），那么网站不会同意提早结束合约。如果用户有太多的滥用行为， 则网站可以要求增加存款数量，或者要求延长合约时间。\n示例2：担保和争端调解\n一个买家想和他不认识或不信任的某人进行交易，当交易出现问题 时，他想有一个第三方——也许是一个专业的争端调解服务来决定谁能拿到钱。\n该示例的实现步骤具体如下。\n1）和商家一起引入一个调解员（如：ClearCoin）。\n2）得到商家的公钥K1，得到调解员的公钥K2，创建自己的公钥 K3。\n3）把K2发给商家，商家生成一个随机数挑战调解员，调解员用K2 的私钥签名，用来证明K2确实属于调解员。\n4）创建一个交易TX1，使用如下输出脚本并且广播该交易。\n2&lt;K1&gt;&lt;K2&gt;&lt;K3&gt;3CHECKMULTISIGVERIFY\n现在这些币被锁定了，如果要解锁这些币，需要使用以下几种方 式。\n客户和商家同意（无论是成功的交易，还是在没有调解的情况下 商家同意回退给客户）。\n客户和调解者同意（失败的交易，调解者认同客户，客户得到退 款）。\n调解者和商家同意（商品已经发送，尽管有争议，商家还是得到 币）。\n示例3：保证合约\n保证合约是建造公众商品时的集资办法，公众商品是指一旦建成， 任何人都可以免费享受到好处的商品。标准的例子是灯塔，所有人都认 同应该建造一个，但是对于航海者个人来说灯塔太贵了，而且灯塔不只 是他一个人用得着，同时也会方便其他的航海者。\n一个解决方案就是向所有人集资，只有当筹集的资金超过所需的建 造成本时，每个人才真正付钱；如果集资款不足，则谁都不用付钱。\n1）主办方创建新的捐赠地址，宣布如果筹集资金超过1000BTC， 则将建造该商品，任何人都可以捐赠。\n2）捐赠者创建一个新交易，把一定数量的钱打到集资地址上，但 是他们并不广播该交易。该交易与常规的交易相似，但有三个不同点： 首先，不能做任何改变，如果你没有正确的输出金额1000BTC，那么你 必须先创建一个；第二，输入脚本要以 SIGHASH_ALL|SIGHASH_ANYONECANPAY的模式签名；最后，输出 值是1000BTC，注意，这不是一个有效的交易，因为输出值比输入值大 得多。\n3）把交易上传到主办方的服务器上，他们把交易保存到磁盘上， 随时更新捐赠的币数量。\n4）一旦服务器获得了足够的币，它将把所有捐赠者上传的独立交 易合并成一个新的交易，该交易只有一个输出，仅仅是把钱付到捐赠地 址，该输出与每个捐赠者的交易的输出部分相同，而输入部分则是所有 捐赠者输入的集合。\n5）广播完整的交易，发送捐赠的币到捐赠地址中。\nSIGHASH_ALL是默认模式，意味着要签名所有交易的内容，除了输入脚本。SIGHASH_ANYONECANPAY是附加的指示器，意味着签名仅覆盖自己的输入部分，而不会覆盖其他人的输入，这样一来，其他人的输 入可以留空。\n示例4：使用外部状态\n考虑一个例子，老人想让他的孙子继承遗产，继承时间是在他死后，或者在孙子年满18岁时，无论先满足哪个条件，他的孙子都可以得到遗产。\n为了解决这个问题，老人首先向他自己发送孙子要继承的资产数量，以便有一个正确的继承数量的唯一输出；接着，他创建了一个带有锁定时间的交易，该交易的意思是：在孙子18岁生日时，把币支付到孙 子的地址中，老人对该交易签名，不进行广播，直接把该交易给了孙子。当过了孙子的18岁生日之后，孙子广播了这个交易并且得到他的币。孙子可以在这个时间之前广播该交易，但他不会提前得到币，有些节点会在内存池中把这种交易丢弃掉，因为锁定时间在遥远的将来。\n示例5：跨链交易\n比特币技术可以用来创建多个独立的货币，与比特币实现理念相同的山寨币，可以在有限信任的条件下与比特币进行自由交易。\n1）A产生一些随机数据X（秘密）。\n2）A产生TX1交易（支付）包含了带跨链交易脚本的输出。它允许 币以A和B共同签名的方式释放，也可以以私密X和B签名的方式释放， 该交易未广播，块链的释放脚本包含了私密的Hash值，并非真正的私密 X本身。\n3）A产生TX2（合约），花掉TX1并且输出到A的地址，该交易有 个未来的锁定时间，输入的序列号为0，因而可以被替换。A签名TX2并 且发送给B，B给TX2签名后发送回A。\n4）A广播TX1和TX2，B可以看到币但是不能花掉它们，因为并没 有输出到B的地址，该交易还没有终结。\n5）B在山寨币块链上执行相同的操作，B的锁定时间应该大于A的 锁定时间，双方的交易都待定但未完全。\n6）因为A知道私密X，A能马上申报他的币，然而，A在申报币的 过程中，向B释放了私密X，所以B可以以私密X和签名B来完成山寨币 块链的交易。\n区块链进阶\n挖矿算法解析\nPoW挖矿算法及分析\nPoW（Proof of Work），即工作证明。也就是说，你获得多少货币，取决于你挖矿贡献的有效工作，比如，你的电脑性能越好，分给你的矿就会越多，即根据你的工作证明来执行货币的分配。\n挖矿算法的本质是通过一个Hash函数找到满足当前难度的Nonce，矿工用一些交易来构建候选区块，他会计算这个区块头Hash的值， 看其是否小于当前目标值，如果这个值小于目标值，矿工就会修改这个 Nonce的值，然后再试一次。通常来说一个矿工会做成千上万次Hash运算，从而得到一个合适的Nonce的值，使得区块头Hash满足当前难度。 这也是PoW（工作量证明）算法的由来。\n一个可参考的解析：https://www.jianshu.com/p/b23cbafbbad2\nPoS股权证明算法\nPoS（Proof of Stake），即股权证明。它是根据你持有货币的量和时间，给你发利息的一个制度。在股权证明模式下，有一个名词叫币龄，每个币每天产生1币龄，例如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000。\n以现有的比特币运行发展情况来看，比特币每年的挖矿产量都在不断减半，我们可以预计，随着比特币产量的不断降低，矿工人数也会越来越少，这样就会导致整个比特币网络的稳定性出现问题。当矿工人数降低时，比特币很可能会被一 些高算力的人或团队进行51%攻击，如果采用PoS体系，你即便拥有了 全网51%的算力，也未必能够进行51%攻击，因为这还要求攻击者持有全球51%的货币量，而这是很难达到的。\nSidechains\nSidechains（侧链）实质上不是指特定的某个区块链，而是指那些遵守侧链协议的所有区块链，这个词是针对比特币主链来说的。侧链协议是指可以让比特币安全地从比特币主链转移到其他区块链，同时又可以让其他区块链上的货币安全返回到比特币主链的一种协议。\n侧链的提出主要是基于以下几个原因。\n（1）应对其他区块链的应用威胁\n（2）比特币核心开发组不欢迎附生链\n（3）Blockstream商业化的考虑\n","categories":["区块链"],"tags":["区块链"]},{"title":"可证明安全","url":"/posts/69ca7032.html","content":"\nProvable Security\n在密码学中，当我们已经设计出一个密码系统或协议时，我们不能直接说它是安全的，因为这样很缺乏信服力。可证明安全通常是用来确定一个密码系统或协议是安全的。\n\n针对确定的安全目标，构造一个形式化的敌手模型及思维实验，利用概率论和计算复杂性理论，把敌手对密码算法或密码协议的攻击归约到对已知困难问题（大数分解，离散对数）的攻击。\n目前对于安全性有两种角度的理解。\n第一种称为“real vs random”，也就是如果加密所得的真实密文的概率分布，看起来和随机（均匀）选取一个密文一样，那么偷听者将无法从密文中获取信息。下面是形式化定义：\n一个密码算法Σ\\SigmaΣ有一次性的均匀分布的密文（one-time uniform ciphertexts），当且仅当\nk←ΣKeyGenc←ΣEnc(k,m)return c=c←ΣCreturn ck\\larr \\Sigma KeyGen\\\\\nc\\larr \\Sigma Enc(k,m)\\\\\nreturn\\ c\\\\\n=\nc\\larr \\Sigma C\\\\\nreturn\\ c\nk←ΣKeyGenc←ΣEnc(k,m)return c=c←ΣCreturn c\n第二种安全性的定义称为“left vs right”，也就是对于任意的两个明文，他们所得的密文的概率分布是一样的，因此无法区分。下面是形式化定义：\n一个密码算法Σ\\SigmaΣ有一次性安全性（one-time secrecy），当且仅当：\nk←ΣKeyGenc←ΣEnc(k,mL)return c=k←ΣKeyGenc←ΣEnc(k,mR)return ck\\larr \\Sigma KeyGen\\\\\nc\\larr \\Sigma Enc(k,m_L)\\\\\nreturn\\ c\\\\\n=\nk\\larr \\Sigma KeyGen\\\\\nc\\larr \\Sigma Enc(k,m_R)\\\\\nreturn\\ c\\\\\nk←ΣKeyGenc←ΣEnc(k,mL​)return c=k←ΣKeyGenc←ΣEnc(k,mR​)return c\n两种安全性定义的关系\n满足定义1,一定满足定义2，Lots−realΣ=Lots−randΣ=&gt;Lots−LΣ=Lots−RΣ=L_{ots-real}^{\\Sigma}=L_{ots-rand}^{\\Sigma}=&gt;L_{ots-L}^{\\Sigma}=L_{ots-R}^{\\Sigma}=Lots−realΣ​=Lots−randΣ​=&gt;Lots−LΣ​=Lots−RΣ​=\n证明：第1步将其拆成了库的调用，主要是因为已知部分的输入只有一个参数。然后第2步是使用了条件（real和rand等价）。第三步是因为rand算法的结果与输入参数无关，因此可以换参数。第4步再次使用条件，最后得证。\n\n满足定义2,不一定满足定义1\n只要给出一个反例即可。比如下面这个密码算法，它是在一次性密码本的基础上，密文末尾加了两个0。由于一次性密码本是满足定义2的，因此对于任意两个明文，末尾加0后，两者的密文的概率分布仍然相同，因此满足定义2。但是在当前的密文空间上，一个明文加密所得的密文必然以00结尾，不满足均匀分布，故不满足定义1。\n\n如何证明不安全\n无论是哪种安全性的定义，我们只需要找到一个程序A，使得安全性定义中的两个库的执行结果（概率）不一样，就能证明该密码算法是不安全的。\n\n要证明如下两个库等价。显然，根据按位与的性质，对于real部分，如果输入的是全0，那么输出的密文一定是全0，这显然与右边的随机算法的输出的概率分布不同。\n\n因此，可以找到如下的一个程序，这个程序将证明 Pr[A Lots−realΣ=&gt;true]=1,Pr[A LotsrandΣ=&gt;true]=12λPr[A\\ L_{ots-real}^{\\Sigma}=&gt; true] =1,Pr[A\\ L_{ots_rand}^{\\Sigma}=&gt;true]=\\frac{1}{2^\\lambda}Pr[A Lots−realΣ​=&gt;true]=1,Pr[A Lotsr​andΣ​=&gt;true]=2λ1​，因此两个库不等价\n使用Hybrid方法证明安全性\n根据安全性的定义，证明需要计算概率，如果密码算法十分复杂，那么可能难以计算。因此Hybrid方法是希望通过一些等价转换（中间的库就称为hybrids），将待证明安全的密码算法转化为已证明安全的密码算法，从而简化安全性的证明。在给出具体示例之前，先介绍一些引理。\n引理1 (A L1) L2=A (L1 L2)(A\\ L_1)\\ L_2=A\\ (L_1\\ L_2)(A L1​) L2​=A (L1​ L2​),前者可以理解为，程序A将一些L1的函数内联，生成一个只调用L2的程序，后者可以理解为是链接了一个复合库，即L1可以调用L2\n引理2 Lleft=Lright, L∗ Lleft=L∗ LrightL_{left}=L_{right},\\ L^*\\ L_{left}=L^*\\ L_{right}Lleft​=Lright​, L∗ Lleft​=L∗ Lright​\n下面，给出一个简单的使用Hybrid方法证明安全性的例子：证明如下密码算法的安全性（定义1）。该密码算法是在一次性密码本（OTP）的基础上，多进行了一次加密（两次异或）。\n\n这里的思路是希望转化为已证明过安全性的一次性密码本\n因此第一步是转化为一次性密码本。第二步则利用了一次性密码本的安全性（等价），根据第二个引理进行替换。第三步是将库进行内联。最后简化无用代码。\n\n","categories":["密码学基础"],"tags":["密码学基础"]},{"title":"同态加密","url":"/posts/c86299ce.html","content":"\n同态加密\n同态加密（Homomorphic Encryption）是一种特殊的加密方法，允许对密文进行处理得到仍然是加密的结果。即对密文直接进行处理，跟对明文进行处理后再对处理结果加密，得到的结果相同。从抽象代数的角度讲，保持了同态性。\n本文，我们先回顾传统的加密方式，再介绍几种典型的同态加密\n\n传统的加密方式\n构建一个加密系统，往往需要一个密钥（key），通过这个密钥，我们可以把明文的信息加密成密文，然后通过密钥再把密文变回原来的样子。所有的加密系统，无疑是做了三件事：\n\n\nKeyGen(1λ)KeyGen(1^ \\lambda)KeyGen(1λ) 来随机生成一对加密和解密的密钥（EncKey,DecKeyEnc_{Key},Dec_{Key}EncKey​,DecKey​）\n\n\n加密方通过加密密钥EncKeyEnc_{Key}EncKey​和加密算法EncryptionEncryptionEncryption来加密明文plaintextplaintextplaintext，得到密文ciphertestciphertestciphertest\n\n\n解密方通过解密密钥DecKeyDec_{Key}DecKey​和解密算法DecryptionDecryptionDecryption来解密密文，得到明文plaintextplaintextplaintext\n\n\n在密码学研究中，每当我们看到一个新的系统的定义之后，接下来往往都要陈述这个系统所应具有的属性。\n正确性 如果我拥有一个正确的密钥，那么我就可以通过解密算法DecryptionDecryptionDecryption来把密文还原成原文。我们如下表示解密的成功率\n∀pt∈PT,(kenc,kdec)←KenGen(1λ)Pr[Decryption(kdec,Encryption(kenc,pt))=pt]=1\\forall pt \\in PT,(k_{enc},k_{dec})\\larr KenGen(1^\\lambda)\\\\\nPr[Decryption(k_{dec},Encryption(k_{enc},pt))=pt]=1\n∀pt∈PT,(kenc​,kdec​)←KenGen(1λ)Pr[Decryption(kdec​,Encryption(kenc​,pt))=pt]=1\n等式代表了，如果我们拥有正确的密钥，那么解密算法可以还原加密算法生成的密文的几率是100%。\n语义安全（Semantic Security）\n如果我们拥有任意两个不同的原文所对应的密文，那么我们是无法区分到底哪个密文是对应了哪个原文的：\n∀m0.m1:Enc(kenc,m0)≈Enc(kdec,m1)\\forall m_0.m_1:Enc(k_{enc},m_0)≈Enc(k_{dec},m_1)∀m0​.m1​:Enc(kenc​,m0​)≈Enc(kdec​,m1​)\n语义安全的主要意义在于旁观者无法区分两条加密的消息。\n同态加密的分类\n系统来看，同态加密大致上可以分为四类：部分同台，近似同台，有限级数全同态与完全同态。\nf([x1],[x2],...,[xn])→[f(x1,x2,...,xn)]f([x_1],[x_2],...,[x_n])\\rarr [f(x_1,x_2,...,x_n)]f([x1​],[x2​],...,[xn​])→[f(x1​,x2​,...,xn​)]\n部分同态加密\n同态加密最初级的阶段被称为部分同态加密，定义就是密文只有一种同态特性，指同态加密算法只对加法或乘法（其中一种）有同态的性质。\n假如说我们可以通过一个加法同态加密的算法来计算FFF的话，那么代表了这个函数F肯定就只能包含私密输入\nxix_ixi​的任意线性组合（加法运算）。一个可行的例子就是把各项私密输入乘以一个常数，然后相加起来：\nf(x1,...,xn)→c1x1+c2x2+...+cnxnf(x_1,...,x_n)\\rarr c_1x_1+c_2x_2+...+c_nx_nf(x1​,...,xn​)→c1​x1​+c2​x2​+...+cn​xn​\n常见的加法同态加密算法就是基于循环群GGG的ElGamal加密算法。\n假如我们拥有两条消息m0,m1m_0,m_1m0​,m1​的加密，分别为ct0,ct1ct_0,ct_1ct0​,ct1​，ct0=(v0=gy0,e0=pky0⋅gm0),ct1=(v1=gy1,e1=pky1⋅gm1)ct_0=(v_0=g^{y_0},e_0=pk^{y_0}\\cdot g^{m_0}),ct_1=(v_1=g^{y_1},e_1=pk^{y_1}\\cdot g^{m_1})ct0​=(v0​=gy0​,e0​=pky0​⋅gm0​),ct1​=(v1​=gy1​,e1​=pky1​⋅gm1​)\n我们把两条密文的两个部分各自相乘的话，可以得到一个新的密文ct^\\hat{ct}ct^\nct^=ct0⋅ct1=(v^=gy0+y1,e^=pky0+y1⋅gm0+m1)\\hat{ct}=ct_0\\cdot ct_1 = (\\hat{v}=g^{y_0+y_1},\\hat{e}=pk^{y_0+y_1}\\cdot g^{m_0+m_1})ct^=ct0​⋅ct1​=(v^=gy0​+y1​,e^=pky0​+y1​⋅gm0​+m1​)\n我们得到的结果恰恰就是原文m0+m1m_0+m_1m0​+m1​加在一起之后所对应的加密密文！这样的话，如果我们得到了两条ElGamal加密算法的密文，我们就可以通过这样的方法得到密文的任意线性组合了。\nRSA加密就是一个乘法同态的系统。\n假如我们拥有两条消息m0,m1m_0,m_1m0​,m1​的加密，分别为ct0,ct1ct_0,ct_1ct0​,ct1​，ct0=m0e(modN),ct1=m1e(modN)ct_0=m_0^e(modN),ct_1=m_1^e(modN)ct0​=m0e​(modN),ct1​=m1e​(modN)\n我们把两条密文的两个部分各自相乘的话，可以得到一个新的密文ct^\\hat{ct}ct^\nct^=ct0⋅ct1=m0e⋅m1e=(m0⋅m1)e\\hat{ct}=ct_0\\cdot ct_1 = m_0^e\\cdot m_1^e=(m_0\\cdot m_1)^ect^=ct0​⋅ct1​=m0e​⋅m1e​=(m0​⋅m1​)e\n近似同态加密（Somewhat Homomorphic Encryption）\n单纯的部分同态加密算法（RSA,ElGamal）无法完成加密的线性组合。\n如果我们有近似同态加密算法的话，那么我们就可以在密文上同时计算加法与乘法了。但是,因为这一阶段是近似同态（Somewhat Homomorphic）的，所以可以做的加法和乘法次数非常有限，可以计算的函数FFF也在一个有限的范围内。\n基于配对（Pairing）的循环群加密算法\n配对（pairing）是基于某些特有的椭圆曲线循环群可以进行的一种特殊运算，我们用e(⋅,⋅)e(\\cdot,\\cdot)e(⋅,⋅)，它的作用是把两个循环群中的值映射到第三个循环群中：e(gx∈G,gy∈G)→gTxy∈GTe(g^x\\in G,g^y\\in G)\\rarr g^{xy}_T \\in G_Te(gx∈G,gy∈G)→gTxy​∈GT​\n但是，Pairing这一特殊属性并不会出现在所有的循环群当中，通过拥有Pairing属性的循环群，我们只能做非常有限的乘法计算。假如说我们当前的群GGG支持Pairing，但是新的映射群GTG_TGT​并不支持任何Pairing，那就代表了如果我们要基于当前的体系进行同态加密运算，可以运算的函数F虽然可以包涵任意的线性组合，但是只能包涵最多一层乘法在里面。\n这一局限性证明了这个系统是近似同态的，因为我们不能计算任意逻辑和深度的函数F。\n有限级数全同态加密\n我们已经可以对密文进行任意的加法乘法组合了，没有任何对于次数的局限性。\n但是之所以被称之为有限级数全同态的原因是，这个阶段的算法会引入一个新的复杂度上限LLL的概念，这一复杂度上限约束了函数FFF的复杂度。如果我们可以把FFF用二进制电路CCC来表示的话，那么CCC的深度和大小一定要在LLL的范围之内: ∣C∣≤L\\vert C \\vert \\le L∣C∣≤L\n全同态加密（Fully Homomorphic Encryption，FHE）\n一个全同态加密的系统没有任何计算方法的限制，我们可以在没有密钥的情况下，把密文任意的组合起来，形成新的密文，并且新的密文，无论计算的复杂度，都可以完美的被还原成原文。\n一个全同态加密系统，一共拥有四个算法：\n\n\n密钥生成算法KeyGen(1λ)→skKeyGen(1^\\lambda)\\rarr skKeyGen(1λ)→sk，生成加密与解密需要用到的密钥sksksk。\n\n\n加密算法Enc(sk,m)→ctEnc(sk,m)\\rarr ctEnc(sk,m)→ct，把原文mmm加密成密文ctctct\n\n\n解密算法Dec(sk,ct)→mDec(sk,ct)\\rarr mDec(sk,ct)→m，还原密文\n\n\n运算算法Eval(F,ct1,...ctl)→c^tEval(F,ct_1,...ct_l)\\rarr \\hat ctEval(F,ct1​,...ctl​)→c^t，把l个密文组合起来，通过一个二进制逻辑电路FFF，最后得到密文c^t\\hat ctc^t，Dec(sk,c^t)=F(m1,...,ml)Dec(sk,\\hat ct)=F(m_1,...,m_l)Dec(sk,c^t)=F(m1​,...,ml​)\n\n\n现在我们来看看这个系统的属性（Properties）。首先，这个体系必须得是正确的（Correctness）。如果我们任意选择一个电路F，并且任意选择一组原文消息m1,...mlm_1,...m_lm1​,...ml​。如果我们拥有一开始KeyGenKeyGenKeyGen算法生成的密钥的话，那么Dec(sk,Eval(F,Enc(sk,m1),...Enc(sk,ml)))=F(m1,...,ml)Dec(sk,Eval(F,Enc(sk,m_1),...Enc(sk,m_l)))=F(m_1,...,m_l)Dec(sk,Eval(F,Enc(sk,m1​),...Enc(sk,ml​)))=F(m1​,...,ml​)\n其次，这个系统需要达到语义安全。\n为了让全同态加密体系变得有实际的使用意义，我们必须还得加一条额外的规定：简短性（Compactness）。简单来说，EvalEvalEval这个算法的输出结果大小必须独立于二进制电路FFF的大小: ∀F,sk,cti←Enc(sk,mi),∣Eval(F,ct1,...,ctl)∣=poly(λ)\\forall F, sk, ct_i \\larr Enc(sk,m_i),\\vert Eval(F,ct_1,...,ct_l) \\vert =poly(\\lambda)∀F,sk,cti​←Enc(sk,mi​),∣Eval(F,ct1​,...,ctl​)∣=poly(λ)\n如果没有简短性的要求，我们可以做出一个作弊的全同态加密：\n\n密钥生成、加密算法可以任意选择一个语义安全的对称加密算法。\nEval(F,cti)→(F,cti)Eval(F,ct_i)\\rarr (F,ct_i)Eval(F,cti​)→(F,cti​) ：运算算法EvalEvalEval要做的事情很简单，直接把对于FFF的描述和原来的密文ctict_icti​全部输出到新的密文ct^\\hat {ct}ct^当中。\nDec(sk,(F,cti))→F(Dec(sk,ct1),...,Dec(sk,ctl))Dec(sk,(F,ct_i))\\rarr F(Dec(sk,ct_1),...,Dec(sk,ct_l))Dec(sk,(F,cti​))→F(Dec(sk,ct1​),...,Dec(sk,ctl​)) ：最后在解密的时候，先把密文全部依次解密回原文，然后再根据对F的描述手动跑一下得到原来的结果。\n\n只要满足正确、语义安全、简短这三个要素，我们就拥有一个有意义（Non-trivial）的全同态加密体系了。\n全同态加密的历史回顾\n1978年，密码学界的几个大牛Rivest，Adleman和Dertouzos在他们的论文On Data Banks and Privacy Homomorphisms中第一次提到了对于密文进行一定的计算，可以间接地对原文进行操作的系统构想。到后来这一想法就被重新总结命名为全同态加密了。\n直到2009年，在斯坦福读书的PhD Craig Gentry突然灵光一现，攻破了FHE算法的难关。在他的博士毕业论文中，他第一次给出了一个合理并且安全的全同态加密系统！这一系统基于理想格（ideal lattice）的假设。Gentry09提出来的全同态系统，我们往往称之为第一代全同态加密系统。\n在2011年的时候，两位大佬Brakerski和Vaikuntanathan提出了一个新的全同态加密体系，这一体系基于格（lattice）加密的另一种假设Learning With Errors（LWE）。在同一年，Brakerski，Gentry与Vaikuntanathan这三人一起把这个体系做完了，并且正式发表出来。他们发明的全同态系统简称为BGV系统。BGV系统是一个有限级数的同态加密系统，但是可以通过Bootstrapping的方式来变成全同态系统。BGV系统相比起Gentry09提出的系统，使用了更加实际一点的LWE假设。一般来说我们都把BGV系统称之为第二代全同态加密系统。\n2013年，Gentry又卷土重来了。Gentry，Sahai和Waters三个大佬推出了新的GSW全同态加密系统。GSW系统和BGV相似，本身具有有限级数全同态性质，基于更加简单的LWE假设，并且通过Bootstrapping可以达到全同态。我们一般把GSW系统称为第三代全同态加密系统。\n","categories":["同态加密"],"tags":["同态加密"]},{"title":"区块链中的密码学","url":"/posts/9b221d34.html","content":"\nHash函数\nHash函数能将任意长度的输入变换为固定长度的输出且不可逆的单向密码体制。它的主要功能是数字签名和消息完整性检验。\n原理\nHash函数是一个单向函数，从明文到密文的不可逆映射，只有加密过程，没有解密过程。\nHash函数可以将满足要求的任意长度的输入进行转换，从而得到固定输出，输出称为原消息的散列值（Hash Value）或消息摘要（Message Digest）。Hash的数学表达：h=H(m)h =H(m)h=H(m)，H是Hash函数，m是任意长度明文，h是固定长度的Hash值。\n如果两个不同的消息x,x′x,x^\\primex,x′，有H(x)=H(x′)H(x) =H(x^\\prime)H(x)=H(x′)，则称发生了一个碰撞。\n典型的Hash函数有两类：消息摘要算法（MD5）和安全散列算法（SHA）。\nHash函数的特点：\n易计算：对于任意给定的消息，计算其Hash值比较容易。\n单向性：对于给定的Hash值h，要找到m′m^\\primem′使得H(m′)=hH(m^\\prime) =hH(m′)=h在计算上 是不可行的，即求Hash的逆很困难。\n抗碰撞性：理想的Hash函数是无碰撞的，但在实际算法的设计中 很难做到这一点。有两种抗碰撞性：一种是弱抗碰撞性，即对于给定的消息，要发现另一个消息，满足H（x）=H（y）在计算上是不可行的； 另一种是强抗碰撞性，即对于任意一对不同的消息（x,y），使得H（x）=H（y）在计算上也是不可行的。\nSHA-1算法\n输入：最大长度小于2642^{64}264位的消息，输入消息以512位的分组为单位进行处理\n输出：160位bit的消息摘要。\n实现速度高、容易实现、应用范围广\n（1）填充：对输入的消息进行填充，要求len(message)≡448(mod  512)len(message)\\equiv 448(\\mod 512)len(message)≡448(mod512)，填充的方式为第一位是1，余下各位是0。再将消息被填充前的长度以大端的方式附加在上一步留下的最后64位中。即使消息的长度满足所希望的长度也必须进行填充，填充长度范围是1-512\n（2）初始化缓冲区，可以用160位来存放Hash函数的初始变量、中间摘要及最终摘要，但首先必须进行初始化，对每个32位的初始变量赋值\nH0=0x67452301H1=0xefcdab89H2=0x98badcfeH3=0x10325476H4=0xc3d2e1f0H_0 = 0x67452301\\\\ H_1 =0xefcdab89\\\\ H_2 =0x98badcfe\\\\ H_3 = 0x10325476 \\\\ H_4 =0xc3d2e1f0H0​=0x67452301H1​=0xefcdab89H2​=0x98badcfeH3​=0x10325476H4​=0xc3d2e1f0\n3）进入消息处理主循环，处理消息块：一次处理512位的消息块，总共进行4轮处理，每轮进行20次操作，如图所示。这4轮处理具有类似的结构，但每轮所使用的辅助函数和常数都各不相同。每轮的输入均为当前处理的消息分组和缓冲区的当前值A、B、C、D、E，输出仍 放在缓冲区以替代旧的A、B、C、D、E的值。第四轮的输出再与第一 轮的输入CVq 相加，以产生CVq+1 ，其中加法是缓冲区5个字中的每个 字与CVq 中相应的字模232相加。\n4）输出：所有的消息分组都被处理完之后，最后一个分组的输出 即为得到的消息摘要值。\n\nSHA-2算法\nSHA-2算法分别有SHA-224,SHA-256,SHA-384,SHA-512,分别对应输出长度为256位，384位，512位\nSHA-256和SHA-512是很新的Hash函数，前者定义一个字为32位，后者则定义一个字为64位。实际上二者的结构是相同的，只是在循环运行的次数、使用常数上有所差异。SHA-224及SHA-384则是前述两种Hash函数的截短型，它们利用不同的初始值做计算。\n椭圆曲线加密\n椭圆曲线密码体制（Elliptic Curve Cryptosystem，ECC）是1985年由Koblitz N和Miller V提出的，其安全性是建立在求解椭圆曲线离散对数问题困难性的基础上的，在同等密钥长度的情况下ECC的安全强度要远高于RSA体制等其他密码体制。\n另一方面，在安全性相当的情况下，ECC所使用的密钥长度更短，这也就意味着对于带宽和存储空间的需求相对较小。\n椭圆曲线密码体制的安全性，依赖于椭圆曲线上离散对数问题（Elliptic Curve Discrete Logarithm Problem，ECDLP）的难解性。\n椭圆曲线方程\n常用于密码系统的基于有限域GF(p)GF(p)GF(p)上的椭圆曲线是由方程：\ny2=x3+ax+b(mod  p)y^2 = x^3 +ax+b (\\mod p)\ny2=x3+ax+b(modp)\n其中a,b,x,y∈GF(p),4a3+27b2≠0,p is a prime and p&gt;3a,b,x,y \\in GF(p), 4a^3+27b^2 \\ne 0, p \\ is\\ a\\ prime\\ and\\ p&gt;3a,b,x,y∈GF(p),4a3+27b2​=0,p is a prime and p&gt;3\n通常用Ep(a,b)E_p(a,b)Ep​(a,b)来表示这类曲线。\n在这类椭圆曲线上，通常有以下的运算规则：\n\n椭圆曲线点乘规则具体如下：\n\n公钥和私钥的产生算法：\n（1）选择一个椭圆曲线E:y2=x3+ax+b(mod  p)E:y^2=x^3+ax+b(\\mod p)E:y2=x3+ax+b(modp)，构造一个椭圆曲线Abel群Ep(a,b)E_p(a,b)Ep​(a,b)\n（2）选择生成元G=(x0,y0)G=(x_0,y_0)G=(x0​,y0​)，G应得满足nG=0nG=0nG=0，n是一个素数\n（3）选择一个小于n的整数nBn_BnB​作为其私钥，然后产生公钥PB=nBGP_B=n_BGPB​=nB​G，用户的公钥为(E,n,G,PB)(E,n,G,P_B)(E,n,G,PB​)，私钥为nBn_BnB​\nECDSA数字签名\n椭圆曲线数字签名算法（Elliptic Curve Digital Signature Algorithm,ECDSA）基于ECDLP，是使用椭圆曲线对数字签名算法（Digital Signature Algorithm，DSA）的模拟。\nECDSA数字签名算法流程：\n准备参数：Ep(a,b),G,sk=d,pk=dGE_p(a,b),G,sk=d,pk=dGEp​(a,b),G,sk=d,pk=dG\n签名：签名者A利用私钥对消息m进行签名，具体方法如下;\n(1)随机选择一个整数k\n(2)计算kG=(x1,y1),r≡x1mod  nkG=(x_1,y_1),r\\equiv x_1\\mod nkG=(x1​,y1​),r≡x1​modn\n(3)计算e=H(m),s=k−1(e+dr)mod  ne=H(m), s=k^{-1}(e+dr)\\mod ne=H(m),s=k−1(e+dr)modn\n其中(r,s)(r,s)(r,s)是A对消息m的签名\n验证：\n（1）验证r,s∈[1,n−1]r,s \\in [1,n-1]r,s∈[1,n−1]\n（2）计算e=H(m),w=s−1mod  n,u1=ewmod  n,u2=rwmod  ne=H(m), w =s^{-1}\\mod n, u_1 =ew\\mod n,u_2 =rw\\mod ne=H(m),w=s−1modn,u1​=ewmodn,u2​=rwmodn\n（3）计算X=u1G+u2Q=(x1,y1)X=u_1G+u_2Q=(x_1,y_1)X=u1​G+u2​Q=(x1​,y1​)\nECDSA在安全性方面的目标是能抵抗选择明文（密文）攻击。\n比特币区块链中，每个交易都需要用户使用私钥签名，只有采用该用户公钥验证通过的交易，比特币网络才会承认。\nBloom filter\nBloom filter是一种节省空间、高效率的数据表示和查询结构。它可以利用位数组很简洁地表示一个集合，并能以很高的概率判断一个元素是否属于这个集合。因此，这种数据结构适合应用在能容忍低错误率的场合。\n技术原理\n传统的判断一个元素是不是在一个集合中，通常的做法是把所有的元素都保存下来，然后比较确定它是不是在其中。但是，当元素的个数增大时，我们需要的空间和时间都会线性变大，检索速度也会越来越慢。Bloom filter采用的是Hash函数的方法，将一个元素映射到一个m长度的阵列上的一个点，当这个点是时，那么这个元素在集合内，反之则不在集合内。\n工作原理如下：\n（1）初始化状态，Bloom filter是一个m位数组，每一位都置为0\n（2）为了表达S={x1,...,xn}S=\\{x_1,...,x_n\\}S={x1​,...,xn​}这样有n个元素的集合，Bloom filter使用k个相互独立的Hash函数，分别将集合中的每个元素映射到{1,2,...m}\\{1,2,...m\\}{1,2,...m}中，对于任意一个元素x，第i个Hash函数映射的位置h(x)会被置为1\n（3）在判断y是否属于这个集合时，可对y应用k次Hash函数，如果所有hi(y)h_i(y)hi​(y)的位置都是1（1≤i≤k），那么就认为y是集合中的元素，否则就认为y不是集合中的元素。\nBloom filter的优点在于它的插入和查询时间都是常数，另外它查询元素却不保存元素本身，具有良好的安全性。\n缺点也很显而易见：插入元素越多，错判元素在集合内的概率越大，并且Bloom filter不能删除元素。\n","categories":["密码学基础"],"tags":["区块链"]},{"title":"对称密码体制","url":"/posts/c4d6c7e7.html","content":"加密-对称技术\n引言\n保密是密码学的核心，加密是获得信息保密的实用工具。\n把有意义区域中的消息和加密算法中的输入称为原文，而把加密算法不可理解的输出称为密文。为了恢复信息，加密变换必须是可逆的，逆变换称为解密。加密算法和解密算法再加上消息和密钥的形式描述就构成了密码体制。\n\n\n密码体制\n密码体制构成如下：\n\n明文消息空间M：某个字母表上的串集\n密文消息空间C：可能的密文消息集\n加密密钥空间K：可能的加密密钥集；解密密钥空间K`：可能的解密密钥集\n有效的密钥生成算法g：N→K∗K′N\\rarr K * K^\\primeN→K∗K′\n有效的加密算法：M∗K→CM*K\\rarr CM∗K→C\n有效的解密算法：C∗K′→MC*K^\\prime \\rarr MC∗K′→M\n\n对于整数1l1^l1l，g(1l)g(1^l)g(1l)输出长为 lll 的密钥对(ke,kd)。\n加密变换：c=εke(m)c=\\varepsilon _{ke}(m)c=εke​(m) ，解密变换：M=Dkd(c)M=D_{kd}(c)M=Dkd​(c)\n由此可以得到： Dkd(εke(m))=mD_{kd}(\\varepsilon_{ke}(m))=mDkd​(εke​(m))=m\n\n当kd=kekd=kekd=ke 的情况：对称密码体制\nKerchoffs原理 ：知道算法和密钥的长度还可以获得已知的明文是现代密码分析的标准假设，既然敌手最终可以获得这些信息，那么评估密码强度时最好不要依赖于这些信息的保密性。\n代换密码\n在 代换密码 中，加密算法是一个代换函数，它将每一个 m∈Mm \\in Mm∈M代换为相应的 c∈Cc \\in Cc∈C，代换函数的参数时密钥k。解密算法只是一个逆代换。\n简单的代换密码\n令 M=C=Z26M=C=Z_{26}M=C=Z26​，加密算法定义为下面的一个置换：\n\n相应的解密算法为：\n\n历史上出现过几种特殊的简单代换密码，最简单且最著名的密码称为移位密码。在移位密码中，K=M=CK=M=CK=M=C，加密和解密映射定义为：\nεk(m)←m+k(modN)\\varepsilon_k(m)\\larr m+k (modN)εk​(m)←m+k(modN)\nDk(c)←c−k(modN)D_k(c)\\larr c-k (modN)Dk​(c)←c−k(modN)\n当M=Z26M=Z_{26}M=Z26​时，移位密码也称为凯撒密码。\n同理也可以定义一种称为仿射密码的简单代换\nεk(m)←k1m+k2(modN)\\varepsilon_k(m)\\larr k_1m+k_2 (modN)εk​(m)←k1​m+k2​(modN)\nDk(c)←k1−1(c−k2)(modN)D_k(c)\\larr k_1^{-1}(c-k_2) (modN)Dk​(c)←k1−1​(c−k2​)(modN)\n单表密码不能抵抗频度分析攻击。\n多表密码\n如果明文信息元可以代换为许多可能是任意多的密文信息元，这种代换密码称为多表密码。\n维吉尼亚密码：密钥是由多于一个的字符所组成的串，令m为密钥长度，那么明文串被分为m个字符的小段。加密算法的运算同于密钥串和明文串之间的移位密码。\n例如：\n\n弗纳姆密码和一次一密\n弗纳姆密码 我们假设消息是比特串：m=b1b2...bn∈0,1nm=b_1b_2...b_n \\in 0,1^nm=b1​b2​...bn​∈0,1n\n那么密钥也是长为n的比特串： k=k1k2...kn∈0,1nk=k_1k_2...k_n \\in 0,1^nk=k1​k2​...kn​∈0,1n\n一次加密一比特，通过将每个消息比特和相应的密钥比特进行比特异或得到密文串 c=c1c2...cnc=c_1c_2...c_nc=c1​c2​...cn​，其中ci=bi⨁kic_i=b_i \\bigoplus k_ici​=bi​⨁ki​\n古典密码\n首先我们要指出古典密码的两个基本工作原理：代换和换位。\n古典密码安全使用的条件： #K≥#M,k∈K\\#K \\ge \\#M,k \\in K#K≥#M,k∈K，每次加密只使用一次。\n","categories":["密码学基础"],"tags":["对称密码"]},{"title":"差分隐私","url":"/posts/b192ad14.html","content":"\n本文将介绍差分隐私及其相关概念。\n\n差分隐私的承诺\n一个有趣的例子：\n医学数据库可能会告诉我们，吸烟会导致癌症，影响保险公司对吸烟者长期医疗费用的看法。吸烟者受到分析的伤害了吗？如果保险公司知道他吸烟，他的保险费可能会上涨。他可能也会得到帮助。但保险公司学习他的健康风险，使他进入戒烟计划。吸烟者的隐私被侵犯了吗？当然，研究结束后对他的了解比以前更多，但他的信息是不是“泄露”了？差分隐私将认为它不是，理由是对吸烟者的影响是相同的独立于他是否在研究中。是这项研究得出的结论影响了吸烟者，而不是他在数据集中的存在与否影响了实验得出的结论。\n差分隐私解决了一个问题，即分析人员通过数据集学习整体信息的同时（趋势、统计信息），无法获取个人的详细信息。\n对于给定的计算任务 TTT和给定的ε\\varepsilonε值，将有许多不同的私有算法以ε\\varepsilonε方式实现TTT。有些算法会比其他算法更准确。当ε\\varepsilonε很小时，很难为任务TTT找到一个高精度的ε\\varepsilonε-差分隐私算法，就像为一个特定的计算任务找到一个数值稳定的算法一样。\n隐私保护的数据分析\n数据不能完全匿名并且仍然有用\n一般来说，数据越丰富，就越有趣和有用。这就产生了“匿名化”和“删除可识别个人信息”的概念，这些概念希望部分数据记录可以被掩盖，其余部分可以发布并用于分析。\n然而，由于数据的丰富性使得“个人”数据属性可能与其他领域的数据属性相重合，比如邮政编码、出生日期和性别的组合，甚至三个电影的名字和一个独立的人观看这些电影的大致日期。这种“命名”功能可用于联动攻击，以将不同数据集中的“匿名”记录与非匿名记录进行匹配。有如下两个事例：\n\n1.通过将匿名医疗遭遇数据与（公开提供的）选民登记记录相匹配，确定了马萨丘塞特政府的医疗记录。\n2.通过与互联网电影数据库（IMDB）的链接，确定了 Netflix 用户，其观看历史记录包含在 Netflix 发布的匿名电影记录集合中，作为推荐竞赛的训练数据。\n\n重标识“匿名”记录并非唯一风险\n“匿名”数据记录的重新标识显然是不可取的，这不仅是因为重新标识本身（这肯定揭示了数据集中的成员身份），而且还因为记录可能包含损害信息，如果它与个人相关联，则可能会造成损害。在给定日期从特定紧急护理中心收集的医疗遭遇记录可能只列出少量不同的投诉或诊断。邻居在相关日期访问设施的附加信息给出了邻居病情的一系列可能诊断结果。可能无法将特定记录与邻居匹配这一事实为邻居提供了最低限度的隐私保护。\n长期的事实并不“好”\n如果一个数据主体随着时间的推移而被跟踪，那么揭露数据个体长期的行为（例如购买面包）可能会有问题。举个例子，假设某人，他年复一年地定期买面包，直到突然转向很少买面包。一位分析师可能会得出结论，某人很可能被诊断为2型糖尿病。分析员可能是正确的，也可能是不正确的；不管怎样，某人的隐私都会受到伤害。\n差分隐私的公式化\n定义1（概率单纯形），给定一个离散集BBB，将BBB上的概率单纯形（是一个数学空间，其中的每个点代表有限个互斥事件之间的概率分布），表示为Δ(B)\\Delta(B)Δ(B)，其定义为：\nΔ(B)={x∈R∣B∣: xi≥0 for all o and Σi=1∣B∣xi=1}\\Delta(B)=\\{x\\in R^{\\vert B \\vert}:\\ x_i \\ge 0\\ for\\ all\\ o\\ and\\ \\Sigma_{i=1}^{\\vert B\\vert}x_i=1 \\}\nΔ(B)={x∈R∣B∣: xi​≥0 for all o and Σi=1∣B∣​xi​=1}\n可以理解为将数据库中的数据集映射到各个离散状态集合BBB中\n定义2（数据库之间距离），将数据库的l1l_1l1​范数距离表示为∣∣x∣∣1\\vert \\vert x\\vert \\vert_1∣∣x∣∣1​，其定义为\n$\\vert \\vert x\\vert \\vert_1=\\Sigma_{i=1}^{\\vert \\chi \\vert} \\vert x_i\\vert\n\n数据库x,yx,yx,y之间的距离为∣∣x−y∣∣1\\vert \\vert x-y \\vert \\vert_1∣∣x−y∣∣1​\n注意到∣∣x∣∣1\\vert \\vert x\\vert \\vert_1∣∣x∣∣1​是衡量数据库xxx的大小（也就是说，数据库xxx包含的记录数），而∣∣x−y∣∣1\\vert \\vert x-y \\vert \\vert_1∣∣x−y∣∣1​表示数据库xxx和yyy之间相差多少条记录。我们称这种记录相差为1的数据库为相邻数据集。\n","categories":["差分隐私"],"tags":["差分隐私"]},{"title":"强化学习","url":"/posts/748f0bbe.html","content":"\n强化学习基础\nlink：https://datawhalechina.github.io/easy-rl/\n强化学习概述\n**强化学习（reinforcement learning，RL）**讨论的问题是智能体（agent）怎么在复杂、不确定的环境（environment）中最大化它能获得的奖励。\n\n强化学习和监督学习的区别如下。\n（1）强化学习输入的样本是序列数据，而不像监督学习里面样本都是独立的。\n（2）学习器并没有告诉我们每一步正确的动作应该是什么，学习器需要自己去发现哪些动作可以带来 最多的奖励，只能通过不停地尝试来发现最有利的动作。\n（3）智能体获得自己能力的过程，其实是不断地试错探索（trial-and-error exploration）的过程。探索 （exploration）和利用（exploitation）是强化学习里面非常核心的问题。其中，探索指尝试一些新的动作， 这些新的动作有可能会使我们得到更多的奖励，也有可能使我们“一无所有”；利用指采取已知的可以获得最多奖励的动作，重复执行这个动作，因为我们知道这样做可以获得一定的奖励。因此，我们需要在探索和利用之间进行权衡，这也是在监督学习里面没有的情况。\n（4）在强化学习过程中，没有非常强的监督者（supervisor），只有奖励信号（reward signal），并且奖励信号是延迟的，即环境会在很久以后告诉我们之前我们采取的动作到底是不是有效的。因为我们没有得 到即时反馈，所以智能体使用强化学习来学习就非常困难。当我们采取一个动作后，如果我们使用监督学习，我们就可以立刻获得一个指导，比如，我们现在采取了一个错误的动作，正确的动作应该是什么。而在强化学习里面，环境可能会告诉我们这个动作是错误的，但是它并没有告诉我们正确的动作是什么。而且更困难的是，它可能是在一两分钟过后告诉我们这个动作是错误的。所以这也是强化学习和监督学习不同的地方\n序列决策\n强化学习研究的问题是智能体与环境交互的问题\n智能体把它的动作输出给环境，环境取得这个动作后会进行下一步，把下一步的观测与这个动作带来的奖励返还给智能体。这样的交互会产生很多观测，智能体的目的是从这些观测之中学到能最大化奖励的策略。\n\n在与环境的交互过程中，智能体会获得很多观测。针对每一个观测，智能体会采取一个动作，也会得到一个奖励。所以历史是观测、动作、奖励的序列：\nHt=o1,a1,r1,...,ot,at,rtH_t=o_1,a_1,r_1,...,o_t,a_t,r_t\nHt​=o1​,a1​,r1​,...,ot​,at​,rt​\n我们可以把整个游戏的状态看成关于这个历史的函数：\nSt=f(Ht)S_t=f(H_t)\nSt​=f(Ht​)\n动作空间\n不同的环境允许不同种类的动作。在给定的环境中，有效动作的集合经常被称为动作空间（action space）\n组成成分和类型\n对于一个强化学习智能体，它可能有一个或多个如下的组成成分。\n\n策略（policy）。智能体会用策略来选取下一步的动作。\n价值函数（value function）。我们用价值函数来对当前状态进行评估。价值函数用于评估智能体进 入某个状态后，可以对后面的奖励带来多大的影响。价值函数值越大，说明智能体进入这个状态越有利。\n模型（model）。模型表示智能体对环境的状态进行理解，它决定了环境中世界的运行方式。\n\n策略是智能体的动作模型，它决定了智能体的动作。它其实是一个函数，用于把输入的状态变成动作。策略可分为两种：随机性策略和确定性策略。\n\n随机性策略：π(a∣s)=p(at=a∣st=s)\\pi(a|s)=p(a_t=a|s_t=s)π(a∣s)=p(at​=a∣st​=s)\n确定性策略：智能体直接采用最有可能的策略，a∗=arg⁡max⁡(a∣s)a^*=\\arg \\max(a|s)a∗=argmax(a∣s)\n\n价值函数的值是对未来奖励的预测，我们用它来评估状态的好坏\nVπ(s)=Eπ[Gt∣st=s]=Eπ[Σk=0∞γkrt+k+1∣st=s]V_\\pi (s)=E_\\pi[G_t|s_t=s]=E_\\pi[\\Sigma_{k=0}^\\infty\\gamma ^k r_{t+k+1}|s_t=s]\nVπ​(s)=Eπ​[Gt​∣st​=s]=Eπ​[Σk=0∞​γkrt+k+1​∣st​=s]\n还有一种价值函数：Q 函数。Q 函数里面包含两个变量：状态和动作\nQπ(s,a)=Eπ[Gt∣st=s,at=a]=Eπ[Σk=0∞γkrt+k+1∣st=s,at=a]Q_\\pi(s,a)=E_\\pi[G_t|s_t=s,a_t=a]=E_\\pi[\\Sigma_{k=0}^\\infty\\gamma ^k r_{t+k+1}|s_t=s,a_t=a]\nQπ​(s,a)=Eπ​[Gt​∣st​=s,at​=a]=Eπ​[Σk=0∞​γkrt+k+1​∣st​=s,at​=a]\n下一步的状态取决于当前的状态以及当前采取的动作。它由状态转移概率和奖励函数两个部分组成。状态转移概率即\npss′a=p(st+1=s′∣st=s,at=a)p_{ss^\\prime}^a=p(s_{t+1}=s^\\prime|s_t=s,a_t=a)\npss′a​=p(st+1​=s′∣st​=s,at​=a)\n奖励函数是指我们在当前状态采取了某个动作，可以得到多大的奖励\nR(s,a)=E[rt+1∣st=s,at=a]R(s,a)=E[r_{t+1}|s_t=s,a_t=a]\nR(s,a)=E[rt+1​∣st​=s,at​=a]\n当我们有了策略、价值函数和模型3个组成部分后，就形成了一个马尔可夫决策过程（Markov decision process）\n\n根据智能体学习的事物不同，我们可以把智能体进行归类。**基于价值的智能体（value-based agent）**显式地学习价值函数，隐式地学习它的策略。策略是其从学到的价值函数里面推算出来的。**基于策略的智能体（policy-based agent）**直接学习策略，我们给它一个状态，它就会输出对应动作的概率\n学习与规划\n学习（learning）和规划（planning）是序列决策的两个基本问题。\n在强化学习中，环境初始时是未知的，智能体不知道环境如何工作，它通过不断地与环境交互，逐渐改进策略。\n实验\n安装环境\nconda create -n rl-env python=3.8 -yconda activate rl-env\n安装gym库\npip install gym==0.25.2pip install pygame\n一个简单的强化学习框架：\nimport gym env = gym.make(&quot;Taxi-v3&quot;) observation = env.reset() agent = load_agent() for step in range(100):    action = agent(observation)     observation, reward, done, info = env.step(action)\n马尔可夫决策过程\n\n马尔可夫过程\n在随机过程中，**马尔可夫性质（Markov property）**是指一个随机过程在给定现在状态及所有过去状态情况下，其未来状态的条件概率分布仅依赖于当前状态。\np(Xt+1=xt+1∣X0:t=x0:t)=p(Xt+1=xt+1∣Xt=xt)p(X_{t+1}=x_{t+1}|X_{0:t}=x_{0:t})=p(X_{t+1}=x_{t+1}|X_{t}=x_{t})\np(Xt+1​=xt+1​∣X0:t​=x0:t​)=p(Xt+1​=xt+1​∣Xt​=xt​)\nX0:tX_{0:t}X0:t​表示变量集合X0,X1,..,Xt,x0:tX_0,X_1,..,X_t,x_{0:t}X0​,X1​,..,Xt​,x0:t​为在状态空间中的状态序列。马x0,x1,...,xtx_0,x_1,...,x_tx0​,x1​,...,xt​马尔可夫性质也可以描述为给定当前状态时，将来的状态与过去状态是条件独立的\n马尔可夫过程是一组具有马尔可夫性质的随机变量序列s1,...,sts_1,...,s_ts1​,...,st​，其中下一个时刻的状态st+1s_{t+1}st+1​只取决于当前状态 sts_tst​。我们设状态的历史为 ht=s1,s2,...,sth_t={s_1,s_2,...,s_t}ht​=s1​,s2​,...,st​（hth_tht​包含了之前的所有状态），则马尔可夫过程满足条件：\np(st+1∣st)=p(st+1∣ht)p(s_{t+1}|s_t)=p(s_{t+1}|h_t)\np(st+1​∣st​)=p(st+1​∣ht​)\n离散时间的马尔可夫过程也称为马尔可夫链（Markov chain）\n\n图中四个状态之间相互转移\n可以用状态转移矩阵 P来描述状态转移p(st+1=s′∣st=s):p(s_{t+1}=s^\\prime|s_t=s):p(st+1​=s′∣st​=s):\nP=(p(s1∣s1)p(s2∣s1)⋯p(sN∣s1)p(s1∣s2)p(s2∣s2)⋯p(sN∣s2)⋮⋮⋱⋮p(s1∣sN)p(s2∣sN)⋯p(sN∣sN))P = \\begin{pmatrix}\np(s_1 \\mid s_1) &amp; p(s_2 \\mid s_1) &amp; \\cdots &amp; p(s_N \\mid s_1) \\\\\np(s_1 \\mid s_2) &amp; p(s_2 \\mid s_2) &amp; \\cdots &amp; p(s_N \\mid s_2) \\\\\n\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\np(s_1 \\mid s_N) &amp; p(s_2 \\mid s_N) &amp; \\cdots &amp; p(s_N \\mid s_N)\n\\end{pmatrix}\nP=⎝⎜⎜⎜⎜⎛​p(s1​∣s1​)p(s1​∣s2​)⋮p(s1​∣sN​)​p(s2​∣s1​)p(s2​∣s2​)⋮p(s2​∣sN​)​⋯⋯⋱⋯​p(sN​∣s1​)p(sN​∣s2​)⋮p(sN​∣sN​)​⎠⎟⎟⎟⎟⎞​\n状态转移矩阵类似于条件概率（conditional probability）\n马尔可夫奖励过程\n马尔可夫奖励过程（Markov reward process, MRP）是马尔可夫链加上奖励函数。在马尔可夫奖励过程中，状态转移矩阵和状态都与马尔可夫链一样，只是多了奖励函数（reward function）。\n奖励函数RRR是一个期望，表示当我们到达某一个状态的时候，可以获得多大的奖励。这里另外定义了折扣因子γ\\gammaγ\n范围（horizon） 是指一个回合的长度（每个回合最大的时间步数）\n**回报（return）**可以定义为奖励的逐步叠加\nGt=rt+1+γrt+2+γ2rt+3+γ3rt+4+....+γT−t−1rTG_t=r_{t+1}+\\gamma r_{t+2}+\\gamma^2 r_{t+3} + \\gamma^3 r_{t+4}+....+\\gamma^{T-t-1} r_{T}\nGt​=rt+1​+γrt+2​+γ2rt+3​+γ3rt+4​+....+γT−t−1rT​\n其中，TTT是最终时刻，γ\\gammaγ是折扣因子，越往后得到的奖励，折扣越多\n对于马尔可夫奖励过程，状态价值函数被定义成回报的期望，即\nVt(s)=E[Gt∣st=s]=E[rt+1+γrt+2+γ2rt+3+γ3rt+4+....+γT−t−1rT∣st=s]V^t(s)=E[G_t|s_t=s] \\\\\n=E[r_{t+1}+\\gamma r_{t+2}+\\gamma^2 r_{t+3} + \\gamma^3 r_{t+4}+....+\\gamma^{T-t-1} r_{T}|s_t=s]\nVt(s)=E[Gt​∣st​=s]=E[rt+1​+γrt+2​+γ2rt+3​+γ3rt+4​+....+γT−t−1rT​∣st​=s]\n我们使用折扣因子的原因如下。第一，有些马尔可夫过程是带环的，它并不会终结，我们想避免无穷的奖励。第二，我们并不能建立完美的模拟环境的模型，我们对未来的评估不一定是准确的，我们不一定完全信任模型，因为这种不确定性，所以我们对未来的评估增加一个折扣\n从价值函数里面推导出贝尔曼方程（Bellman equation）：\nV(s)=R(s)⏟即时奖励+γ∑s′∈Sp(s′∣s)V(s′)⏟未来奖励的折扣总和V(s) = \\underbrace{R(s)}_{\\text{即时奖励}} + \\gamma \\underbrace{\\sum_{s&#x27; \\in S} p(s&#x27; \\mid s) V(s&#x27;)}_{\\text{未来奖励的折扣总和}}\nV(s)=即时奖励R(s)​​+γ未来奖励的折扣总和s′∈S∑​p(s′∣s)V(s′)​​\ns′s&#x27;s′ 可以看成未来的所有状态，\np(s′∣s)p(s&#x27; \\mid s)p(s′∣s) 是指从当前状态转移到未来状态的概率。\nV(s′)V(s&#x27;)V(s′) 代表的是未来某一个状态的价值。我们从当前状态开始，有一定的概率去到未来的所有状态，所以我们要把 p(s′∣s)p(s&#x27; \\mid s)p(s′∣s) 写上去。我们得到了未来状态后，乘一个 γ\\gammaγ，这样就可以把未来的奖励打折扣。\nγ∑s′∈Sp(s′∣s)V(s′)\\gamma \\sum_{s&#x27; \\in S} p(s&#x27; \\mid s) V(s&#x27;)γ∑s′∈S​p(s′∣s)V(s′) 可以看成未来奖励的折扣总和（discounted sum of future reward）\n\n我们可以把贝尔曼方程写成矩阵的形式：\n\\\n\\begin{pmatrix}\nV(s_1) \\\nV(s_2) \\\n\\vdots \\\nV(s_N)\n\\end{pmatrix}\n\\begin{pmatrix}\nR(s_1) \\\nR(s_2) \\\n\\vdots \\\nR(s_N)\n\\end{pmatrix}\n+\n\\gamma\n\\begin{pmatrix}\np(s_1 \\mid s_1) &amp; p(s_2 \\mid s_1) &amp; \\cdots &amp; p(s_N \\mid s_1) \\\np(s_1 \\mid s_2) &amp; p(s_2 \\mid s_2) &amp; \\cdots &amp; p(s_N \\mid s_2) \\\n\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\np(s_1 \\mid s_N) &amp; p(s_2 \\mid s_N) &amp; \\cdots &amp; p(s_N \\mid s_N)\n\\end{pmatrix}\n\\begin{pmatrix}\nV(s_1) \\\nV(s_2) \\\n\\vdots \\\nV(s_N)\n\\end{pmatrix}\n\n马尔可夫决策过程\n马尔可夫决策过程满足：\np(st+1∣st,at)=p(st+1∣ht,at)p(s_{t+1}|s_t,a_t)=p(s_{t+1}|h_t,a_t)\np(st+1​∣st​,at​)=p(st+1​∣ht​,at​)\n概率代表在所有可能的动作里面怎样采取行动，比如可能有 0.7 的概率往左走，有 0.3 的概率往右走，这是一个概率的表示\n因为我们现在已知策略函数，也就是已知在每一个状态下，可能采取的动作的概率，所以我们就可以直接把动作进行加和，去掉 aa，这样我们就可以得到对于马尔可夫奖励过程的转移，这里就没有动作，即\nPπ(s′∣s)=Σπ(a∣s)p(s′∣s,a)P_\\pi(s^\\prime|s)=\\Sigma \\pi (a|s)p(s^\\prime|s,a)\nPπ​(s′∣s)=Σπ(a∣s)p(s′∣s,a)\n对于奖励函数，我们也可以把动作去掉，这样就会得到类似于马尔可夫奖励过程的奖励函数，即\nrπ(s)=Σπ(a∣s)R(s,a)r_\\pi(s)=\\Sigma \\pi(a|s)R(s,a)\nrπ​(s)=Σπ(a∣s)R(s,a)\n马尔可夫决策过程里面的状态转移与马尔可夫奖励过程以及马尔可夫过程的状态转移的差异如图 所示\n\n\n马尔可夫奖励过程的状态转移是直接决定的\n马尔可夫决策过程，中间多了一层动作aaa\n\n马尔可夫决策过程中的价值函数可定义为\nVπ(s)=Eπ[Gt∣st=s]V_\\pi(s)=E_\\pi[G_t|s_t=s]\nVπ​(s)=Eπ​[Gt​∣st​=s]\n这里我们另外引入了一个 Q 函数（Q-function）。Q 函数也被称为动作价值函数（action-value function）\nQπ(s,a)=Eπ[Gt∣st=s,at=a]Q_\\pi(s,a)=E_\\pi[G_t|s_t=s,a_t=a]\nQπ​(s,a)=Eπ​[Gt​∣st​=s,at​=a]\n这里的期望其实也是基于策略函数的。所以我们需要对策略函数进行一个加和，然后得到它的价值\nVπ(s)=Σπ(a∣s)Qπ(s,a)V_\\pi(s)=\\Sigma \\pi(a|s)Q_\\pi(s,a)\nVπ​(s)=Σπ(a∣s)Qπ​(s,a)\n备份类似于自举之间的迭代关系，对于某一个状态，它的当前价值是与它的未来价值线性相关的\n\n第一层加和是对叶子节点进行加和，往上备份一层，我们就可以把未来的价值（s′s^\\primes′的价值）备份到黑色的节点。 第二层加和是对动作进行加和，得到黑色节点的价值后，再往上备份一层，就会得到根节点的价值，即当前状态的价值\nVπ(s)=Σπ(a∣s)(R(s,a)+γΣp(s′∣s,a)Vπ(s′))V_\\pi(s)=\\Sigma \\pi(a|s)(R(s,a)+\\gamma\\Sigma p(s^\\prime|s,a)V_\\pi(s^\\prime))\nVπ​(s)=Σπ(a∣s)(R(s,a)+γΣp(s′∣s,a)Vπ​(s′))\n\n\n预测（prediction）和控制（control）是马尔可夫决策过程里面的核心问题。预测（评估一个给定的策略）的输入是马尔可夫决策过程&lt;S,A,P,R,γ&gt;&lt;S,A,P,R,\\gamma&gt;&lt;S,A,P,R,γ&gt; 和策略π\\piπ，\n输出是价值函数 VπV_\\piVπ​。预测是指给定一个马尔可夫决策过程以及一个策略π∗\\pi^*π∗ ，计算它的价值函数，也就是计算每个状态的价值。\n推荐斯坦福大学的一个网页\n最佳价值函数的定义为\nV∗(s)=max⁡Vπ(s)V^*(s)=\\max V_\\pi(s)\nV∗(s)=maxVπ​(s)\n最佳策略\nπ∗(s)=arg⁡max⁡Vπ(s)\\pi^*(s)=\\arg \\max V_\\pi(s)\nπ∗(s)=argmaxVπ​(s)\n策略迭代由两个步骤组成：策略评估和策略改进（policy improvement）\n\n","categories":["reinforcement learning"],"tags":["reinforcement learning"]},{"title":"差分隐私（二）","url":"/posts/5e047603.html","content":"\n本文将介绍差分隐私中和熵相关的概念。\n\nRenyi Entropy\n熵在密码学中有很多应用，比如说常见的香农熵和Hartley Function，它们都是由Renyi Entropy推广得到的：\nHα(X)=11−αlog(Σi=1npiα), α≥0, α≠1H_{\\alpha}(X)=\\frac{1}{1-\\alpha}log(\\Sigma_{i=1}^np_i^{\\alpha}),\\ \\alpha \\ge0,\\ \\alpha\\ne1\nHα​(X)=1−α1​log(Σi=1n​piα​), α≥0, α​=1\n至于说Renyi Entropy是如何得到其他熵的？是不同的α\\alphaα对应不同的熵\n如果将ppp看成向量，括号里的形式实际上可以被看成向量的α\\alphaα范数\nHα(X)=11−αlog(Σi=1npiα)=α1−αlog∥p∥αH_{\\alpha}(X)=\\frac{1}{1-\\alpha}log(\\Sigma_{i=1}^np_i^{\\alpha})=\\frac{\\alpha}{1-\\alpha}log\\| p \\| _{\\alpha}\nHα​(X)=1−α1​log(Σi=1n​piα​)=1−αα​log∥p∥α​\nHartley Function or max-entropy\n当α=0\\alpha=0α=0时，H0(X)H_0(X)H0​(X)实际上就是Hartley熵\nHα(X)=11−0log(Σi=1npi0)=log nH_{\\alpha}(X)=\\frac{1}{1-0}log(\\Sigma_{i=1}^np_i^{0})=log\\ n\nHα​(X)=1−01​log(Σi=1n​pi0​)=log n\n他表示的意思是：如果从有限集合A中均匀随机地选取样本，则已知结果后所揭示的信息由哈特利函数给出。\n哈特利使用了以十为底的对数，以这个底数，信息单位被称为哈特利（又名ban或dit）以纪念他。它也称为哈特利熵或最大熵。\nShannon entropy\n当α→1\\alpha \\rarr 1α→1时，H1XH_1{X}H1​X实际上就是Shannon熵\nH1(X)=lim⁡α→111−αlog(Σi=1npiα)H_1(X)=\\lim_{\\alpha \\rarr 1} \\frac{1}{1-\\alpha}log(\\Sigma_{i=1}^np_i^{\\alpha})\nH1​(X)=α→1lim​1−α1​log(Σi=1n​piα​)\nH1(X)=lim⁡α→11−1Σi=1npiαln⁡piΣi=1npiα=−Σi=1npiln⁡piH_1(X)=\\lim_{\\alpha \\rarr 1} \\frac{1}{-1} \\frac{\\Sigma_{i=1}^n p_i^{\\alpha}\\ln p_i}{\\Sigma_{i=1}^np_i^{\\alpha}}=-\\Sigma_{i=1}^n p_i \\ln p_i\nH1​(X)=α→1lim​−11​Σi=1n​piα​Σi=1n​piα​lnpi​​=−Σi=1n​pi​lnpi​\nRenyi Divergence\nDivergence并不是距离，因为不满足距离定义中的对称性，但是我们仍然可以用它来衡量两个分布之间的差距，比如常用的KL-Divergence。而和Renyi Entropy一样，Renyi Divergence也是KL-Divergence和Max-Divergence的推广。\nDα(p∥Q)=1α−1log⁡(Σi=1nqipiαqiα)D_{\\alpha}(p\\| Q)=\\frac{1}{\\alpha-1}\\log (\\Sigma_{i=1}^n q_i \\frac {p_i^{\\alpha}}{q_i^{\\alpha}})\nDα​(p∥Q)=α−11​log(Σi=1n​qi​qiα​piα​​)\nKL Divergece\n当α→1\\alpha \\rarr 1α→1\nDα(p∥Q)=1α−1log⁡(Σi=1nqipiαqiα)D_{\\alpha}(p\\| Q)=\\frac{1}{\\alpha-1}\\log (\\Sigma_{i=1}^n q_i \\frac {p_i^{\\alpha}}{q_i^{\\alpha}})\nDα​(p∥Q)=α−11​log(Σi=1n​qi​qiα​piα​​)\nD1(p∥Q)=log⁡Σi=1npipiqiD_{1}(p\\| Q)=\\log \\Sigma_{i=1}^n p_i \\frac {p_i}{q_i}\nD1​(p∥Q)=logΣi=1n​pi​qi​pi​​\nMax Divergence\n当α→∞\\alpha \\rarr \\inftyα→∞\nD∞(p∥Q)=lim⁡α→∞1α−1log⁡(Σi=1nqipiαqiα)=log⁡max⁡piqiD_{\\infty}(p\\| Q)=\\lim_{\\alpha \\rarr \\infty}\\frac{1}{\\alpha-1}\\log (\\Sigma_{i=1}^n q_i \\frac {p_i^{\\alpha}}{q_i^{\\alpha}})=\\log \\max \\frac{p_i}{q_i}\nD∞​(p∥Q)=α→∞lim​α−11​log(Σi=1n​qi​qiα​piα​​)=logmaxqi​pi​​\n3 - 差分隐私中的Divergence\n从Max-Divergence可以看到，当对这个Max-Divergence进行约束之后：\nD∞(P∥Q)=log⁡max⁡piqiD_{\\infty}(P\\| Q)=\\log \\max \\frac{p_i}{q_i}\nD∞​(P∥Q)=logmaxqi​pi​​\nPr(A(x)=t)Pr(A(x′)=t)≤exp(ε)\\frac {Pr(A(x)=t)}{Pr(A(x^\\prime)=t)} \\le exp(\\varepsilon)\nPr(A(x′)=t)Pr(A(x)=t)​≤exp(ε)\n","categories":["差分隐私"],"tags":["差分隐私"]},{"title":"承诺","url":"/posts/2de2aebf.html","content":"\n承诺\n\n承诺分为三个步骤：承诺，打开承诺，验证承诺。\n承诺：承诺:发送方将某个值xxx封装为yyy发送给接收方。(1)发送方不能修改信封中的值(绑定性);(2)接收方无法知道xxx(隐藏性)。\n打开承诺:发送方揭露xxx。\n校验承诺:接收方校验打开的值xxx与yyy中封装的xxx是否相同。\n承诺一个值\n\n承诺：选择xxx，计算y=f(x)y=f(x)y=f(x)，发送函数值yyy\n打开承诺：发送原象xxx\n校验承诺：函数一致性y=f(x)y=f(x)y=f(x)\n\n对函数有一定要求：\n\n函数求逆是 NP 困难的,需要指数时间暴力搜索。防止根据承诺值 y 计算 x。\n但是校验简单,仅需要多项式时间计算复杂度。\n该函数通常是哈希函数或 pedersen 承诺函数等。\n\n承诺一个多项式\n\n承诺：选择n+1n+1n+1个随机数a0,a1,...,ana_0,a_1,...,a_na0​,a1​,...,an​，构造多项式f(x)=Σi=0naixif(x)=\\Sigma_{i=0}^na_ix^if(x)=Σi=0n​ai​xi，计算Ai=aiG, i=0,...,nA_i=a_iG,\\ i=0,...,nAi​=ai​G, i=0,...,n，发送AiA_iAi​\n打开承诺：打开一个随机点kkk，计算f(k)=Σi=0naikif(k)=\\Sigma_{i=0}^na_ik^if(k)=Σi=0n​ai​ki，发送(k,f(k))(k,f(k))(k,f(k))\n校验承诺：基于AiA_iAi​，校验(k,f(k))(k,f(k))(k,f(k))正确性，f(k)G=Σi=0n(kiAi)f(k)G=\\Sigma_{i=0}^n(k^iA_i)f(k)G=Σi=0n​(kiAi​)\n\n如果攻击者不知道多项式,选择随机数作为函数值,则发生碰撞的概率可忽略。\n因此,不必打开多项式所有系数,仅打开一个或多个函数点即可,从而减少发送数据。\n此外,没泄露多项式,具有保密性。需要 n+1 个值,才会泄露多项式的系数。\n哈希承诺\n\n承诺：发送哈希值yyy\n打开承诺：发送原象xxx\n校验承诺：校验哈希一致性y=hash(x)y=hash(x)y=hash(x)\n\n哈希函数求逆满足NP困难\nMerkle承诺与Merkle证明\n\n\n承诺：发送rootrootroot\n\n\n打开承诺：发送叶子节点xix_ixi​和pathipath_ipathi​，其中pathipath_ipathi​是指兄弟节点\n\n\n校验承诺：校验root=Merkle(xi,pathi)root=Merkle(x_i,path_i)root=Merkle(xi​,pathi​)\n\n\n\n问题：证明方证明知道每个叶子的值xi,i0=,..,2nx_i,i0=,..,2^nxi​,i0=,..,2n\n低效做法：\n\n承诺：发送root\n打开承诺：发送所有叶子节点xix_ixi​\n校验承诺：校验root=Merkle(x0,...,x2n)root=Merkle(x_0,...,x_{2^n})root=Merkle(x0​,...,x2n​)\n\n高效做法：\n\n\n承诺：发送rootrootroot\n\n\n打开承诺：发送叶子节点xix_ixi​和pathipath_ipathi​\n\n\n校验承诺：校验root=Merkle(xi,pathi)root=Merkle(x_i,path_i)root=Merkle(xi​,pathi​)\n\n\n发送数据和校验复杂度均降低。\n如果每个叶子的取值是 0 或 1,则 n 次均成功概率为1/2n1/2^n1/2n 。\n如果每个叶子的取值空间为m,则 n 次均成功概率为1/m201/m^{20}1/m20。\n核心思想：从概率角度，不必打开全部叶子节点；仅需要打开 n 个点，如果每次都正确，则伪造成功概率指数降低。因此，验证方相信证明方知道所有叶子节点。\nSigma零知识证明中的承诺\n\n承诺A=rGA=rGA=rG，挑战eee，相应z=r+eωz=r+e\\omegaz=r+eω，校验zG=A+eQzG=A+eQzG=A+eQ\nPedersen承诺\n初始化：椭圆曲线生成元为G,H,H=αGG,H,H=\\alpha GG,H,H=αG，其中α\\alphaα保密\n\n承诺：Token数量为m和随机数为r，计算P=mG+rHP=mG+rHP=mG+rH，发送P\n打开承诺：发送m和r\n校验承诺：校验一致性P=mG+rHP=mG+rHP=mG+rH\n\nPedersen承诺的同态性\n初始状态：A和B的余额密文是0\n\nC对m1m_1m1​个Token承诺：P1=m1G+r1HP_1=m_1G+r_1HP1​=m1​G+r1​H，接收地址为AddrAliceAddr_{Alice}AddrAlice​，然后签名广播。打开承诺：私底下保密发送m1,r1m_1,r_1m1​,r1​给A，A校验Pedersen承诺的一致性，且等交易单上链后，则收款成功\nD对m2m_2m2​个Token承诺：P2=m2G+r2HP_2=m_2G+r_2HP2​=m2​G+r2​H，接收地址为AddrAliceAddr_{Alice}AddrAlice​，然后签名广播。打开承诺：私底下保密发送m2,r2m_2,r_2m2​,r2​给A，A校验Pedersen承诺的一致性，且等交易单上链后，则收款成功\n\n经过共识算法：矿工上链A余额密文：P1+P2=(m1+m2)G+(r1+r2)HP_1+P_2=(m_1+m_2)G+(r_1+r_2)HP1​+P2​=(m1​+m2​)G+(r1​+r2​)H\nA知道秘密，m1+m2m_1+m_2m1​+m2​和随机数r1+r2r_1+r_2r1​+r2​，则A能花费该费用。\n\nA对m3m_3m3​个Token承诺：P3=m3G+r3HP_3=m_3G+r_3HP3​=m3​G+r3​H，接收地址为AddrBobAddr_{Bob}AddrBob​，然后签名广播，打开承诺：私底下保密发送m3,r3m_3,r_3m3​,r3​给B，B校验Pedersen承诺的一致性，且等交易单上链后，则收款成功\n\n经过共识算法：矿工上链A和B余额密文：\nA:P1+P2−P3=(m1+m2−m3)G+(r1+r2−r3)HB:P3=m3G+r3HA:P_1+P_2-P_3=(m_1+m_2-m_3)G+(r_1+r_2-r_3)H\\\\\nB:P_3=m_3G+r_3H\nA:P1​+P2​−P3​=(m1​+m2​−m3​)G+(r1​+r2​−r3​)HB:P3​=m3​G+r3​H\n\nA知道(m1+m2−m3),(r1+r2−r3)(m_1+m_2-m_3),(r_1+r_2-r_3)(m1​+m2​−m3​),(r1​+r2​−r3​)可以继续支付\nB知道m3,r3m_3,r_3m3​,r3​也可以继续支付\n\n如果α\\alphaα泄露：\nA知道G,HG,HG,H之间的离散对数α\\alphaα，后果很严重。\n真实情况，A拥有小金额m=10m=10m=10和随机数rrr，余额承诺为P=mG+rHP=mG+rHP=mG+rH\nA能够计算α1\\alpha^{_1}α1​，选择一个大金额m′=200000m^{\\prime}=200000m′=200000，计算随机数r′=r−(m′−m)α−1r^{\\prime}=r-(m^{\\prime}-m)\\alpha^{-1}r′=r−(m′−m)α−1\n\nA支付m′m^{\\prime}m′个Token，支付承诺为P=m′G+r′HP=m^{\\prime}G+r^{\\prime}HP=m′G+r′H，接收地址为AddrBobAddr_{Bob}AddrBob​，然后签名广播，打开承诺：私底下保密发送m′,r′m^{\\prime},r^{\\prime}m′,r′给B，B校验Pedersen承诺的一致性，且等交易单上链后，则收款成功\n\n经过共识算法：矿工上链B余额密文：P=m′G+r′HP=m^{\\prime}G+r^{\\prime}HP=m′G+r′H\nm′G+r′H=m′G+(r−(m′−m)α−1)H=m′G+rH−m′α−1H+mα−1H=mG+rH=Pm^{\\prime}G+r^{\\prime}H=m^{\\prime}G+(r-(m^{\\prime-m})\\alpha^{-1})H\\\\\n=m^{\\prime}G+rH-m^{\\prime}\\alpha^{-1}H+m\\alpha^{-1}H\\\\\n=mG+rH=P\nm′G+r′H=m′G+(r−(m′−m)α−1)H=m′G+rH−m′α−1H+mα−1H=mG+rH=P\n类似结论：zcash中各个生成元gi,hig_i,h_igi​,hi​之间的离散对数不能泄露\n","categories":["密码学基础"],"tags":["密码学基础"]},{"title":"拜占庭将军问题","url":"/posts/5e173025.html","content":"拜占庭将军问题(The Byzantine Generals Problem)提供了对分布式共识问题的一种情景化描述, 由Leslie Lamport等人在1982年首次发表。\n问题描述\n拜占庭将军问题是一个协议问题，拜占庭帝国军队的将军们必须全体一致的决定是否攻击某一支敌军。问题是这些将军在地理上是分隔开来的，并且将军中存在叛徒。叛徒可以任意行动以达到以下目标：欺骗某些将军采取进攻行动；促成一个不是所有将军都同意的决定，如当将军们不希望进攻时促成进攻行动；或者迷惑某些将军，使他们无法做出决定。如果叛徒达到了这些目的之一，则任何攻击行动的结果都是注定要失败的，只有完全达成一致的努力才能获得胜利。\n内涵：在缺少可信任的中央节点和可信任的通道的情况下，分布在网络中的各个节点应如何达成共识。\n当前研究的结论是：如果叛徒的数量大于或等于1/3，拜占庭问题不可解。\n2个将军的情况\n当两个将军在攻击同一个敌人的时候，一个人被认为是领导，而另一个被认为是跟随着。单一的将军无法打败敌人，因此，两人必须要合作。\n为了两军的沟通和决定作战时间，将军1号必须要派遣一个信使穿过敌人的营地去把攻击时间告诉将军2号。但是，信使可能会被敌人抓住因而信息无法传到友军。那会导致将军1号发起攻击时，将军2号和他的军队还呆在原地。\n即使2号收到了信息，也需要派遣一个信使回去告诉1号，这可能重复被抓的情况。这样有可能无限延伸ACK，两位将军无法达成一致。\n事实上，两个将军问题已被证实无解。https://en.wikipedia.org/wiki/Two_Generals'_Problem#Proof\n4个将军的情况\n假设4个将军（ABCD）中最多只有1个背叛者。\n（1）假设A将军分别告诉B、C、D将军，下午1点发起进攻。假设B、C、D中有一人是叛徒。那么，到了下午1点，将有三个将军发起进攻，同时他们能发现发现没有参与进攻的将军是叛徒。在这种情况中，对任务执行没有影响。\n（2）假设如果A是背叛的，A分别告诉B、C、D将军在下午1点、2点、3点发起进攻。于是，到了下午，B、C、D三个将军分别去进攻，都失败了。这种情况下，对任务是毁灭性打击。\n为了防止毁灭性失败的情况，1999年，出现了著名的PBFT算法，拜占庭容错算法，提出：对于每一个收到命令的将军，都要去询问其他人，他们收到的命令是什么。\n对于第（1）种情况，假设B,C,D中只有一个叛徒（因为叛徒的数量不能大于1/3），假设B是叛徒。在A告诉B,C,D下午1点的进攻时间后，BCD中会再次有信息交互，将各自收到的信息告诉另外两人。此时不管B发出的时间是多少，C和D两人之中都会得到至少两个是1点的消息。管怎么样，C和D都能放心执行1点进攻的命令。\n对于第（2）种情况，A是背叛者的情况，在A告诉B、C、D三个不同的时间之后，B、C、D三人之间会有一次信息交互，它们会分别把自己收到的信息告诉给另外两人。\nB会收到【1点（来自A），2点（来自C），3点（来自D）】三个不同的时间\nC同样会收到三个不同的时间【1点（来自B），2点（来自A），3点（来自D）】\n以及D会收到【1点（来自B），2点（来自C），3点（来自A）】。\n此时，叛徒数量不超过1/3，可以判断A是叛徒。\n3个将军的情况\n此时叛徒数量达到1/3，3个将军A、B、C，其中一人是叛徒。假设将军A发出进攻命令“下午1点进攻”，B或C其中一人是叛徒。假设B是叛徒，他可能告诉C，他收到的是“下午两点进攻”的命令。这时C收到一个“下午一点进攻”，一个“下午两点进攻“，因此C不能判断谁是叛徒，也不能判断真正的进攻时间。 另一种情况是，如果A是叛徒，告诉B“在下午1点进攻”，告诉C“在下午2点进攻”。当B告诉C，他收到“在下午1点进攻”的命令时，C收到的是“在下午两点进攻”的命令，同样无法判断进攻的时间和真正的叛徒。 从上面的例子可以看出，在只有三个将军的系统中，只要有一个是叛徒，也即1/3，拜占庭问题便不可解。\n针对拜占庭将军问题的解决办法包括：口头协议算法，书面协议算法\n口头协议算法：要求每个被发送的消息都能被正确投递，信息接收者知道消息的发送者身份，知道缺少的消息信息。此时，若叛徒数少于1/3，则拜占庭将军问题可解。但该算法不可追根溯源。\n书面协议算法：该算法要求签名不可伪造，一旦被篡改即可发现，同时任何人都可以验证签名的可靠性。该算法没有考虑信息传输时延，其签名体系难以实现且签名消息记录的保存难以摆脱中心化结构。\n区块链的一致性\n我们可以将每一个比特币交易账号看作一个将军，这些账号分布在世界各地，无法聚在一起，很可能会有恶意账号，账号之间的沟通也很可能因为机器坏了、网络断了、黑客攻击等受到破坏，并且有关账号是不是要支付、具体支付多少的讨论也会浪费很多时间。\n为此，区块链引入POW共识算法，通过工作量证明，增加了发送信息的成本，降低节点发送消息速率，使得一次只有一个用户可以发出消息；同时在广播时会附上自己的签名。\nA向BCD发起提议，BCD看到A签名后的提议书，在验证过后，就会同意进攻提议，而不会发起自己新的进攻提议；如果其中发现错误，才会发起自己的进攻提议。\n从区块链的角度描述：当一个矿工打包出一个区块之后，其他节点会对这个区块进行验证。如果验证通过，则表明已经有节点发布新区块成功，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争。\n","categories":["区块链"],"tags":["区块链"]},{"title":"数学基础-群","url":"/posts/f40e8fb8.html","content":"\n群\n群是一个对象集合，在这个集合中任意两个对象之间定义了一种运算。\n\n群的基本定义\n定义1： 群，集合GGG和运算∘\\circ∘一起称为群(G,∘)(G,\\circ)(G,∘)，运算满足下列条件：\n\n\n∀a,b∈G,a∘b∈G\\forall a,b \\in G , a \\circ b \\in G∀a,b∈G,a∘b∈G\n\n\n∀a,b,c∈G,a∘(b∘c)=(a∘b)∘c\\forall a,b,c \\in G, a \\circ(b \\circ c)=(a \\circ b)\\circ c∀a,b,c∈G,a∘(b∘c)=(a∘b)∘c\n\n\n∃e∈G,st∀a∈G,a∘e=e∘a=a,e\\exists e \\in G, st \\forall a \\in G,a \\circ e =e \\circ a =a ,e∃e∈G,st∀a∈G,a∘e=e∘a=a,e被称为单位元\n\n\n∀a∈G,∃a−1∈G,sta∘a−1=a−1∘a\\forall a \\in G, \\exists a^{-1} \\in G, st\\quad a\\circ a^{-1}=a^{-1}\\circ a∀a∈G,∃a−1∈G,sta∘a−1=a−1∘a\n\n\n我们通常省略运算符，用GGG表示一个群\n定义2：有限群和无限群，如果集合GGG中的元素个数是有限的，那么群G就称为有限群，否则称为无限群\n**定义3：**阿贝尔群，如果对所有的 a,b∈Ga,b \\in Ga,b∈G,均有 a∘b=b∘aa\\circ b = b\\circ aa∘b=b∘a，则称群GGG为阿贝尔群\n例1 群\n\n\n整数集ZZZ在加法+下构成群，即(Z,+)(Z,+)(Z,+)是一个群，其中 e=0,a−1=−ae=0,a^{-1}=-ae=0,a−1=−a，这是一个加法群，同时还是无限群，阿贝尔群。同理，有理数集QQQ，实数集RRR和复数集CCC都是无限加法群，单位元逆元定义同上。\n\n\nQ,R,C中的非零元素在乘法下构成群，其中e=1,a−1e=1,a^{-1}e=1,a−1就是乘法逆元。\n\n\n对任意 n≥1n \\geq 1n≥1，整数模n集合构成一个包含n个元素的有限加法群，这里的加法指的是模n的假发，单位元是0，对于群中任一元素a，a−1=n−aa^{-1}=n-aa−1=n−a，我们将这个群记为ZnZ_nZn​\n\n\nZnZ_nZn​中包含所有与n互素的元素的子集构成一个有限乘法群，这里的乘法指模n乘法，e=1.我们用Zn∗Z_n^*Zn∗​表示这个群，例如(Z15∗,(mod15))=({1,2,4,7,8,11,13,14},(mod15))(Z_{15}^*,(mod15))=(\\lbrace1,2,4,7,8,11,13,14 \\rbrace,(mod15))(Z15∗​,(mod15))=({1,2,4,7,8,11,13,14},(mod15))\n\n\n定义4： G是运算∘\\circ∘下的一个群，对任一元素a∈Ga\\in Ga∈G和任一非负整数i∈Ni \\in Ni∈N,我们将下面的元素\na∘a∘...∘aa \\circ a \\circ ...\\circ a\na∘a∘...∘a\n记为 ai∈Ga^i \\in Gai∈G\n定义5： 子群 如果群GGG的非空子集HHH在与GGG同样的运算下自身构成一个群，我们就把HHH称为群GGG的一个子群，用 H⊆GH\\subseteq GH⊆G来表示H是G的一个子群，而H⊂GH\\subset GH⊂G则表示H是G的一个真子群。\n例2\n\n\n在加法运算下，Z⊆Q⊆R⊆CZ \\sube Q  \\sube R\\sube CZ⊆Q⊆R⊆C\n\n\n在加法运算下，所有偶数与0构成的集合是（1）中所有群的一个子群\n\n\n集合eee是任意群的一个子群。\n\n\n定义6： 群的阶，有限群GGG中元素的个数称为GGG的阶。例如，Zn=nZ_n=nZn​=n\n拉格朗日定理\n定义7：  陪集 ，令 GGG 是一个阿贝尔群，并且 H⊆GH \\sube GH⊆G，对于 a∈Ga \\in Ga∈G， 集合a∘H={a∘h∣h∈H}a \\circ H = \\lbrace a \\circ h|h \\in H \\rbracea∘H={a∘h∣h∈H}称为H的一个陪集\n**定理1：**若H是G的一个子群，则 #H∣#G\\#H | \\#G#H∣#G\n定义8： 商群，GGG是一个阿贝尔群，且H∈GH\\in GH∈G，则所有陪集 a∘Ha \\circ Ha∘H构成的集合，称为 GGG模HHH的商群，其中 aaa 取自于 GGG，记为 G/HG/HG/H，群定义 (a∘H)∗(b∘H)=(a∘b)∘H(a \\circ H) * (b \\circ H)= (a\\circ b)\\circ H(a∘H)∗(b∘H)=(a∘b)∘H，单位元是 e∘He \\circ He∘H\n例3：\n\n对Z12Z12Z12的每一个子群HHH，均有 #H∣#Z12\\# H | \\#Z_{12}#H∣#Z12​\nn&gt;0是一个整数，在整数加法运算下，集合nZ={0,±n,±2n...}nZ= \\lbrace 0, \\pm n, \\pm 2n... \\rbracenZ={0,±n,±2n...}显然是Z的一个子群。那么商群\n\nZ/nZ={x+nZ∣x∈Z}Z/nZ = \\lbrace x+nZ|x\\in Z\\rbrace\nZ/nZ={x+nZ∣x∈Z}\n**定义9：**群元素的阶，G为一群，且 a∈Ga\\in Ga∈G，满足 ai=ea^i = eai=e的最下正整数 i∈Ni \\in Ni∈N称为元素a的阶，记为 ord(a)ord(a)ord(a)，如果这样的整数iii不存在，则a为无限阶元\n例4：\n\nZ12Z_{12}Z12​中，ord(1)=12,ord(2)=6,ord(3)=4,ord(4)=3,ord(5)=12\n\n定义10： 循环群，群生成元，如果存在一个元素 a∈Ga\\in Ga∈G ，对任一 b∈Gb\\in Gb∈G， 都存在一个整数 i≥0i \\ge 0i≥0, 使得 b=aib=a^ib=ai，则群G称为循环群，元素 a称为 G的一个生成元，G是由a生成的群，记作 G=&lt;a&gt;G=&lt;a&gt;G=&lt;a&gt;\n例5：\n\n对于 n≥1n \\ge 1n≥1，加法群 ZnZ_nZn​是循环群，1是生成元。\n\n定理2：\n\n循环群的每一个子群均为循环群。\n对于 ord&lt;a&gt;ord&lt;a&gt;ord&lt;a&gt;的每一个正因子d，&lt;a&gt;&lt;a&gt;&lt;a&gt; 恰包含一个d阶子群。\n如果 ord&lt;a&gt;=mord &lt;a&gt; =mord&lt;a&gt;=m，那么 ord&lt;ak&gt;=m/gcd(k,m)ord&lt;a^k&gt;= m/gcd(k,m)ord&lt;ak&gt;=m/gcd(k,m)\n对 ord&lt;a&gt;ord&lt;a&gt;ord&lt;a&gt;的每一个正因子d,&lt;a&gt;&lt;a&gt;&lt;a&gt;包含 ϕ(d)\\phi(d)ϕ(d)个d阶元。\n令 ord&lt;a&gt;=mord&lt;a&gt;=mord&lt;a&gt;=m，那么&lt;a&gt;&lt;a&gt;&lt;a&gt;包含 ϕ(m)\\phi(m)ϕ(m) 个生成元，这些生成元形如 ara^rar, 其中 gcd(r,m)=1gcd(r,m)=1gcd(r,m)=1\n\n","categories":["信息安全数学基础"],"tags":["群"]},{"title":"数学基础","url":"/posts/e403a46.html","content":"\n本文介绍密码学中常用的一些符号和数学知识。\n\n标准符号\n#S\\#S#S，集合SSS中的元素数目\nFqF_qFq​，q个元素的有限域\ndesc(A)desc(A)desc(A)，代数结构A的描述\nx←Dx\\larr Dx←D，根据分布DDD进行赋值\nx←USx\\larr _USx←U​S，按SSS为均匀分布进行赋值\nord(x)ord(x)ord(x)，群元素的阶\n&lt;g&gt;&lt;g&gt;&lt;g&gt;，由g生成的循环群\n概率论和信息论\n概率论和信息论是现代密码技术发展必不可少的工具。\n现代密码系统，特别是公钥密码系统，对概率行为的要求已经达到相当苛刻的程度：语义安全性。\n概率论的基本概念\n令SSS为一个任意确定的点的集合,称之为概率空间(或样本空间)。任意元素x∈Sx\\in Sx∈S称为样点(也称为结果、简单事件或不可分事件;为了简单我们将只用点)。一个事件(也称为合成事件或可分事件)是SSS的一个子集,通常用一个大写字母表示(比如EEE)。一次实验或观察是一种从SSS中产生(取出)一个点的动作。一个事件EEE的发生就是一个试验产生某个点x∈Sx\\in Sx∈S,并满足:x∈Ex\\in Ex∈E。\n概率的经典定义\n假设一个实验可以从n=#Sn=\\# Sn=#S个等可能的点中产生一个点，并且每次实验必须产生一个点。令mmm表示事件EEE包含的点的数目，那么mn\\frac{m}{n}nm​为事件EEE发生的概率，并记为Prob[E]=mnProb[E]=\\frac{m}{n}Prob[E]=nm​\n概率的统计定义\n假设在相同条件下进行了nnn次实验，其中事件EEE发生了μ\\muμ次，如果对所有足够大的nnn，μn\\frac{\\mu}{n}nμ​保持不变，那么就是说事件EEE的概率为μn\\frac{\\mu}{n}nμ​，记为，Prob[E]≈μnProb[E]\\approx \\frac{\\mu}{n}Prob[E]≈nμ​\n随机变量及其概率分布\n在密码学中，我们主要考虑定义在离散空间上的函数。设离散空间SSS包含有限个或者可数个孤立的点x1,...,x_1,...,x1​,...,\n离散随机变量及其分布函数\n一个离散随机变量是一个实验的数字化结果。它是定义在样本空间上的函数\n设SSS为一个概率空间，ξ\\xiξ为一个随机变量。ξ\\xiξ的分布函数是S→RS\\rarr RS→R的一个函数，以一个概率值Prob[ξ=xi]=piProb[\\xi=x_i]=p_iProb[ξ=xi​]=pi​\n均匀分布\n密码学中最常用的随机变量服从均匀分布：Prob[ξ=xi]=1#SProb[\\xi=x_i]=\\frac{1}{ \\# S}Prob[ξ=xi​]=#S1​\n设SSS表示最长为kkk比特的非负数集合，依据均匀分布，从SSS中随机取出一个数，所取的数为k比特的概率是12\\frac{1}{2}21​\n二项式分布\n假定一个实验只有两个结果,记为“成功”和“失败”(例如,抛一枚硬币只有两个结果,“正面”和“反面&quot;)。独立地重复进行该实验,如果每一次实验结果仅有两种可能的点，且它们的概率在整个实验过程中保持不变,那么这样的实验就称为贝努利试验(bernoulli trials)。\n假设在任何一次试验中：Prob[Y]=p,Prob[N]=1−pProb[Y]=p,Prob[N]=1-pProb[Y]=p,Prob[N]=1−p\n那么Prob[n test,k N]=Cnkpk(1−p)n−kProb[n\\ test,k\\ N]=C_n^kp^k(1-p)^{n-k}Prob[n test,k N]=Cnk​pk(1−p)n−k\n如果随机变量ξn\\xi_nξn​取值为0，1，n，且对每一个p，0&lt;p&lt;10&lt; p&lt;10&lt;p&lt;1，有Prob[ξn=k]=Cnkpk(1−p)n−kProb[\\xi_n=k]=C_n^kp^k(1-p)^{n-k}Prob[ξn​=k]=Cnk​pk(1−p)n−k\n那么我们说ξn\\xi _nξn​服从贝努利分布\n生日悖论\n对任意函数f:X→Yf:X\\rarr Yf:X→Y，其中YYY为包含n个元素的集合，我们来解决下面的问题：\n对于一个概率界限ϵ,0&lt;ϵ&lt;1\\epsilon,0&lt;\\epsilon&lt;1ϵ,0&lt;ϵ&lt;1，找一个整数kkk，使得对于kkk个两两互异的值x1,x2,...,xk∈UXx_1,x_2,...,x_k\\in_U Xx1​,x2​,...,xk​∈U​X，kkk个函数值f(x1),f(x2),...,f(xk)f(x_1),f(x_2),...,f(x_k)f(x1​),f(x2​),...,f(xk​)对某些i≠ji\\ne ji​=j有 Prob[f(xi)=f(xj)]≥ϵProb[f(x_i)=f(x_j)]\\ge \\epsilonProb[f(xi​)=f(xj​)]≥ϵ\n即在kkk个函数值中，以不小于ϵ\\epsilonϵ的概率发生碰撞\n上述问题可以表示成：从装有nnn个不同颜色小球的袋子中去一个球，记下该球的颜色，然后放回。找到一个整数kkk，至少出现一次颜色匹配的概率为ϵ\\epsilonϵ。令yiy_iyi​表示第iii次取出的小球的颜色，第二次取出小球颜色不同的概率为1−1/n1-1/n1−1/n，以此类推，第kkk个球还未发生碰撞的概率为(1−1n)(1−2n)...(1−k−1n)(1-\\frac{1}{n})(1-\\frac{2}{n})...(1-\\frac{k-1}{n})(1−n1​)(1−n2​)...(1−nk−1​)\n当n足够大且x相对较小时1+xn=exn1+\\frac{x}{n}=e^{\\frac{x}{n}}1+nx​=enx​\n因此(1−1n)(1−2n)...(1−k−1n)=e−k(k−1)2n(1-\\frac{1}{n})(1-\\frac{2}{n})...(1-\\frac{k-1}{n})=e^{-\\frac{k(k-1)}{2n}}(1−n1​)(1−n2​)...(1−nk−1​)=e−2nk(k−1)​\n这是不碰撞的概率，因此碰撞的概率为1−e−k(k−1)2n=ϵ1-e^{-\\frac{k(k-1)}{2n}}=\\epsilon1−e−2nk(k−1)​=ϵ\n我们有k≈2nlog⁡11−ϵk\\approx \\sqrt {2n\\log \\frac{1}{1-\\epsilon}}k≈2nlog1−ϵ1​​\n考虑ϵ=1/2\\epsilon=1/2ϵ=1/2，则k=1.1774nk=1.1774\\sqrt{n}k=1.1774n​，它表示对于一个输出空间大小为nnn的随机函数，我们只需计算大约n\\sqrt nn​个函数值，就能以一个不可忽略的概率发现一个碰撞。\n如果说，我们将一组数据作为某个密码函数的原像隐藏，如果该数据的平方根不够大，那么就可以通过随即计算函数值来找出这组数据。这种攻击被称为生日攻击。它来源于：n=365,k≈22.49n=365,k\\approx22.49n=365,k≈22.49，为了以大于50%的概率从房间中找到有两个人的生日相同，在该房间中只需有23人即可。\n生日悖论的应用：指数计算的Pollard袋鼠算法\nppp为素数，f(x)=gx(mod p)f(x)=g^x(mod\\ p)f(x)=gx(mod p)是一个随机函数，对于x=1,2,..,p−1x=1,2,..,p-1x=1,2,..,p−1，函数值f(x)f(x)f(x)在整数区间[1,p−1][1,p-1][1,p−1]范围内任意变化，这个函数具有单向性。求逆十分困难。\n在某些情况下，我们知道a和b，可以计算f(a),f(a+1),...f(a),f(a+1),...f(a),f(a+1),...在穷尽b-a步之前找到x。如果b-a太大，那么这种穷搜索方法不现实。但如果b−a\\sqrt{b-a}b−a​是一个容易处理的值，那么生日悖论在b−a\\sqrt{b-a}b−a​步求f(x)f(x)f(x)中起到作用。\nPollard发现了这种方法，他称之为λ\\lambdaλ算法或袋鼠算法。\nPollard用两个袋鼠描述他的算法，一只是驯养的袋鼠TTT，另一只是野生的袋鼠WWW，已知f(x)=gx(mod p)f(x)=g^x(mod\\ p)f(x)=gx(mod p)求解x的问题可以模型化为TTT追捕WWW。这一点是通过让袋鼠沿着跳跃的方式完成的。\nS={s(0),s(1),...,s(J−1)}={20,21,...,2J−1}S=\\{s(0),s(1),...,s(J-1)\\}=\\{2^0,2^1,...,2^{J-1}\\}S={s(0),s(1),...,s(J−1)}={20,21,...,2J−1}\n袋鼠每一次跳跃的距离为SSS中随机的一个数，每只袋鼠都随身携带一个里程表来计算它跳过的总距离。\nTTT从已知点t0=gb(mod p)t_0=g^b(mod\\ p)t0​=gb(mod p)开始跳，TTT是驯服的袋鼠，它的路线为t(i+1)=t(i)gs(t(i)mod J)(mod p)t(i+1)=t(i)g^{s(t(i)mod\\ J)}(mod\\ p)t(i+1)=t(i)gs(t(i)mod J)(mod p)\n在跳了n此后，TTT携带的里程表记录着它目前跳过的距离d(n)=Σi=0ns(t(i)mod J)d(n)=\\Sigma_{i=0}^ns(t(i)mod\\ J)d(n)=Σi=0n​s(t(i)mod J)\n我们将上面的表达式重新表达为t(n)=gb+d(n−1)mod pt(n)=g^{b+d(n-1)}mod\\ pt(n)=gb+d(n−1)mod p\nWWW是野生的，它从一个未知的点w0=gxmod pw_0=g^xmod\\ pw0​=gxmod p，它的路线为w(i+1)=w(i)gs(w(i)mod J)(mod p)w(i+1)=w(i)g^{s(w(i)mod\\ J)}(mod\\ p)w(i+1)=w(i)gs(w(i)mod J)(mod p)\nWWW携带的里程表记录着它目前跳过的距离D(j)=Σk=0js(wkmod J)D(j)=\\Sigma_{k=0}^js(w_kmod\\ J)D(j)=Σk=0j​s(wk​mod J)\n我们将上面的表达式重新表达为w(i)=gx+D(i−1)mod pw(i)=g^{x+D(i-1)}mod\\ pw(i)=gx+D(i−1)mod p\n显然，它们的足迹t(i)t(i)t(i)和w(j)w(j)w(j)是两个随机函数，根据生日悖论，在TTT和WWW分别大约跳n≈b−an\\approx\\sqrt{b-a}n≈b−a​步内，发生碰撞，也就是跳在了同一个点。如果超过n≈b−an\\approx\\sqrt{b-a}n≈b−a​，那么碰撞发生的概率趋向于1.\n信息论\n香农关于消息源的熵(entropy)的定义用来衡量这个源所含信息量的多少。这个量度以源输出的所有可能的消息集上的概率分布函数形式给出。\n设L=a1,a2,...,anL={a_1,a_2,...,a_n}L=a1​,a2​,...,an​为由n个不同符号组成的语言，假设信源SSS以独立的概率Prob[a1],Prob[a2],...,Prob[an]Prob[a_1],Prob[a_2],...,Prob[a_n]Prob[a1​],Prob[a2​],...,Prob[an​]分别输出这些符号，并且满足Σi=1nProb[ai]=1\\Sigma_{i=1}^nProb[a_i]=1Σi=1n​Prob[ai​]=1\nS的熵为H(S)=Σi=1nProb[ai]log⁡2(1Prob[ai])H(S)=\\Sigma_{i=1}^nProb[a_i]\\log_2(\\frac{1}{Prob[a_i]})H(S)=Σi=1n​Prob[ai​]log2​(Prob[ai​]1​)，我们称之为“每个信源输出的比特数”\n如果SSS以概率1输出某个符号，例如a1a_1a1​，则熵函数H(S)H(S)H(S)有最小值0，这是因为H(S)=Prob[a1]log⁡2(1Prob[a1])=log⁡21=0H(S)=Prob[a_1]\\log_2(\\frac{1}{Prob[a_1]})=\\log_21=0H(S)=Prob[a1​]log2​(Prob[a1​]1​)=log2​1=0，这种情况说明，当我们确信信源SSS确定地仅输出a1a_1a1​，我们没必要浪费比特来记录它。\n","categories":["信息安全数学基础"],"tags":["数学"]},{"title":"拜占庭攻击","url":"/posts/c64cf0b7.html","content":"\n拜占庭将军问题（Byzantine Generals Problem），是由莱斯利·兰波特在其同名论文中提出的分布式对等网络通信容错问题。\n在分布式计算中，不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动。但有时候，系统中的成员计算机可能出错而发送错误的信息，用于传递信息的通讯网络也可能导致信息损坏，使得网络中不同的成员关于全体协作的策略得出不同结论，从而破坏系统一致性。\n\n\n在第t轮训练迭代中，一个诚实的参与者上传梯度：\nΔωi(t):=▽Fi(ωi(t))\\Delta \\omega _i ^{(t)}:=\\bigtriangledown F_i(\\omega_i^{(t)})\nΔωi(t)​:=▽Fi​(ωi(t)​)\n而一个恶意用户可能会上传任意值。\nΔωi(t)={∗,malicious▽Fi(ωi(t)),otherwise\\Delta \\omega _i ^{(t)}=\n\\begin {cases}\n*,malicious\\\\\n\\bigtriangledown F_i(\\omega_i^{(t)}),otherwise\n\\end {cases}\nΔωi(t)​={∗,malicious▽Fi​(ωi(t)​),otherwise​\n其中，*为任意值，Fi代表第i个用户模型的目标函数。\n目前针对联邦学习的拜占庭攻击主要分为三种模式。\n第一种攻击模式称为数据污染攻击，是通过在客户端本地数据集中加入污染过的图片使得客户端上传的模型准确度很差，进而影响全局模型。常见的数据污染攻击包括标签反转攻击（Label-flipping Attack）、基于反向梯度优化的攻击（Back-gradient optimization based attack）等等。相比于其他方式，数据污染攻击的攻击强度比较弱、攻击精度比较差，但是比较容易进行。\n第二种攻击模式称为模型污染攻击，是在模型的训练过程中以及传输过程中进行修改，不涉及对本地数据的变更，代表是局部模型污染攻击（Local Model Poisoning Attack）。模型污染攻击的攻击强度很高，并且可以进行更有针对性的攻击，但是相应的也需要对客户端更多的控制权。\n第三种攻击模式是前两种攻击的融合，比如目标模型污染（Targeted Model Poisoning）和隐式模型污染（Stealthy Model Poisoning）。第三种模式不但会修改被控制的客户端的本地数据，而且也会对模型训练过程进行影响。相比于前两种攻击方式，第三种攻击方式不但拥有较好的隐秘性而且还拥有很强的精确性。\n","categories":["AI安全"],"tags":["模型攻击"]},{"title":"数据完整性","url":"/posts/86c8c9d8.html","content":"数据完整性\n我们需要一种机制，使得到消息的接收者可以验证该消息确实是来自所声称的消息源，且在传输的过程中未受到未授权方式修改。数据完整性就是抗击对消息未授权修改的安全服务。\n定义\n数据完整性保护 设Data为任意信息，KeKeKe未编码密钥，KvKvKv为与该编码密钥相匹配的验证密钥。Data的数据完整性保护如下：检测码的生成：MDC←f(Ke,Data)MDC\\larr f(Ke,Data)MDC←f(Ke,Data)\n检测码的验证：\nG(Kv,Data,MDC)={True,MDC=f(Ke,Data)False,MDC≠f(Ke,Data)G(Kv,Data,MDC)=\n\\begin {cases}\nTrue,MDC=f(Ke,Data) \\\\\nFalse ,MDC≠f(Ke,Data)\n\\end {cases}\nG(Kv,Data,MDC)={True,MDC=f(Ke,Data)False,MDC​=f(Ke,Data)​\n其中f和g都是有效的密码变换：前者由一个辅助输入Ke参数化，后者由任意输入Kv参数化、\n对称技术\n在实现数据完整性的对称技术中，密码变换f和g是对称密码算法，这意味着f=g,Ke=Kvf=g,Ke=Kvf=g,Ke=Kv。\n密码杂凑函数\n实现MAC通常的方法时使用密钥杂凑函数技术。\n杂凑函数是一个确定的函数，它将任意长的比特串映射为定长比特串的杂凑值。设hhh为一个杂凑函数，其固定的输出长度用∣h∣\\vert h \\vert∣h∣，它有以下的性质：\n\n\n混合变换，对于任意的输入xxx，输出的杂凑值h(x)h(x)h(x)应当和区间[0,2∣h∣][0,2^{\\vert h \\vert}][0,2∣h∣]中均匀的二进制串在计算上是不可区分的。\n\n\n抗碰撞攻击，输入x,y,x≠yx,y,x≠yx,y,x​=y，使得h(x)=h(y)h(x)=h(y)h(x)=h(y)在计算上应当是不可行的。\n\n\n抗原像攻击，已知一个杂凑值hhh，找一个输入串xxx，使得h=h(x)h=h(x)h=h(x)，在计算上是不可行的。\n\n\n实用有效性，给定一个输入串xxx，h(x)h(x)h(x)的计算可以在关于xxx的长度规模的低阶多项式时间内完成。\n\n\n杂凑函数在密码学中的应用\n"},{"title":"数论基础","url":"/posts/d1fe2c48.html","content":"\n同余和剩余类\n对于整数n&gt;1n&gt;1n&gt;1，同余关系（模n）具有自反性，对称性和传递性，即对任意的a,b,c∈Za,b,c\\in Za,b,c∈Z，有：\n\n\na≡a(mod n)a \\equiv a ( mod\\ n)a≡a(mod n)\n\n\nif a≡b(mod n)a\\equiv b (mod\\ n)a≡b(mod n), then b≡a(mod n)b \\equiv a (mod\\ n)b≡a(mod n)\n\n\nif a≡b(mod n),b≡c(mod n)a\\equiv b (mod\\ n), b\\equiv c (mod\\ n)a≡b(mod n),b≡c(mod n), then a≡c(mod n)a\\equiv c (mod\\ n)a≡c(mod n)\n\n\n一个集合上的等价关系把这个集合分成若干个等价类。这个关系定义在集合Z上，因此它把Z恰好分成n个等价类，每个类包含与某整数模n同余的所有整数。可以表示为：\na={x∈Z∣x(mod n)≡a}a = \\{x\\in Z| x(mod\\ n )\\equiv a\\}\na={x∈Z∣x(mod n)≡a}\n我们将上面每一个集合称为一个模n剩余类。显然，我们可以把ZnZ_nZn​看做：\nZn={0,1,...,n−1}Z_n = \\{0,1,...,n-1\\}Zn​={0,1,...,n−1}\n如果把Z看作是Z的一个平凡子集，陪集nZnZnZ是所有n的倍数的整数集合，即：\nnZ={0,±n,...}nZ=\\{0,\\plusmn n,... \\}\nnZ={0,±n,...}\n群运算为加法运算的商群：\nZ/nZ={x+nZ∣x∈Z}Z/nZ = \\{x+nZ|x\\in Z\\}\nZ/nZ={x+nZ∣x∈Z}\nZnZ_nZn​中运算的同余性质\n对任意的整数n&gt;1n&gt;1n&gt;1，if a\\equiv b (mod\\ n) \\and c\\equiv d (mod\\ n), then a±c≡b±d(mod n)a \\plusmn c \\equiv b \\plusmn d (mod\\ n)a±c≡b±d(mod n), ac≡bd(mod n)ac \\equiv bd (mod\\ n)ac≡bd(mod n)\n假设整数n&gt;1,d≠0n&gt;1,d\\neq 0n&gt;1,d​=0, if ad≡bd(mod n)ad\\equiv bd (mod\\ n)ad≡bd(mod n), then a≡b(mod ngcd⁡(d,n))a\\equiv b (mod\\ \\frac{n}{\\gcd(d,n)})a≡b(mod gcd(d,n)n​)\n如果f(x)f(x)f(x)是整数集Z上的一个多项式，并且a≡b(mod n)a\\equiv b (mod\\ n)a≡b(mod n)，其中整数n&gt;1n&gt;1n&gt;1，则f(a)≡f(b)(mod n)f(a)\\equiv f(b) (mod\\ n)f(a)≡f(b)(mod n)\n求解ZnZ_nZn​中的线性同余式\n假设整数n&gt;1n&gt;1n&gt;1，同余式ax≡b(mod n)ax \\equiv b(mod \\ n)ax≡b(mod n)可解当且仅当gcd(a,n)∣bgcd(a,n)|bgcd(a,n)∣b\n中国剩余定理\n设正整数m1,m2,...,mkm_1, m_2, ...,m_km1​,m2​,...,mk​两两互素，则：\nx≡ai(mod  mi)x \\equiv a_i (\\mod m_i)x≡ai​(modmi​)方程组的解为：\nx≡ΣaiMiMi−1(mod  M)x \\equiv \\Sigma a_i M_i M_i ^{-1} (\\mod M)x≡Σai​Mi​Mi−1​(modM)\n其中M=m1m2...mk,Mi=M/miM= m_1 m_2...m_k, M_i = M/m_iM=m1​m2​...mk​,Mi​=M/mi​\n欧拉函数\n设ϕ(n)\\phi(n)ϕ(n)是一个欧拉函数，则：\nϕ(1)=1\\phi (1) =1ϕ(1)=1, 如果p是素数，则ϕ(p)p−1\\phi(p) p-1ϕ(p)p−1\n欧拉ϕ\\phiϕ函数是积性函数，如果gcd(m,n)=1gcd(m,n)=1gcd(m,n)=1，则ϕ(mn)=ϕ(m)ϕ(n)\\phi(mn)=\\phi(m)\\phi(n)ϕ(mn)=ϕ(m)ϕ(n)\n如果n=p1e1p2e2...pkekn=p_1^{e_1}p_2^{e_2}...p_k^{e_k}n=p1e1​​p2e2​​...pkek​​的素分解，则ϕ(n)=n(1−1p1)(1−1p2)...(1−1pk)\\phi(n) = n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})...({1-\\frac{1}{p_k}})ϕ(n)=n(1−p1​1​)(1−p2​1​)...(1−pk​1​)\n费马小定理：如果p是素数，则ap−1≡1(mod  p),ap≡a(mod  p)a^{p-1} \\equiv 1 (\\mod p), a^p\\equiv a(\\mod p)ap−1≡1(modp),ap≡a(modp)\n数学归纳法的证明：\na=1a=1a=1,显然\n假设p∣(ap−a)p | (a^p-a)p∣(ap−a),考虑(a+1)p−(a+1)=Σk=0pCpkak−a−1=Σk=1p−1Cpkak+(ap−a)(a+1)^p-(a+1)= \\Sigma_{k=0}^p C_p^ka^k-a-1=\\Sigma_{k=1}^{p-1} C_p^ka^k+(a^p-a)(a+1)p−(a+1)=Σk=0p​Cpk​ak−a−1=Σk=1p−1​Cpk​ak+(ap−a)\n由于Cpk=p!k!(p−k)!C_p^k =\\frac{p!}{k!(p-k)!}Cpk​=k!(p−k)!p!​，且p为质数，因此p∣Cpkp|C_p^kp∣Cpk​，即p∣Σk=1p−1Cpk,p∣(ap−a)p|\\Sigma_{k=1}^{p-1}C_p^k,p|(a^p-a)p∣Σk=1p−1​Cpk​,p∣(ap−a)，从而p∣(a+1)p−(a+1)p|(a+1)^p-(a+1)p∣(a+1)p−(a+1)\n欧拉定理：如果gcd(a,n)=1gcd (a,n) =1gcd(a,n)=1，则aϕ(n)≡1(mod  n)a^{\\phi(n)}\\equiv 1(\\mod n)aϕ(n)≡1(modn)\n","categories":["密码学基础"],"tags":["密码学基础"]},{"title":"格","url":"/posts/3efe364e.html","content":"\n格密码学\nLattice-based cryptography，格密码学，是一种基于格（lattice）的密码学算法，目前是后量子密码学的重要候选方案，与 RSA、Diffie-Hellman 或椭圆曲线密码系统等更广泛使用和众所周知的公钥方案（理论上可以在量子计算机上使用肖尔算法击败这些方案）不同，一些基于格的构造似乎既能抵御经典计算机的攻击，也能抵御量子计算机的攻击。\n\n关于格\n传统公钥密码学的安全，往往建立在数学问题的困难性上，RSA基于大整数分解的困难性，Elgamal，ECC基于有限域上离散对数求解的困难性，这些难题均可使用量子计算机并应用秀尔算法破解。虽然大型量子计算机尚未普及，但是后量子密码学已经成为人们关注的焦点。格密码学是后量子密码学的代表之一。\n格，是一种类似向量空间的数学空间，实数空间RRR上的向量空间VVV,是一些向量的集合，任意两个向量可以相加，任意一个向量可以和一个实数相乘，运算具有封闭性。在lattice中，与向量空间有所区别，具体来说，就是乘法中的乘数，从实数改为整数。如下图，是几种不同的格空间。\n\n数学表示，给定nnn维实数空间RnR^nRn中的一组线性无关向量B={b1,...,bn}⊂RnB=\\{b_1,...,b_n\\}\\subset R^nB={b1​,...,bn​}⊂Rn，其整数系数线性组合构成的集合被称为格（Lattice），即L=Σi=1nbi⋅Z=Bx,x∈ZnL=\\Sigma_{i=1}^nb_i \\cdot Z={Bx,x\\in Z^n}L=Σi=1n​bi​⋅Z=Bx,x∈Zn其中B={b1,...,bn}B=\\{b_1,...,b_n\\}B={b1​,...,bn​}被称为格基。同一个格可能有不同的格基。\n某种程度上，格可以理解成系数为整数的向量空间。\n与格相关的基本计算性难题：\n1.SVP: Shortest Vector Problem （在格中寻找最短的非零向量）\n最短向量问题(SVP):在格LLL中寻找一个最短的非零向量，即寻找一个非零向量v∈Lv\\in Lv∈L,使它的欧几里得范数∣∣v∣∣\\vert \\vert v\\vert \\vert∣∣v∣∣最小。\n2.CVP: Closet Vector Problem（在格中寻找与指定非格向量最为接近的向量）\n最近向量问题(CVP):给定一个不在格LLL中的向量ω∈Rm\\omega \\in R^mω∈Rm ，寻找一个向量v∈Lv \\in Lv∈L，使它最接近ω\\omegaω，即寻找一个向量v∈Lv\\in Lv∈L，使欧几里得范数∣∣ω−v∣∣\\vert \\vert \\omega - v\\vert\\vert∣∣ω−v∣∣最小。\n","categories":["同态加密"],"tags":["格密码学"]},{"title":"智能设备配对","url":"/posts/642886bd.html","content":"我们分别从熵源和所使用的加密基元两个方面来讨论智能物联网设备配对。\n熵源\n考虑到熵源，目前人们最感兴趣的是加速和声音。\n基于加速度的配对使用移动设备上的加速度传感器来检测两个设备之间的物理接触。有一些方案提出提取步态中的加速度作为上下文。步态是利用人体运动时的姿势和动作特征记录下来的。还有一些方案提出利用人体运动提取有效指纹，这些方案通常在可穿戴设备上实现。还有一些方案提出利用运动过程中的加速度（例如汽车内部环境）提取有效熵，有文章已经成功地在道路上行驶的汽车内通过传感器融合实现了设备配对。然而，这些方案要求设备处于移动环境中，这对配对条件的要求很高。\n\n声音在生活中无处不在，大多数智能设备都配备了麦克风和话筒，从而具备了播放和录制声音的能力。一些方案关注环境中的噪声并提取指纹序列，等方案提出录制自然噪声进行匹配，但环境声音的随机性在实际过程中带来了较长的匹配时间。随后，提出通过在法定边界内添加额外声源来增强环境声音，并给出了一种基于时域的音频指纹提取方法。近年来，也有人提出在智能家居环境中通过人声来实现智能设备的配对。提出麦克风可以很好地识别人声，并提到了人声的特征。\n\n加密原语\n在以往的工作中，设备配对方案依赖于模糊承诺加密原语，在于从有限个正确点中恢复密钥。\n具体来说，设备 Di{D_i}Di​ 选择密钥 KKK 和指纹 fff，发送承诺 c←ECC.encode(K)⊕fc \\xleftarrow{} ECC.encode(K) \\oplus fc​ECC.encode(K)⊕f 给 D1−i{D_{1-i}}D1−i​。当指纹错误在纠错码（ECC）的纠错能力范围内时，D1−iD_{1-i}D1−i​ 就能通过 K←.ECC.decode(c⊕f′)K \\xleftarrow{}.ECC.decode(c\\oplus f^\\prime)K​.ECC.decode(c⊕f′) 恢复密钥。提出了一种基于fPAKE协议的多传感器融合配对方案，在方案执行初期，需要重复运行PAKE至少fff次，以放大指纹位熵，实现fi→Kif_i\\xrightarrow{}K_ifi​​Ki​ 并发送承诺 com←ECC.encode(s)oplusKicom \\xleftarrow{} ECC.encode(s)oplus K_icom​ECC.encode(s)oplusKi​。但这在初始阶段会耗费大量时间。\n\n为了克服这个缺点，FS2M 使用了一种叫做非对称模糊封装机制（Asymmetric Fuzzy Encapsulation Mechanism）的加密原语，并给出了一种基于椭圆曲线加密法（Elliptic Curve Cryptography）的方法。我们的协议发送一个模糊承诺 Enc(Keygen(ski),s)→cEnc(Keygen(sk_i),s) \\xrightarrow{} cEnc(Keygen(ski​),s)​c，持有相似指纹 f1−i(sk1−i)f_{1-i}(sk_{1-i})f1−i​(sk1−i​) 的设备能够通过 Dec(Keygen(sk1−i),c)→sDec(Keygen(sk_{1-i}),c) \\xrightarrow{} sDec(Keygen(sk1−i​),c)​s 正确解密这个承诺。这种应用于设备配对的协议是单轮高效且安全的。\n","categories":["iot"],"tags":["iot"]},{"title":"横向联邦学习","url":"/posts/86cff816.html","content":"\n\n横向联邦学习的定义\n横向联邦学习也称为按样本划分的联邦学习（Sample-Partitioned Federated Learning 或 Example-Partitioned Federated Learning），可以应用于联邦学习的各个参与方的数据集有相同的特征空间和不同的样本空间的场景，类似于在表格视图中对数据进行水平划分的情况。事实上，横向一词来源于术语 横向划分（horizontal partition）。“横向划分” 广泛用于传统的以表格形式展示数据库记录内容的场景，例如表格中的记录按照行被横向划分为不同的组，且每行都包含完整的数据特征。我们将横向联邦学习的条件总结为：\nxi=xj,yi=yj,Ii≠Ij,∀Di,Dj,i≠jx_i=x_j,y_i=y_j,I_i\\ne I_j,\\forall D_i,D_j,i\\ne j\nxi​=xj​,yi​=yj​,Ii​​=Ij​,∀Di​,Dj​,i​=j\nDi,DjD_i,D_jDi​,Dj​表示第i方和第j方拥有的数据集。我们假设两方的数据特征空间和标签空间对，即(xi,yi),(xj,yj)(x_i,y_i),(x_j,y_j)(xi​,yi​),(xj​,yj​)是相同的。但是我们假设两方的客户ID空间，即Ii,IjI_i,I_jIi​,Ij​没有交集或交际很小。\n横向联邦学习的安全性\n关于横向联邦学习系统的安全性的定义，我们通常假设一个横向联邦学习系统的参与方都是诚实的，需要防范的对象是一个诚实但好奇 （honest-but-curious）的聚合服务器。即通常假设只有服务器才能使得数据参与方的隐私安全受到威胁。\n横向联邦学习架构\n客户-服务器架构\n客户-服务器架构也被称为主-从（master-worker）架构或者轮辐式（hub-and-spoke）架构。在这种系统中，具有同样数据结构的 K 个参与方（也叫作客户或用户）在服务器（也叫作参数服务器或者聚合服务器）的帮助下，协作地训练一个机器学习模型。横向联邦学习系统的训练过程通常由如下四步组成：\n\n各参与方在本地计算模型梯度，并使用同态加密、差分隐私或秘密共享等加密技术，对梯度信息进行掩饰，并将掩饰后的结果（简称为加密梯度） 发送给聚合服务器。\n服务器进行安全聚合（secure aggregation）操作，如使用基于同态加密的加权平均。\n服务器将聚合后的结果发送给各参与方。\n各参与方对收到的梯度进行解密，并使用解密后的梯度结果更新各自的模型参数。\n\n\n图一：横向联邦学习的客户-服务器架构\n上述步骤将会持续迭代进行，直到损失函数收敛达到允许的迭代次数的上限或训练时间，这种架构独立于特定的机器学习算法，并且所有参与方将会共享最终的模型参数。\n值得注意的是，如果发送的是梯度信息，再将梯度信息聚合，再将聚合好的结果发送各参与方，这称为梯度平均。除了共享梯度信息，联邦学习的参与方还可以共享模型的参数。\n对等网络架构\n除了上面讨论的客户-服务器架构，横向联邦学习系统也能够利用对等网络架构。在该框架下，不存在中央服务器或 者协调方。在这种架构中，横向联邦学习系统的 K 个参与方也被称为训练方（trainer）或分布式训练方。每一个训练方负责只使用本地数据来训练同一个机器学习模型（如DNN模型）。此外，训练方们使用安全链路（channels）在相互之间传输模型参数信息。为了保证任意两方之间的通信安全，需要使用例如基于公共密钥的加密方法等安全措施。\n\n图二：横向联邦学习的对等网络架构\n由于对等网络架构中不存在中央服务器，训练方们必须提前商定发送和接收模型参数信息的顺序。\n全局模型评估\n在横向联邦学习中，模型训练和评估是在每个参与方中分布地执行的，并且任意方都不能获取其他方的数据集。在这里，本地模型性能表示某一参与方在本地测试数据集上检验得出的横向联邦学习模型的性能，全局模型性能表示所有参与方在本地测试数据集上检验得出的横向联邦学习模型的性能。模型性能可以表现为精确度（precision），准确度（accuracy）和召回率（recall）。\n我们以一个二分类模型作为例子，能够根据以下步骤得到全局模型性能：\n\n对于二分类任务，第k个参与方会生成本地模型测试结果NTP(k),NFP(k),NTN(k),NFN(k)N_{TP}^{(k)},N_{FP}^{(k)},N_{TN}^{(k)},N_{FN}^{(k)}NTP(k)​,NFP(k)​,NTN(k)​,NFN(k)​，分别表示真阳性，假阳性，真阴性，假阴性。参与方k=1,2,...,Kk=1,2,...,Kk=1,2,...,K都执行此操作。\n第k个参与方给协调方发送本地模型预测结果NTP(k),NFP(k),NTN(k),NFN(k)N_{TP}^{(k)},N_{FP}^{(k)},N_{TN}^{(k)},N_{FN}^{(k)}NTP(k)​,NFP(k)​,NTN(k)​,NFN(k)​。参与方k=1,2,...,Kk=1,2,...,Kk=1,2,...,K都执行此操作。\n在收集K个参与方的本地模型测试结果NTP(k),NFP(k),NTN(k),NFN(k)N_{TP}^{(k)},N_{FP}^{(k)},N_{TN}^{(k)},N_{FN}^{(k)}NTP(k)​,NFP(k)​,NTN(k)​,NFN(k)​，协调方能够计算全局模型性能测试结果。例如，对于二分类任务，全局召回率通过Σk=1KNTP(k)Σk=1K(NTP(k)+NFN(k))\\frac{\\Sigma_{k=1}^KN_{TP}^{(k)}}{\\Sigma_{k=1}^K(N_{TP}^{(k)}+N_{FN}^{(k)})}Σk=1K​(NTP(k)​+NFN(k)​)Σk=1K​NTP(k)​​\n协调方将计算得到的全局模型的性能发送给所有的参与方。\n\n联邦平均算法介绍\n","categories":["联邦学习"],"tags":["联邦学习"]},{"title":"比特安全性","url":"/posts/cc63f144.html","content":"比特安全性\n关于基本的和通用的公钥密码函数比特安全性的实际结果意味着，只要明文消息是随机的，那么恢复有关明文的任何消息的问题就同这些基本函数求逆一样困难，这是因为后者是恢复整个明文消息的问题。\nRSA比特\n如果一条RSA密文是对不包含事前可猜测的信息进行的加密，那么从密文中提取一比特的明文信息就同提取整个明文组一样困难。\n"},{"title":"环和域","url":"/posts/3c8c316a.html","content":"\n环和域\n定义1： 环（Ring）\n\n一个同时有两种运算：加法和乘法的集合，如果满足如下性质，就称为环R：\n\nR在加法+下是一个阿贝尔群，加法单位元记作0（称为零元）\nR在乘法 ⋅\\cdot⋅ 下满足封闭律，结合律和单位元律，乘法单位元记作1\n∀a,b∈R,a⋅b=b⋅a\\forall a, b \\in R, a \\cdot b =b \\cdot a∀a,b∈R,a⋅b=b⋅a\n∀a,b,c∈R,a⋅(b+c)=a⋅b+a⋅c\\forall a,b,c \\in R, a \\cdot (b+c) = a \\cdot b +a \\cdot c∀a,b,c∈R,a⋅(b+c)=a⋅b+a⋅c\n\n如果乘法还满足交换律，则是一个交换环。\n例1：\n\n在通常的加法和乘法运算下， Z,Q,R和C均是环\n对 n&gt;0， 在模n加法和模n乘法运算下，ZnZ_nZn​是一个环\n\n定义2： 域（Field）\n如果一个环中的非零元在乘法运算下构成群，则该环就称为域。\n域中乘法群（即非零元）满足封闭律，这表明域FFF不含零因子，即对任意的a,b∈F,ab=0a,b\\in F,ab=0a,b∈F,ab=0可推出a=0或b=0\n例2：\n\n在通常的加法和乘法运算下，QRC均是域。\n\n定义3： 一个代数结构如果包含有限个元素，就说该代数结构是有限的，元素的个数称为这个结构的阶。\n如果一个代数结构A的一个非空子集S在A的运算下自身成为一个代数结构，那么S就称为代数结构A的子结构。\n有限域的结构\n有限域在密码学和密码协议中有着广泛的应用。现在我们对有限域的结构进行一下完整的讨论。\n含有素数个元素的有限域\n最简单结构的有限域就是阶为素数的有限域，然而这样的域在密码学中的应用却最广泛。\n素域：不含真子域的域称为素域\n例如，Q为素域，由于Q为R的真子域，所以R不是素域，Q是一个无限域。\n同态和同构：令A，B是两个代数结构，如果映射f:A→Bf:A\\rightarrow Bf:A→B保持A的运算，即如果⋅\\cdot⋅是A的运算，∗*∗是B中的运算，那么$\\forall x,y \\in A, f(x\\cdot y)=f(x)*f(y) $，则该映射就称为A到B的同台。如果f是A到B上的一一同台，那么f就称为一个同构，我们就说A和B是同构的。\n如果f:A→Bf: A\\rightarrow Bf:A→B 十一个同态，且e是A中的一个单位元（加法的或乘法的），那么f(e)∗f(e)=f(e⋅e)=f(e)f(e)*f(e)=f(e\\cdot e)=f(e)f(e)∗f(e)=f(e⋅e)=f(e)\n举例：同构的代数结构：\n对于任意素数p，函数f(x)=gx(modp)f(x)=g^x(mod p)f(x)=gx(modp)是加法群Zp−1Z_{p-1}Zp−1​和乘法群Zp∗Z_p^*Zp∗​之间的同构映射，因此这两个群是同构的。\n域FpF_pFp​，令p为一个素数，有限域ZpZ_pZp​记为FpF_pFp​\n代数结构的特征：A是一个代数结构，对每一个a∈Aa\\in Aa∈A，满足 na=0na =0na=0的最小正整数n称为A的特征，记为char(A)char(A)char(A)，如果正整数n不存在，就说AAA的特征为0。每一个有限域的特征均为素数。\n","categories":["信息安全数学基础"],"tags":["环和域"]},{"title":"浙大暑期课程","url":"/posts/e97ac66e.html","content":"Provable Security Basics\nModern Cryptography:\n\nConfidentiality\nIntegrity\nAuthentication\n\nProvable Security:\n\nPrecisely specify threat model\nPropose a construction\nWrite a formal proof(reduction)\n\nOne-way function:\nf(x) is polynomial-time computable for all x\nFor all PPT algorithm A\\mathcal{A}A\nPr[InvertA,f(n)=1]≤ϵ(n)Pr[Invert_{\\mathcal{A},f}(n)=1]\\le \\epsilon(n)Pr[InvertA,f​(n)=1]≤ϵ(n)\nDiscrete Logarithm Problem\nLet G\\mathcal{G}G be a neneric, polynomial-time, group generation algorithm\nInput 1n1^n1n, output G,q,g∈GG,q,g\\in GG,q,g∈G\nDLogA,G(n)DLog_{\\mathcal{A,G}}(n)DLogA,G​(n)\n1.Generate (G,q,g)←G(1n)(G,q,g)\\leftarrow \\mathcal{G}(1^n)(G,q,g)←G(1n)\n2.Choose a uniform h←Gh\\leftarrow Gh←G\n3.Obtain x←A(G,q,g,h)x\\leftarrow \\mathcal{A}(G,q,g,h)x←A(G,q,g,h)\n4.Return 1 iff gx=hg^x=hgx=h\nCDH vs DL\nTheorem: if the CDH problem is hard relative to G\\mathcal{G}G then discrete logarithm problem is also hard relative to G\\mathcal{G}G\n\nMPC\n安全多方计算\n安全多方计算的分类\n\n2-move Two-party Computation\n\nEncode a by using pk\nCompute f(a,b) over encoded inputs\nDecode c by using sk, botain f(a,b)\n\nElgamal is IND-CPA Secure\nIf the DDH problem is hard relative to G\\mathcal{G}G,then the Elgamal encryption scheme is IND-CPA secure\n","categories":["密码学基础"],"tags":["密码学基础"]},{"title":"盲签名","url":"/posts/4e6420da.html","content":"\n盲签名\n随着互联网的普及，为在线支付营造了丰沃的土壤，支付宝、微信支付与各大银行App纷纷登上在线支付的头把交椅。有的人甚至说“只需要一部手机就可以走遍天下”。但是，在线支付虽然便捷且交易的是一串数字但并不是电子现金，在线支付并不具备匿名性，容易追踪到某笔交易金额的来源和购买的商品，而电子现金具备匿名性，无法追踪电子现金来源。其中技术用到了假名、零知识证明、环签名、盲签名等等。\n\n电子现金\n电子现金(Electronic Cash)其实是一种用电子形式模拟现金的技术。电子现金系统企图在多方面为在线交易复制现金的特性：方便、费用低（或者没有交易费用）。不记名以及其他性质。但不是所有的电子现金系统都满足这些特点，多数电子现金系统都能为小额在线交易提供快捷与方便。\n电子现金优于真实现金之处在于它安全、超距、迅速、低成本、匿名性、精确性等，这大大强化了现金的可移动性。电子现金通过信息网络系统和公共信息平台实现流通、存取、支付。在电子现金的支付中有三方参与：银行、用户、商家。\n电子现金在线交易一般需要以下三个基本阶段：\n**取款阶段：**用户从自己的银行账户上提取数字现金\n**支付阶段：**用户使用数字现金从商店中购买商品\n**存款阶段：**用户及商家将数字现金存入到自己的银行账户上\n在电子现金支付和使用的过程中，为了保护用户购买商品、服务时的隐私，接收方不应获得支付方的任何身份信息。\n盲签名可以实现银行向合法用户发放有效的电子现金，使用户可以使用有效的电子现金进行交易，银行本身也无法通过电子现金追踪到该电子现金是属于哪个用户的。\n盲签名的概念\n盲签名的概念首先由 David Chaum 于1982年提出，盲签名实现了签名者对发送者的消息进行签名，却不能知道签名者消息的具体内容。\n相当于将文件放入信封，签名者在信封上对文件进行签名，而不知道具体的文件内容。\n性质\n\n不可伪造性，除了签名者本人外，任何人不能以他的名义生成有效的盲签名\n不可抵赖性，签名者一旦签署了某个消息，他无法否认自己对消息的签名\n盲性，签名者虽然对某个消息进行了签名，但他不可能得到消息的具体内容。\n不可跟踪性，一旦消息的签名公开后，签名者不能确定自己何时签署的这条消息。\n\n模型\n\n接收者首先将待签数据进行盲变换，把变换后的盲数据发给签名者。\n经签名者签名后再发给接收者。\n接收者对签名再作去盲变换，得出的便是签名者对原数据的盲签名。\n\n\n基于RSA的盲签名\n假设A是接收者，B是签名者，私钥ddd，公开RSA公钥(n,e)(n,e)(n,e)，A让B盲签名消息mmm\n\n\n选取盲引子rrr，计算m′=m∗re mod nm^{\\prime}=m*r^e\\ mod\\ nm′=m∗re mod n\n\n\nB对m′m^{\\prime}m′进行签名m′d=(m∗re)d mod nm^{\\prime d}=(m*r^e)^d\\ mod\\ nm′d=(m∗re)d mod n\n\n\nA去盲得到原始签名 s=m′d∗r−1=(m∗re)d∗r−1 mod n=md∗red∗r−1 mod n=md mod ns=m^{\\prime d} * r^{-1}=(m*r^e)^d*r^{-1}\\ mod\\ n=m^d*r^{ed}*r^{-1}\\ mod\\ n=m^d\\ mod\\ ns=m′d∗r−1=(m∗re)d∗r−1 mod n=md∗red∗r−1 mod n=md mod n\n\n\n正确性容易证明\njava测试代码如下：\nimport java.math.BigInteger;/** * 盲签名相关 * Created by forest on 2017/5/23. */public class blindSignature &#123;    public static void main(String[] args)&#123;        System.out.println(&quot;这里是盲签名测试&quot;);        BigInteger e = new BigInteger(&quot;32663&quot;);        BigInteger d = new BigInteger(&quot;23&quot;);        BigInteger n = new BigInteger(&quot;42167&quot;);        BigInteger m = new BigInteger(&quot;123&quot;);       //签名的消息        BigInteger factor = new BigInteger(&quot;37&quot;);   //盲因子        BigInteger blindMsg = blindHideMsg(m, factor, e, n);        BigInteger blindSig = blindSignature(blindMsg, d, n);        BigInteger sig = blindRetriveSig(blindSig, factor, n);        System.out.println(&quot;盲签名 = &quot; + sig);        BigInteger realSig = m.modPow(d, n);        System.out.println(&quot;原签名 = &quot; + realSig);    &#125;    /**盲签名-盲化*/    public static BigInteger blindHideMsg(BigInteger msg, BigInteger factor, BigInteger e, BigInteger n)&#123;        BigInteger hideMsg = msg.multiply(factor.modPow(e, n)).mod(n);        return hideMsg;    &#125;    /**盲签名-签名*/    public static BigInteger blindSignature(BigInteger blindMsg, BigInteger d, BigInteger n)&#123;        BigInteger blindSig = blindMsg.modPow(d, n);        return blindSig;    &#125;/**盲签名-解盲得到签名*/    public static BigInteger blindRetriveSig(BigInteger blindSig, BigInteger factor, BigInteger n)&#123;        BigInteger signature = blindSig.multiply(factor.modInverse(n)).mod(n);        return signature;    &#125;\n盲签名在区块链中的应用\n区块链系统中地址是由用户自行生成，与用户的身份信息无关，用户创建和使用地址不需要第三方参与。因此，区块链地址具有较好的匿名性。\n但是区块链交易之间的关联性可以被用于推测敏感信息。区块链所有数据都存储在公开的全局账本中，通过分析这些交易之间的关联关系(比如：同一交易的所有输入地址属于同一用户集合、找零地址和输入地址属于同一用户等等)，再结合一些背景知识，能够逐步降低区块链地址的匿名性，甚至发现匿名地址对应用户的真实身份。\n因此，在区块链网络中，为了保护隐私信息，出现了一些隐私保护机制，其中Blindcoin协议是其中一种中心化混币技术，是一个基于盲签名技术的隐藏机制。\n\n如上图所示，Blindcoin协议是在Mixcoin 协议基础上，通过盲签名技术，使得混币用户的输入输出地址映射关系对混币服务商M不可见。\n","categories":["密码学基础"],"tags":["盲签名"]},{"title":"群上的离散对数问题","url":"/posts/703ad939.html","content":"\n群上的离散对数问题：给定群GGG的生成元ggg和GGG中的随即元素hhh，计算log⁡gh\\log _ghlogg​h。这个问题在许多群中都被认为是困难的，称其为离散对数假设。\n令GroupGen是一个多项式时间算法，其输入为安全参数K\\mathcal{K}K，输出为一个阶等于qqq的循环群GGG的描述，以及一个生成元g∈Gg\\in Gg∈G，它的离散对数假设定义如下：\nGroupGen的离散对数问题是困难的，如果对于所有的PPT算法AAA，下式是可忽略的\nPr[(G,g)←GroupGen(K);h←RG;x←A(G,g,h)],st gx=hPr[(G,g)\\larr GroupGen(\\mathcal{K});h\\larr _RG;x\\larr \\mathcal{A}(G,g,h)],st\\ g^x=h\nPr[(G,g)←GroupGen(K);h←R​G;x←A(G,g,h)],st gx=h\n如果GroupGen的离散对数是困难的，且G是一个有GroupGen输出的群，则称离散对数问题在G中是困难的。\nElGamal加密算法是IND-CPA安全的，\n密钥产生过程：\nKenGen(K):(G,g)←GroupGen(K);x←RZq,y=gxpk=(G,g,y),sk=xKenGen(\\mathcal{K}):\\\\\n(G,g)\\larr GroupGen(\\mathcal{K});\\\\\nx \\larr_R Z_q,y=g^x\\\\\npk=(G,g,y),sk=x\nKenGen(K):(G,g)←GroupGen(K);x←R​Zq​,y=gxpk=(G,g,y),sk=x\n加密过程\nεpk(M):r←RZqoutput (gx,yrM)\\varepsilon_{pk}(M):\\\\\nr\\larr _RZ_q\\\\\noutput\\ (g^x,y^rM)\nεpk​(M):r←R​Zq​output (gx,yrM)\n解密过程\nDsk(A,B)D_{sk}(A,B)\nDsk​(A,B)\n离散对数问题意味着给定公开钥，没有敌手能确定秘密钥。然而，这不足以保证方案是IND-CPA安全的。实际上，可以找到一个特殊的群，其上的离散对数假设成立，但建立在其上的ElGamal加密方案却不是IND-CPA的。\n例如Zp∗Z_p^*Zp∗​上的离散对数假定是成立的，但在多项式时间内可判定ZP∗Z_P^{*}ZP∗​是否为二次剩余。而且ZP∗Z_P^*ZP∗​中的生成元g不可能是二次剩余，否则其元素都是二次剩余。这就导致一种针对ElGamal的直接攻击：敌手产生两个等长的消息(M0,M1)(M_0,M_1)(M0​,M1​)使得M0M_0M0​是二次剩余，M1M_1M1​是二次非剩余。给定密文（A,B）则存在r使得A=gx,B=yrMβA=g^x,B=y^rM_{\\beta}A=gx,B=yrMβ​，可以在多项式时间内判定yry^ryr是否为二次剩余。\n例如A是二次剩余，则存在一个a使得a2=Aa^2=Aa2=A，将a写成生成元g的幂gag^aga，那么A=g2a,r≡2αmod  (p−1)A=g^{2a},r \\equiv  2\\alpha\\mod (p-1)A=g2a,r≡2αmod(p−1)。\n如果A或y是二次剩余，则x，r至少有一个是偶数，所以yr=gxry^r=g^{xr}yr=gxr也是一个二次剩余。通过观察B，就能判断MβM_{\\beta}Mβ​是否为二次剩余。进而可以判断出加密的是哪个消息。\n因此，为了证明ElGamal加密方案的语义安全性，我们需要一个更强的假设。\n判断性Diffie-Hellman(DDH)假设\n判断性Diffie-Hellman(Decisional Diffie-Hellman)假设（DDH假设）指的是区分元组(g,gx,gy,gxy)(g,g^x,g^y,g^{xy})(g,gx,gy,gxy)和(g,gx,gy,gz)(g,g^x,g^y,g^z)(g,gx,gy,gz)是困难的，其中g是生成元，x,y,z是随机的\n设G是阶为大元素q的群，g为G的生成元，x,y,z←RZqx,y,z\\larr _RZ_qx,y,z←R​Zq​，则以下两个分布：\n\n随机四元组R=(g,gx,gy,gz)∈GAR=(g,g^x,g^y,g^z)\\in G^AR=(g,gx,gy,gz)∈GA\n四元组D=(g,gx,gy,gxy)∈GAD=(g,g^x,g^y,g^{xy})\\in G^AD=(g,gx,gy,gxy)∈GA在计算上是不可区分的。\n\n对任一敌手A\\mathcal{A}A，A\\mathcal{A}A区分R和D的优势AdvADDH(K)=∣Pr[A(R)=1]−Pr[A(D)=1]∣Adv_{\\mathcal{A}}^{DDH}(\\mathcal{K})=|Pr[\\mathcal{A}(R)=1]-Pr[\\mathcal{A}(D)=1]|AdvADDH​(K)=∣Pr[A(R)=1]−Pr[A(D)=1]∣是可忽略的。\n在DDH假设下，ElGamal加密方案是IND-CPA安全的。\n","categories":["密码学基础"],"tags":["密码学基础"]},{"title":"精通以太坊","url":"/posts/de8726eb.html","content":"\nChapter 1\n以太坊开发主要有四个阶段\n四个主要的发展阶段代号为前沿（Frontier），家园（Homestead），大都会（Metropolis）和宁静（Serenity）。中间的硬分叉代号为“冰河时代（Ice Age）”，“DAO”，“蜜桔前哨（Tangerine Whistle）”，“假龙（Spurious Dragon）”，“拜占庭（Byzantium）”和“君士坦丁堡（Constantinople）”。它们在下面列出，以及硬分叉发生的块号：\n之前的过渡\n\n\nBlock #0\n&quot;Frontier&quot; - 以太坊的初始阶段, 从2015年7月30日持续到2016年3月。\n\n\nBlock #200,000\n“Ice Age” - 引入指数级难度增长的一个难题，激励了到权益证明的过渡。\n\n\nBlock #1,150,000\n&quot;Homestead&quot; - 以太坊的第二阶段，2016年3月启动。\n\n\nBlock #1,192,000\n“DAO” - 恢复被破坏的DAO合约的硬分叉，导致以太坊和以太坊经典分成两个竞争系统。\n\n\nBlock #2,463,000\n“Tangerine Whistle” - 改变某些IO密集操作的燃气计算方法和清除拒绝服务攻击（利用这些操作的低燃气成本）累积状态的硬分叉。\n\n\nBlock #2,675,000\n“Spurious Dragon” - 解决更多拒绝服务攻击向量和另一种状态清除的硬分叉，还包括转播攻击保护机制。\n\n\n以太坊和图灵完整性\n术语“图灵完全”是以英国数学家阿兰图灵（Alan Turing）的名字命名的，他被认为是计算机科学之父。1936年，他创建了一个计算机的数学模型，该计算机由一个状态机构成，该状态机通过读写顺序存储器（类似于无限长度的磁带）来操纵符号。通过这个构造，Alan Turing继续提供了一个来回答（否定的）关于 通用可计算性（是否可以解决所有问题）问题的数学基础。他证明了存在一些不可计算的问题。具体来说，他证明 停机问题 Halting Problem（试图评估程序是否最终会停止运行）是不可解决的。\n以太坊的突破性创新是将存储程序计算机的通用计算架构与去中心化区块链相结合，从而创建分布式单状态（单例）世界计算机。以太坊程序“到处”运行，但却产生了共识规则所保证的共同（共识）状态。\n从通用区块链到去中心化应用 (DApps)\n以太坊扩展为编程去中心化应用（DApps）的平台。DApps至少是一个智能合约和一个web用户界面。\n以太坊的开发文化：速度和创新\n以太坊基础\n控制和责任\n因为去中心化，以太坊的每位用户都应该学会保存自己的密钥，这些密钥可以控制对资金和合约的访问。如果你丢失了密钥，你将无法获得资金和合约，你的资金将永远锁定。\n以太坊货币单位\n以太坊货币单位称为 以太，ETH\n1ETH=1018wei1ETH=10^{18}wei1ETH=1018wei\n以太坊钱包\n推荐使用MetaMask\n密钥，地址\n以太坊有两种不同类型的账户，可以拥有和控制ether：外部所有账户（EOA）和_合同_。\nEOAs中以太的所有权通过 数字密钥 digital keys，以太坊地址_和_数字签名 建立 。\n钱包\n钱包是作为主要用户界面的应用程序。钱包控制对用户资金的访问，管理密钥和地址，追踪余额以及创建和签署交易。另外，一些以太坊钱包还可以与合约（如代币）进行交互。\n"},{"title":"Mastering Bitcoin","url":"/posts/a37f5aad.html","content":"\n公认的区块链1.0的最好的书，在线阅读Mastering Bitcoin\n介绍\n什么是比特币\n比特币是由一系列概念和技术作为基础构建的数字货币生态系统。\n比特币可以做传统货币能做的所有事，例如买卖商品、给个人或组织汇款、贷款。用户可以在专门的交易所里买卖比特币或兑换其他货币。\n不同于传统货币，比特币是完全虚拟的。用户只要有证明其控制权的密钥，用密钥解锁，就可以发送比特币。这些密钥通常存储在计算机的数字钱包里。\n比特币是通过“挖矿”产生的，挖矿就是验证比特币交易的同时参与竞赛来解决一个数学问题。任何参与者（比如运行一个完整协议栈的人）都可以做矿工，用他们的电脑算力来验证和记录交易。\n比特币协议还规定，每四年新币的开采量减半，同时限制比特币的最终开采总量为2,100万枚。这样，流通中的比特币数量非常接近一条曲线，并将在2140年比特币将达到2,100万枚。由于比特币的开采速度随时间递减，从长期来看，比特币是一种通货紧缩货币。\n比特币的构成：\n\n去中心化的点对点网络\n公共的交易账簿\n去中心化的数学的和确定性的货币发行\n去中心化的交易验证系统\n\n比特币发展史\n2008年，一个化名为中本聪的人，在《比特币：一个点对点的电子现金系统》的论文中首先提出了比特币。中本聪结合以前的多个数字货币发明，如B-money和HashCash，创建了一个完全去中心化的电子现金系统，不依赖于通货保障或是结算交易验证保障的中央权威。他提出的算法的关键在于“工作量证明”。\n根据中本聪发表的一篇涉及比特币网络运行的论文，比特币网络自从被许多其他的程序员修订之后，于2009年启动。\n中本聪在2011年4月退出公众视野，将比特币代码开发与网络建设的重任留给了欣欣向荣的社区成员。\n入门\n比特币客户端的三种主要形式是：\n完整客户端\n一个完整客户端，或称“全节点”，是存储所有比特币交易的整个交易历史（由每一个用户完成的每一笔交易，曾经所有的每一笔）的客户端，管理用户的钱包，并可以在比特币网络上直接开始交易。它处理着协议的各个方面，而不依赖于任何其它的服务器或第三方服务。\n轻量级客户端\n一个轻量级客户端存储用户的钱包，但需要依赖第三方服务器才能进行比特币交易，才能接入比特币网络。轻量级客户端不保存所有交易的完整副本，因此必须信赖第三方的服务器来获取交易确认。\n在线客户端\n在线客户端通过网页浏览器在第三方服务器上访问和储存该用户的钱包。\n比特币的原理\n与传统银行和支付系统不同，比特币系统是以去中心化信任为基础的。由于比特币网络中不存在中央权威信任机构，“信任”成为了比特币用户之间存在的一种突出特性。\n比特币概述\n\n如图所示，比特币系统由以下构成：\n用户（用户通过密钥控制钱包）\n交易（每一笔交易都会被广播到整个比特币网络）\n矿工（通过竞争计算生成在每个节点达成共识的区块链，区块链是一个分布式的公共权威账簿，包含了比特币网络发生的所有的交易）\n买咖啡的例子\n这是一个真实发生的买咖啡的例子：\nbitcoin:1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA?amount=0.015&amp;label=Bob%27s%20Cafe&amp;message=Purchase%20at%20Bob%27s%20Cafe\n它的意思表示：\nA bitcoin address: &quot;1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA&quot;The payment amount: &quot;0.015&quot;A label for the recipient address: &quot;Bob&#x27;s Cafe&quot;A description for the payment: &quot;Purchase at Bob&#x27;s Cafe&quot;\n比特币的交易\n交易告知全网：比特币的持有者已授权把比特币转帐给其他人。而新持有者能够再次授权，转移给该比特币所有权链中的其他人，产生另一笔交易来花掉这些比特币，后面的持有者在花费比特币也是用类似的方式。\n每笔交易包含多个输入或输出，输入是针对一个比特币账号的负债，输出被当成信用点数记入到比特币账户中。当输出累加略少于输入量时，两者的差额就代表了一笔隐含的“矿工费”，这也是将交易放进账簿的矿工所收集到的一笔小额支付。\n在比特币术语中，“消费”指的是签署一笔交易：转移一笔以前交易的比特币给以比特币地址所标识的新所有者。\n常见的交易形式：\n从一个地址到另一个地址的简单支付，一个交易包含一个输入和两个输出\n\n集合多个输入到一个输出，相当于生活中很多零钱＋纸币兑换大额面钞\n\n将一个输入分配给多个输出，即多个接收者的交易，可被用作商业实体分配资金\n\n交易的构建\n钱包应用知道如何选取合适的输入和输出以建立Alice所希望的交易，A只需要输入地址和金额，其余的细节钱包应用会在后台自动完成。包应用甚至可以在完全离线时建立交易：比特币交易建立和签名时不用连接比特币网络，只有在执行交易时才需要将交易发送到网络。\n获取正确的输入\nAlice的钱包应用首先要找到一些足够支付给Bob所需金额的输入。如果钱包客户端没有某一未消费交易输出，它可以通过不同的服务者提供的各种API或完整索引节点的JSON PRC API从比特币网络中拿到这一交易信息。\n如下所示：\n$ curl https://blockchain.info/unspent?active=1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK\n查找Alice的比特币地址所有的未消费的输出\n返回的响应数据\n&#123;  &quot;unspent_outputs&quot;: [    &#123;      &quot;tx_hash&quot;:&quot;186f9f998a5...2836dd734d2804fe65fa35779&quot;,      &quot;tx_index&quot;:104810202,      &quot;tx_output_n&quot;:0,      &quot;script&quot;:&quot;76a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac&quot;,      &quot;value&quot;:10000000,      &quot;value_hex&quot;:&quot;00989680&quot;,      &quot;confirmations&quot;:0    &#125;  ]&#125;\nA的地址：1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK\n含有一个未消费输出，价值是一千万聪（0.1btc）\n创建交易输出\nAlice的交易输出会包含一个脚本，这个脚本说 “这个输出谁能拿出一个签名和Bob的公开地址匹配上，就支付给谁”。因为只有Bob的钱包的私钥可以匹配这个地址，所以只有Bob的钱包可以提供这个签名以兑换这笔输出。因此Alice会用需要Bob的签名来包装一个输出。\n第二个输出：因为Alice的金额是0.10比特币的输出形式，对0.015 比特币一杯的咖啡来说太多了，需要找Alice 0.085比特币的零钱。Alice钱包创建给她的零钱的支付就在付给Bob的同一个交易里面。\nAlice的钱包将她的金额分成了两个支付：一个给Bob，一个给自己。她可以在以后的交易里消费这笔零钱输出。\n最后，为了让这笔交易尽快地被网络处理，Alice的钱包会多付一小笔费用。这个不是明显地包含在交易中的；而是通过输入和输出的差值所隐含的。如果Alice的找零时0.0845btc，而不是0.1-0.015=0.085btc，这里就有剩下 0.0005btc（50万聪） 。因为加起来小到 0.10，所以这个 0.10 btc的输入就没有被完整的消费了。\n比特币挖矿\n这个交易现在在比特币网络上传播开来。但只有被一个称为挖矿的过程验证且加到一个区块中之后，这个交易才会成为这个共享账簿（区块链）的一部分。\n比特币系统的信任是建立在计算的基础上的。交易被包在一起放进区块中时需要极大的计算量来证明，但只需少量计算就能验证它们已被证明。\n▷ 挖矿在构建区块时会创造新的比特币，和一个中央银行印发新的纸币很类似。每个区块创造的比特币数量是固定的，随时间会渐渐减少。\n▷ 挖矿创建信任。挖矿确保只有在包含交易的区块上贡献了足够的计算量后，这些交易才被确认。区块越多，花费的计算量越大，意味着更多的信任。\n密钥，地址，钱包\n每笔比特币交易都需要一个有效的签名才会被存储在区块链，只有有效的数字密钥才能产生有效的数字签名，因此拥有比特币的密钥副本就拥有了该帐户的比特币控制权。密钥包含公钥和私钥。\n在比特币交易中，收件人的公钥称为比特币地址，比特币地址是用户经常看到的密钥的唯一代表，他们只需要把比特币地址告诉其他人即可。\n在比特币系统中，我们用公钥加密创建一个密钥对，密钥对包括私钥和衍生出的公钥，公钥用于接收比特币，私钥用于比特币支付时的交易签名。\n公钥和私钥之间的数学关系，使得私钥可用于生成特定消息的签名。此签名可以在不泄露私钥的同时对公钥进行验证。\n私钥和公钥\n私钥是一个随机选出的数字。私钥用于生成支付比特币所必需的签名以证明资金的所有权。私钥必须始终保持机密。\n更准确地说，私钥可以是1和n-1之间的任何数字，其中n是一个常数（略小于2^256）。要生成这个私钥，我们可以随机选择一个256位的数字，并检查它是否小于n-1。\n通过椭圆曲线算法可以从私钥计算得到公钥，这是不可逆转的过程：K=k∗GK = k * GK=k∗G 。其中k是私钥，G是被称为生成点的常数点，而K是所得公钥。\n比特币使用了secp256k1标准所定义的一条特殊的椭圆曲线和一系列数学常数。\n例如：\nK = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G\nK = (x, y)x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341Ay = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB\n比特币地址\n比特币地址是一个由数字和字母组成的字符串，可以与任何想给你比特币的人分享。通常由“1”开头。\n通常用户见到的比特币地址是经过“Base58Check”编码的。如图所示\n\nBase58是一种基于文本的二进制编码格式，用在比特币和其它的加密货币中。相比于Base64（26个小写字母、26个大写字母、10个数字以及两个符号），Base58由不包括（0，O，l，I）的大小写字母和数字组成。\n为什么要Base58编码？\n想要记住一个256位的整数是非常困难的，并且，如果记错了其中某些位，这个记错的整数仍然是一个有效的私钥，因此，比特币有一种对私钥进行编码的方式，这种编码方式就是带校验的Base58编码。又称为钱包导入格式：WIF（Wallet Import Format）\n对私钥进行Base58编码有两种方式：非压缩的私钥格式（非压缩的公钥格式），压缩的私钥格式（压缩的公钥格式）。\n非压缩的私钥格式\n非压缩的私钥格式是指在32字节的私钥前添加一个0x80字节前缀，得到33字节的数据，对其计算4字节的校验码，附加到最后，一共得到37字节的数据：\n私钥：0C28FCA386C7A227600B2FE50B7CAE11EC86D3BF1FBE471BE89827E19D72AA1D\n增加0x80到私钥的前面：800C28FCA386C7A227600B2FE50B7CAE11EC86D3BF1FBE471BE89827E19D72AA1D\n两次SHA-256运算：\n8147786C4D15106333BF278D71DADAF1079EF2D2440A4DDE37D747DED5403592\n507A5B8DFED0FC6FE8801743720CEDEC06AA5C6FCA72B07C49964492FB98A714\n前四个字节作为效验位：507A5B8D\n效验位加在第二步的结果的后面：800C28FCA386C7A227600B2FE50B7CAE11EC86D3BF1FBE471BE89827E19D72AA1D507A5B8D\nBase58编码：5HueCGU8rMjxEXxiPuD5BDku4MkFqeZyd4dZ1jvhTVqvbTLvyTJ\n压缩的私钥格式\n压缩的私钥格式会在32字节的私钥前后各添加一个0x80字节前缀和0x01字节后缀，共34字节的数据，对其计算4字节的校验码，附加到最后，一共得到38字节的数据\n交易\n比特币交易的本质是数据结构，这些数据结构中含有比特币交易参与者价值转移的相关信息。比特币区块链是全球复式记账总账簿，每个比特币交易都是在比特币区块链上的一个公开记录。\n比特币交易的生命周期\n诞生：一笔比特币交易的生命周期起始于它被创建的那一刻。\n比特币交易会被一个或者多个签名加密（这标志着对该交易指向的比特币资金的使用许可）。在比特币网络中，每一个节点（比特币交易参与者）验证、并将交易在网络中进行广播，直到这笔交易被网络中大多数节点接收。最终，比特币交易被一个挖矿节点验证，并被添加到区块链上一个记录着许多比特币交易的区块中。\n创建比特币交易-&gt;广播交易比特币至网络-&gt;比特币交易在比特币网络中的传播\n交易结构\n一笔比特币交易是一个含有输入值和输出值的数据结构。\n比特币交易的基本单位是未经使用的一个交易输出，简称UTXO（unspent transaction output）。UTXO是不能再分割、被所有者锁住或记录于区块链中的并被整个网络识别成货币单位的一定量的比特币货币。\n一个UTXO可以是一“聪”的任意倍。尽管UTXO可以是任意值，但只要它被创造出来了，就像不能被切成两半的硬币一样不可再分了。如果出现UTXO过大，在交易支付的时候会出现找零的情况。例如：用户由5btc的UTXO想支付1btc，那么这笔交易必须消耗掉20btc并且产生两个输出，1btc支付给接收人，4btc支付到找零地址。\n就像现实生活中一样，比特币应用可以使用一些策略来满足付款需要：组合若干小的个体，算出准确的找零；或者使用一个比交易值大的个体然后进行找零。\n被交易消耗的UTXO被称为交易输入，由交易创建的UTXO被称为交易输出。\n交易输入是指向UTXO的指针。它们指向特定的UTXO，并被交易哈希和在区块链中记录UTXO的序列号作为参考。可以使用贪心算法选择所要使用的UTXO。\n大多数交易包含交易费，这是为了在网络安全方面给比特币矿工一种补偿。\n交易费可当作是为了包含（挖矿）一笔交易到下一个区块中的一种鼓励，也可当作是对于欺诈交易和任何种类的系统滥用，在每一笔交易上通过征收一笔小成本的税而造成的一种妨碍。交易费被挖出这个区块的矿工得到，并且记录在这个交易的区块链中。交易费通过所有输入的总和，以及所有输出的总和之间的差来表示：交易费 = 求和（所有输入） - 求和（所有输出）\n比特币网络\nP2P网络架构\n比特币采用了基于国际互联网（Internet）的P2P（peer-to-peer）网络架构。P2P是指位于同一网络中的每台计算机都彼此对等，各个节点共同提供网络服务。\n尽管P2P网络中各个节点互等，但是根据提供的功能不同，各节点之间具有不同的分工。每个比特币节点都由路由、区块链数据库、挖矿、钱包服务的功能集合。一个全节点包括：钱包、矿工、完整区块链、网络路由节点。\n全节点能够独立自主地校验所有交易，而不需借由任何外部参照。轻量级节点只保留了区块链的一部分，通过“建议支付验证（SPV）”的方式来完成交易验证。\n挖矿节点通过运行在特殊硬件设备上的工作量证明（proof-of-work）算法，以相互竞争的方式创建新的区块。\n用户钱包也可以作为全节点的一部分\n扩展比特币网络的不同节点类型：\n\n核心客户端：钱包，矿工，完整区块链，网络路由节点\n完整区块链节点：完整区块链，网络路由节点\n独立矿工：矿工，完整区块链，网络路由节点\nSPV钱包：钱包，网络路由节点\n\n全节点\n全节点是指维持包含全部交易信息的完整区块链的节点。完整区块链节点保有完整的、最新的包含全部交易信息的比特币区块链拷贝，这样的节点可以独立地进行建立并校验区块链，从第一区块（创世区块）一直建立到网络中最新的区块。\n简易支付验证 （SPV）节点\n通过简化的支付验证（SPV）的方式可以使某些节点在不必存储完整区块链的情况下进行工作，这种类型的客端被称为SPV客户端或轻量级客户端。SPV节点只需下载区块头，而不用下载包含在每个区块中的交易信息。\n简易支付验证是通过参考交易在区块链中的深度，一个拥有完整区块链的节点会构造一条验证链，这条链是由沿着区块链按时间倒序一直追溯到创世区块的数千区块及交易组成。而一个SPV节点会验证所有区块的链（但不是所有的交易），并且把区块链和有关交易链接起来。\nSPV节点不能验证某个交易（譬如同一个UTXO的双重支付）不存在。为了防御这些攻击，SPV节点需要随机连接到多个节点，以增加与至少一个可靠节点相连接的概率。\n在引入SPV节点/轻量级节点后不久，比特币开发人员就添加了一个新功能：Bloom过滤器，用以解决SPV节点的隐私风险问题。Bloom过滤器通过一个采用概率而不是固定模式的过滤机制，允许SPV节点只接收交易信息的子集，同时不会精确泄露哪些是它们感兴趣的地址。\nBloom过滤器\nBloom过滤器是一个允许用户描述特定的关键词组合而不必精确表述的基于概率的过滤方法。\n首先，SPV节点会初始化一个不会匹配任何关键词的“空白”Bloom过滤器。接下来，SPV节点会创建一个包含钱包中所有地址信息的列表，并创建一个与每个地址相对应的交易输出相匹配的搜索模式。然后，SPV节点会把每一个搜索模式添加至Bloom过滤器里，这样只要关键词出现在交易中就能够被过滤器识别出来。最后，对等节点会用收到的Bloom过滤器来匹配传送至SPV节点的交易。\nBloom过滤器的实现是由一个可变长度（N）的二进制数组（N位二进制数构成一个位域）和数量可变（M）的一组哈希函数组成。这些哈希函数的输出值始终在1和N之间，该数值与二进制数组相对应。Bloom过滤器的准确性和私密性能通过改变长度（N）和哈希函数的数量（M）来调节。\nBloom过滤器被用来过滤SPV节点从对等节点里收到的交易信息。SPV会建立一个只能和SPV节点钱包里的地址匹配的过滤器。SPV节点会向对等节点发送一条包含需在该连接中使用的过滤器的filterload消息。当过滤器建好之后，对等节点将每个交易的输出值代入过滤器中验证。那些匹配的交易会被传送回SPV节点。\n交易池\n交易池：维护一份未确认交易的临时列表。例如，保存用户钱包的节点会利用这个交易池来记录那些网络已经接收但还未被确认的。当一个交易被添加到交易池中，会同时检查孤立交易池，看是否有某个孤立交易引用了此交易的输出（子交易）。\n区块链\n区块链是由包含交易信息的区块从后向前有序链接起来的数据结构。\n区块链可以被视为一个垂直的栈，第一个区块作为栈底的首区块，随后每个区块都放在其他区块之上。\n每个区块头都经过SHA-256加密生成一个哈希值，每个区块都通过其区块头的“父区块哈希值“字段引用前一区块，这样，每个区块都可以连接前一个区块，这也方便了追溯。\n每个区块都只有一个父区块，但可以暂时拥有多个子区块，这是区块链分叉，这是暂时的，最终，只有一个子区块会成为区块链的一部分。\n区块结构\n区块是一种被包含在公开账簿（区块链）里的聚合了交易信息的容器数据结构。它包含：一个区块头，紧跟其后的区块主体的一长串交易。区块头80字节，平均每个交易为250字节，每个区块超过500个交易，因此，一个包含所有交易的完整区块比区块头大得多。\n\n\n\n大小\n字段\n描述\n\n\n\n\n4字节\n区块大小\n用字节表示的该字段之后的区块大小\n\n\n80字节\n区块头\n组成区块头的几个字段\n\n\n1-9 （可变整数）\n交易计数器\n交易的数量\n\n\n可变的\n交易\n记录在区块里的交易信息\n\n\n\n区块头\n区块头由三组区块元数据组成。\n一组引用父区块哈希值的数据，这组数据用于该区块与前一区块连接。\n第二组元数据，难度，时间戳和nonce，与挖矿竞争相关。\n第三组元数据是merkle树根。\n区块标识符\n区块主标识符就是它的加密哈希值，一个通过两次SHA256算法得到的数字指纹，产生的32字节哈希值，即区块头哈希值，例如：\n000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\n是第一个比特币区块的区块哈希值。区块哈希值可以唯一、明确地标识一个区块.\n区块哈希值并不包含在区块的数据结构里，它可能会作为区块元数据的一部分被存储在一个独立的数据库表中。\n另一种标识区块的方式是通过该区块在区块链中的位置，即区块的高度，block height。第一个区块的高度是0，和之前的哈希值表示同一个区块。每一个随后被存储在第一个区块之上的区块在区块链中都比前一区块“高”出一个位置。\n但是，相较于区块哈希值，区块高度并不是唯一的标识符。虽然单一的区块总会有一个明确的固定的高度，但反过来不成立。有可能存在两个相同高度的区块在争夺位置，这是分叉。\n创世区块\n区块链里的第一个区块创建于2009年，被称为创世区块。它是区块链里面所有区块的共同祖先，这意味着你从任一区块，循链向后回溯，最终都将到达创世区块。\n创世区块的哈希值：\n0000000000 19d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\nhttps://blockchain.info/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f可以在这个网址查看创世区块的信息。\n区块的连接\n当一个节点从网络接收传入的区块时，它会验证这些区块，然后链接到现有的区块链上。\n例如，现在第277314个区块的区块头哈希值为：00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249，此时比特币节点从网络上接收到一个新的区块，描述如下：\n&#123;    &quot;size&quot;:43560,    &quot;version&quot;:2,    &quot;previousblockhash&quot;:&quot;00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249&quot;,    &quot;merkleroot&quot;:&quot;5e049f4030e0ab2debb92378f53c0a6e09548aea083f3ab25e1d94ea1155e29d&quot;,    &quot;time&quot;:1388185038,    &quot;difficulty&quot;:1180923195.25802612,    &quot;nonce&quot;:4215469401,    &quot;tx&quot;:[&quot;257e7497fb8bc68421eb2c7b699dbab234831600e7352f0d9e6522c7cf3f6c77&quot;,#[...many more transactions omitted...]        &quot;05cfd38f6ae6aa83674cc99e4d75a1458c165b7ab84725eda41d018a09176634&quot;        ]&#125;\n对于这个区块，节点会根据”父区块哈希值“字段找出包含它的父区块的哈希值，这是节点已知的哈希值，也就是第277314块区块的哈希值。故这个区块的高度为277315。\nMerkle 树\n区块链中的每个区块都包含了产生于该区块的所有交易，且以Merkle树表示。\nMerkle树是一种哈希二叉树，用作快速归纳和校验大规模数据完整性。\n在比特币网络中，Merkle树被用来归纳一个区块中的所有交易，同时生成整个交易集合的数字指纹，且提供了一种校验区块是否存在某交易的高效途径。当N个元素插入到Merkle树中后，至多计算2log⁡2N2\\log_2N2log2​N就可检测出某个交易是否在这个树中。\nMerkle树是自底向上构建的。\nMerkle树被SPV节点广泛使用。SPV节点不保存所有交易也不会下载整个区块，仅仅保存区块头。它们使用认证路径或者Merkle路径来验证交易存在于区块中，而不必下载区块中所有交易。\n挖矿与共识\n挖矿是增加比特币货币供应的一个过程。每10分钟就会有一个新的区块被“挖掘”出来。\n矿工们在挖矿过程中会得到两种类型的奖励：创建新区块的新币奖励，以及区块中所含交易的交易费。为了得到这些奖励，矿工们会争相完成一种基于加密哈希算法的数学难题，解决这个难题的答案，作为矿工的计算工作量的证明，被称为”“工作量证明”\n新比特币的生成过程被称为挖矿是因为它的奖励机制被设计为速度递减模式，类似于贵重金属的挖矿过程。矿工通过创造一个新区块得到的比特币数量准确说是每210,000个块减少一半。在2140年之后，不会再有新的比特币产生。\n矿工们同时也会获取交易费。每笔交易都可能包含一笔交易费，交易费是每笔交易记录的输入和输出的差额。\n比特币经济学和货币创造\n目前，比特币一一个确定的但不断减慢的速率被铸造出来。大约每10分钟产生一个新区块，每一个区块都伴随着一定数量的全新比特币。每开采21万个区块，大约耗时4年，货币发行速率降低50%，在比特币运行的第一个四年中，每个区块创造出50个新比特币。\n最终，在经过1,344万个区块之后，所有的共2,099,999,997,690,000聪比特币将全部发行完毕。这大约是2140年。\n\n总量有限并且发行速度递减创造了一种抗通胀的货币供应模式。\n去中心化共识\n区块链并不是由一个中心机构创造的，它是由比特币网络中的所有节点各自独立竞争完成的。换句话说比特币网络中的所有节点，依靠着节点间的不稳定的网络连接所传输的信息，最终得出同样的结果并维护了同一个公共总帐。\n中本聪的主要发明就是这种去中心化的自发共识机制。自发是指，没有经过明确选举或者没有固定达成的共识的时间，在比特币的共识中，数以千计的独立节点遵守了简单的规则通过异步交互自发形成的产物。\n比特币的去中心化共识由所有网络节点的4种独立过程相互作用而产生：\n\n每个全节点依据综合标准对每个交易进行独立验证\n通过完成工作量证明算法的验算，挖矿节点将交易记录独立打包进新区块\n每个节点独立的对新区块进行校验并组装进区块链\n每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链\n\n交易的独立检验\n钱包软件通过收集UTXO、提供正确的解锁脚本、构造支付给接收者的输出这一系列的方式来创建交易。产生的交易随后将被发送到比特币网络临近的节点，从而使得该交易能够在整个比特币网络中传播。每一个收到交易的比特币节点将会首先验证该交易，这将确保只有有效的交易才会在网络中传播。\n每一个节点在校验每一笔交易时，都需要对照一个长长的标准列表：\n\n交易的语法和数据结构必须正确。\n输入与输出列表都不能为空。\n交易的字节大小是小于MAX_BLOCK_SIZE的。\n每一个输出值，以及总量，必须在规定值的范围内 （小于2,100万个币，大于0）。\n没有哈希等于0，N等于-1的输入（coinbase交易不应当被中继）。\nnLockTime是小于或等于INT_MAX的。\n交易的字节大小是大于或等于100的。\n交易中的签名数量应小于签名操作数量上限。\n解锁脚本（scriptSig）只能够将数字压入栈中，并且锁定脚本（scriptPubkey）必须要符合isStandard的格式 （该格式将会拒绝非标准交易）。\n池中或位于主分支区块中的一个匹配交易必须是存在的。\n对于每一个输入，如果引用的输出存在于池中任何的交易，该交易将被拒绝。\n对于每一个输入，在主分支和交易池中寻找引用的输出交易。如果输出交易缺少任何一个输入，该交易将成为一个孤立的交易。如果与其匹配的交易还没有出现在池中，那么将被加入到孤立交易池中。\n对于每一个输入，如果引用的输出交易是一个coinbase输出，该输入必须至少获得COINBASE_MATURITY (100)个确认。\n对于每一个输入，引用的输出是必须存在的，并且没有被花费。\n使用引用的输出交易获得输入值，并检查每一个输入值和总值是否在规定值的范围内 （小于2100万个币，大于0）。\n如果输入值的总和小于输出值的总和，交易将被中止。\n如果交易费用太低以至于无法进入一个空的区块，交易将被拒绝。\n每一个输入的解锁脚本必须依据相应输出的锁定脚本来验证。\n\n整合交易至区块\n验证交易后，比特币节点会将这些交易添加到自己的内存池中。内存池也称作交易池，用来暂存尚未被加入到区块的交易记录。\nAlice从Bob咖啡店购买咖啡时产生的那个区块，我们假设这个区块是由Jing的挖矿系统挖出的，并且继续跟进Alice的交易，因为这个交易已经成为了新区块的一部分。\nJing的挖矿节点维护了一个区块链的本地副本，包含了自2009年比特币系统启动运行以来的全部区块。当Alice买咖啡的时候，Jing节点的区块链已经收集到了区块277,314，并继续监听着网络上的交易，在尝试挖掘新区块的同时，也监听着由其他节点发现的区块。\nJing的节点立刻构建一个新的空区块，做为区块277,316的候选区块。\n交易优先级\n交易的优先级是由交易输入所花费的UTXO的“块龄”决定，交易输入值高、“块龄”大的交易比那些新的、输入值小的交易拥有更高的优先级。\n交易的优先级是通过输入值和输入的“块龄”乘积之和除以交易的总长度得到的：\nPriority = Sum (Value of input * Input Age) / Transaction Size\n交易输入的值是由比特币单位“聪”（1亿分之1个比特币）来表示的。UTXO的“块龄”是自该UTXO被记录到区块链为止所经历过的区块数，即这个UTXO在区块链中的深度。\n一个交易想要成为“较高优先级”，需满足的条件：优先值大于57,600,000，相当于一个比特币（即1亿聪），年龄为一天（144个区块），交易的大小为250个字节：\nHigh Priority &gt; 100,000,000 satoshis * 144 blocks / 250 bytes = 57,600,000\n比特币交易中没有过期、超时的概念，一笔交易现在有效，那么它就永远有效。\n创币交易\n区块中的第一笔交易是笔特殊交易，称为创币交易或者coinbase交易。是由节点构造并用来奖励矿工们所做的贡献的。\n创币交易没有输入，不消耗UTXO。它只包含一个被称作coinbase的输入，仅仅用来创建新的比特币。创币交易有一个输出，支付到这个矿工的比特币地址。\n","categories":["区块链"],"tags":["区块链"]},{"title":"联邦学习综述","url":"/posts/5262bc4b.html","content":"\n本文将介绍当前人工智能面临的挑战以及联邦学习可以作为一个有效的解决方案，并介绍联邦学习的分类和发展。\n\n人工智能面临的挑战\n在过去的十年，我们见证了机器学习（Machine Learning，ML）在人工智能（Artificial Intelligence，AI）应用领域中的迅猛发展，如计算机视觉，自然语言处理，推荐系统。近些年的产品，如AlphaGo，ChatGpt已经深深地影响着人类的生活。这些技术的成功，尤其是深度学习，都是建立在大量的数据基础上的。通过使用这些数据，深度学习系统能够在许多领域执行人类难以完成的任务。\n随着社会的不断发展，人们逐渐意识到主权的重要性，也会刻意选择去保护自己的隐私，这带来这样的意识问题：什么人或者组织能够拥有和使用数据建立人工智能技术应用的权力。在一般的产品服务中，商家都会要求获取产品数据和购买者记录的使用权，这种请求是不明确的。最近更是有许多互联网企业由于泄露用户数据而被重罚，垃圾邮件制作者和不法的数据交易也常常被曝光和处罚。例如Meta数据泄露，拼多多用户数据非法收集。\n在法律层面，法规制定者和监管机构正在考虑出台新的法律法规来规范数据的管理和使用。经典的例子是2018年欧盟开始执行的GDPR，此外，中国的《中华人民共和国民法通则》和《中华人民共和国网络安全法》同样对数据的收集和处理提出了严格的要求。\n在这样的环境下，我们在不同组织之间收集和分享数据会变得越来越困难。某些高度敏感的数据（如医疗数据）的拥有者会极力反对无限制地计算和使用这些数据。在这种情况下，数据只保存在个人手中，往往会出现数据孤岛的现象。行业竞争，用户隐私，数据安全，复杂的管理规程，都会对数据的使用带来困难。\n如何在遵守更加严格的，新的隐私保护条例的前提下，解决数据碎片化和数据隔离的问题，是当前人工智能研究者和实践者面临的首要挑战。倘若不能及解决，将会导致新一轮的人工智能的寒冬。\n人工智能产业面临的另一个挑战：各方协同分享处理大数据的的益处并不明显。人们对数据失去掌控的担忧，以及对于增益分配效果的不透明，加剧了所谓数据碎片化和孤岛分布的严重性。\n随着物联网和边缘计算的兴起，大数据往往不会拘泥于单一的整体，而是分布在许多方面。对于自动驾驶汽车，每辆汽车必须能够在本地使用机器学习模型处理大量信息，同时需要与全球汽车协同工作。如何安全且有效地实现模型在多个地点间的更新和共享，是当前各类计算方法所面临的挑战。\n联邦学习概述\n由于数据孤岛的出现，正阻碍着训练人工智能模型所必需的大数据的使用，所以人们开始寻求：不必将所有数据集中到一个中心存储点就能够训练机器学习模型。\n一种可行的方法是由每一个拥有数据源的组织训练一个模型，之后让各个组织在各自的模型上彼此交流沟通，最终通过模型聚合得到一个全局模型。为了确保用户隐私和数据安全，各组织间交换模型信息的过程将会被精心地设计，使得没有组织能够猜测到其他任何组织的隐私数据内容。这便是联邦机器学习（Fedrated machine learning）或者联邦学习（Fedrated learning）的思想。\n谷歌的H.B M等人通过使用边缘服务器架构，将联邦学习用于智能手机上的语言预测模型更新，Communication-Efficient Learning of Deep Networks from Decentralized Data，Federated learning of deep networks using model averaging。通过联邦学习，每台移动设备上的模型将会被加密并上传到云端。最终，所有的加密模型都会被聚合到一个加密的全局模型中。\n谷歌的联邦学习很好地展示了企业对消费者（Business to Customer，B2C）的一个应用案例，除此之外，还应该支持企业对企业（Business to Business，B2B）的应用。\n联邦学习的定义\n联邦学习旨在建立一个基于分布数据集的联邦学习模型。联邦学习包括两个过程，分别是模型训练和模型推理。在模型训练的过程中，模型相关的信息能够在各方之间交换（或者是以加密形式交换），但数据不能。这一交换不会暴露每个站点上数据的任何受保护的隐私部分。当推理时，模型可以应用于新的数据实例。\n联邦学习是一种具有以下特征的用来建立机器学习模型的算法框架。其中，机器学习模型是指将某一方的数据实例映射到预测结果输出的函数。\n\n有两个或以上的联邦学习参与方协作构建一个共享的机器学习模型。每一个参与方都拥有若干能够用来训练模型的训练数据。\n在联邦学习模型的训练过程中，每一个参与方拥有的数据都不会离开该参与方。\n联邦学习模型相关的信息能够以加密方式在各方之间进行传输和交换，并且需要保证任何一个参与方都不能推测出其他方的原始数据。\n联邦学习模型的性能要能够充分逼近理想模型的性能。\n\n设有NNN位参与方{Fi}i=1N\\{F_i\\}_{i=1}^N{Fi​}i=1N​协作通过使用各自的训练数据集{Di}i=1N\\{D_i\\}_{i=1}^N{Di​}i=1N​来训练机器学习模型。传统的方法是将所有的数据{Di}i=1N\\{D_i\\}_{i=1}^N{Di​}i=1N​收集起来并存储在一个地方训练得到一个机器学习模型MSUMM_{SUM}MSUM​，这样会导致任何一方FiF_iFi​的训练数据会直接暴露出来DiD_iDi​。联邦学习是一种不需要收集各参与方所有的数据{Di}i=1N\\{D_i\\}_{i=1}^N{Di​}i=1N​便能协作的训练一个模型MFEDM_{FED}MFED​的机器学习过程。设vSUMv_{SUM}vSUM​和vFEDv_{FED}vFED​分别为集中型模型MSUMM_{SUM}MSUM​和联邦型模型MFEDM{FED}MFED的性能量度，设δ\\deltaδ为一个非负实数，在满足以下条件时，联邦学习模型MFEDM_{FED}MFED​具有δ\\deltaδ的性能损失。\nvSUM−vFED&lt;δv_{SUM}-v_{FED}&lt;\\delta\nvSUM​−vFED​&lt;δ\n该公式说明了：如果使用安全的联邦学习在分布式数据源上构建机器学习模型，这个模型在未来数据上的性能近似于把所有数据集中到一个地方训练所得到的模型的性能。但实际上，我们允许联邦学习模型在性能上比集中训练的模型稍差。\n根据应用场景的不同，联邦学习系统可能设计也可能不涉及中央协调方。\n图一展示了一种包括协调方的联邦学习架构示例。\n\n图一：联邦学习系统示例：客户端-服务器架构\n在此场景中，协调方是一台聚合服务器，可以将初始模型发送给各参与方A~C。参与方分别使用各自的数据集训练该模型，并将模型权重更新发送到聚合服务器。之后，聚合服务器将从参与方处接收到的模型更新聚合起来，并将聚合后的模型更新发回给参与方。这一过程会反复进行，直至模型收敛。这种方法不仅保护了用户的隐私和数据安全，还减少了发送原始数据所带来的通信开销。\n联邦学习架构也能被设计为对等（P2P）网络的方式，不需要协调方。这进一步确保了安全，因为各方无需借助第三方便可以直接通信，如图二所示。\n\n图二：联邦学习系统示例：对等架构\n这种体系结构的优点时=是提高了安全性，但可能需要更多的计算操作来对消息内容进行加密和解密。\n联邦学习的分类\n设矩阵DiD_iDi​表示第iii个参与方的数据，设矩阵DiD_iDi​的每一行表示一个数据样本，每一列表示一个具体的数据特征（figure）。\n我们将特征空间设为χ\\chiχ，数据标签（label）空间设为yyy，并用III表示数据样本ID空间，例如：在教育领域，数据标签可以是学生的成绩分数。三者组成了一个训练数据集(I,χ,y)(I,\\chi,y)(I,χ,y)。不同的参与方拥有的数据的特征空间和样本IDIDID空间是不同的。根据分布情况的不同，我们将联邦学习划分为横向联邦学习（Horizontal Fedrated Learning，HFL），纵向联邦学习（Vertical Fedrated Learning，VFL）和联邦迁移学习（Fedrated Transfer Learning，VFL）\n\n图三：联邦学习划分\n横向联邦学习适用于联邦学习的参与方的数据有重叠的数据特征，即数据特征在参与方之间是对齐的，但是参与方拥有的数据样本是不同的。它类似于在表格视图中将数据水平划分的情况。因此，我们将横向联邦学习称为按样本划分的联邦学习（Sample-Partitioned Fedrated learning）。\n与横向联邦学习不同，纵向联邦学习适用于联邦学习参与方的训练数据有重叠的数据样本，即参与方之间的数据样本是对齐的，但是在数据特征上有所不同。它类似于数据在表格视图中将数据垂直划分的情况。因此，我们将纵向联邦学习称为按特征划分的联邦学习（Feature-Partitioned Fedrated learning）。\n联邦迁移学习适用于参与方的数据样本和数据特征重叠都很少的情况。\n例如，当两家位于不同地区的银行，他们重叠的用户可能很少，但是由于具有相似的商业模式都具有相同的特征，这意味着，两家银行的数据特征重叠部分较大，那么就可以通过横向联邦学习建立一个机器学习模型。\n当两家公司（如银行和电子商务公司）提供不同的服务，但在客户群体上有非常大的交集时，它们可以在各自的不同特征空间上协作，为各自的到一个更好的机器学习模型。用户重叠部分较大，数据特征的重叠部分较小，则这两家公司可以协作地通过纵向联邦学习方式训练机器学习模型。\n联邦学习的发展\n在计算机科学和机器学习的发展史中，联邦学习的概念曾多次以不同的形式出现过，如：面向隐私保护的机器学习，协作式机器学习，联邦优化和面向隐私保护的数据分析。\n","categories":["联邦学习"],"tags":["联邦学习"]},{"title":"计算复杂度","url":"/posts/74967696.html","content":"\n本文介绍图灵机，确定性多项式时间类和非确定性多项式时间问题。\n\n图灵机\n为了精确定义有效程序(即算法)这一概念，图灵构思了一种称为图灵机(Turing machine)的计算设备，把它作为一个计算原型，但却是非常通用的计算模型。这里要介绍的计算复杂性材料沿用了图灵机计算模型。下面介绍图灵机的个变型，这对我们学习计算复杂性的目的来说已经足够了。\n在我们的变型里，图灵机由有限状态控制单元、k(≥1)条纸带( tape)以及同样数量的读写头( tapehead)组成。有限控制单元控制磁头读写纸带的操作，每个读写头访问一条纸带(称为它的纸带)，沿着纸带或左或右地移动完成这一操作。每一条纸带分成无限个单元(cell)。图灵机求解一个问题时,读写头扫描一个有有限个字符的串。该串从纸带最左边的单元开始按顺序存放在纸带上，每个字符占用一个单元,右边剩下的是空白(blank)单元，该串称为问题的一个输入。扫描从含有输入的纸带左端开始，同时图灵机赋一个初态( initial state）。任何时刻图灵机都只有一个读写头访问它的纸带。读写头对它的纸带的一次访问称为一个合法移动。\n如果图灵机从初始状态开始，一步接一步地合法移动，完成对输入串的扫描，最终满足了终止条件而停下来，则称图灵机识别了该输入。图灵机识别的一个输入被称为一种可识别语言（language）的一个实例。\n对给定的问题，图灵机可以由它的有限控制单元的功能完全描述。这样的功能可以用一张表的形式给出，列出图灵机每个状态的下一步。\n为识别一个输入，图灵机MMM在停下来之前所移动的步数称为MMM的运行时间或MMM的时间复杂性，记为TMT_MTM​。TMT_MTM​可以表示为函数TM(N):N→NT_M(N):N\\rarr NTM​(N):N→N，其中n是输入实例的长度或规模。当MMM在初始状态时，它就是组成输入串的字符数，TM(n)≥nT_M(n)\\ge nTM​(n)≥n。除了对时间的要求外，MMM还有对空间的要求SMS_MSM​，它是MMM在写操作中读写头访问的纸带单元数。SMS_MSM​可表示为函数SM(n):N→NS_M(n):N\\rarr NSM​(n):N→N，称为MMM的空间复杂性。\n下面我们介绍一个具体的图灵机。\n确定性多项式时间\np(n)p(n)p(n)是整数上关于nnn的一个多项式，它有下列形式：\np(n)=cknk+ck−1nk−1+...+c1n+c0p(n)=c_kn^k+c_{k-1}n^{k-1}+...+c_1n+c_0\np(n)=ck​nk+ck−1​nk−1+...+c1​n+c0​\n其中k,cik,c_ik,ci​是常整数且ck≠0c_k\\ne 0ck​​=0，当k&gt;0k&gt;0k&gt;0是，前者称为多项式p(n)p(n)p(n)的次数，记为deg(p(n))deg(p(n))deg(p(n))，后者称为多项式p(n)p(n)p(n)的系数。\nP类，我们记PPP表示具有下列特征的语言类。语言LLL在PPP中，如果存在一个图灵机MMM和一个多项式p(n)p(n)p(n)使得对任意非负整数n，M可以在时间TM(n)≤p(n)T_M(n)\\le p(n)TM​(n)≤p(n)内识别任意实例I∈LI\\in LI∈L，其中n是表示实例III规模的整数参数。我们称L是可以在多项式时间内识别的。\n粗略地说，可以在多项式时间内识别的语言总是很容易的。\n","categories":["信息安全数学基础"],"tags":["数学"]},{"title":"纵向联邦学习","url":"/posts/c23d1ee9.html","content":"\n现在我们介绍另一种联邦学习算法：纵向联邦学习（Vertical Federated Learning）。纵向联邦学习的参与方拥有相同样本空间、不同特征空间的数据，通过共有样本数据进行安全联合建模，在金融、广告等领域拥有广泛的应用场景。和横向联邦学习相比，纵向联邦学习的参与方之间需要协同完成数据求交集、模型联合训练和模型联合推理。并且，参与方越多，纵向联邦学习系统的复杂度就越高。\n\n纵向联邦学习VFL一般由两部分组成：加密实体对齐，加密模型训练。\n加密实体对齐\n由于A方和B方公司的用户群体不同，系统使用一种基于加密的用户ID对齐技术，来确保A方和B方不需要暴漏各自的原始数据便可以对齐共同用户。在实体对齐期间，系统不会将属于某一家公司的用户暴露出来。\n加密模型训练\n在确定共有实体后，各方可以使用这些共有实体的数据来协同地训练一个机器学习模型。训练过程可以被分为以下四个步骤：\n\n协调者C创建密钥对，并将公共密钥发送给A方和B方\nA方和B方对中间结果进行加密和交换，中间结果用来帮助计算梯度和损失值\nA方和B方计算加密梯度并分别加入附加掩码。B方还会计算加密损失。A方和B方将加密的结果发送给C方\nC方对梯度和损失信息进行解密，并将结果发送回A方和B方。A方和B方解除梯度信息上的掩码，并根据这些梯度信息来更新模型参数\n\n在样本对齐中，最常使用地便是隐私集合求交（Private Set Intersection，PSI）技术。业界PSI实现方案有多种：基于电路、基于公钥加密、基于不经意传输协议和基于全同态加密等。不同PSI方案各有优劣势。例如，基于公钥加密方案不需要辅助服务器运行，但公钥加密的计算开销大；而基于不经意传输方案计算性能高，但通信开销较大。因此在具体应用时，要根据实际场景来选择功能、性能和安全之间的最佳平衡方案。\n基于RSA盲签名是一种基于公钥加密的经典PSI方法，也是当前业界纵向联邦学习系统中广泛应用的技术之一。下面以企业A和企业B为例描述RSA盲签名算法的基本流程。\n\n企业A作为服务端，拥有一个包含了标签数据+样本ID的集合。企业B则作为客户端，拥有样本ID集合。首先，企业A利用RSA算法生成私钥和公钥。其中，私钥保留在服务端，公钥则发送给企业B。\n服务端利用RSA算法计算出参与样本对齐的ID的签名：\ntj=H‘(Ka:j)t_j=H^`(K_{a:j})\ntj​=H‘(Ka:j​)\n其中Ka:j=(H(aj))d(mod  n)K_{a:j}=(H(a_j))^d(\\mod n)Ka:j​=(H(aj​))d(modn)是采用私钥d加密的对H(aj)H(a_j)H(aj​)的RSA加密的结果。\n同样，在客户端侧对样本ID进行公钥加密，并乘以一个随机数用于加盲扰动:\nyi=H(bi)(Rb,i)emod  ny_i=H(b_i)(R_{b,i})^e\\mod n\nyi​=H(bi​)(Rb,i​)emodn\n客户端侧将上述计算出来的{y1,...,yv}\\{y_1,...,y_v\\}{y1​,...,yv​}值传输给服务端侧。服务端侧收到yiy_iyi​值后，使用私钥ddd进行签名并计算：\nyi‘=yidmod  ny_i^`=y_i^d\\mod n\nyi‘​=yid​modn\n然后将计算出的{y1‘,...,yv‘}\\{y_1^`,...,y_v^`\\}{y1‘​,...,yv‘​}和{t1,...,tw}\\{t_1,...,t_w\\}{t1​,...,tw​}发送给客户端侧。 而客户端侧收到yi‘y_i^`yi‘​和tjt_jtj​后，首先完成去盲操作：\nKb:i=yi /Rb,iK_{b:i}=y_i^~/R_{b,i}\nKb:i​=yi ​/Rb,i​\n并将自己的ID签名与服务端发过来的ID签名进行样本对齐，得到加密和哈希组合状态下的ID交集III，\nti‘=H‘(Kb:i)I={t1,...,tw}∩{t1‘,...,tv‘}t_i^`=H^`(K_{b:i})\\\\\nI=\\{t_1,...,t_w\\}\\cap\\{t_1^`,...,t_v^`\\}\nti‘​=H‘(Kb:i​)I={t1​,...,tw​}∩{t1‘​,...,tv‘​}\n最后，将对齐后的样本ID交集III发送给服务端，服务端利用自身的映射表单独求取明文结果。这样企业A和企业B在加密状态下完成了求取相交的用户集合，并且在整个过程中双方非重叠样本ID都不会对外暴露。\n","categories":["联邦学习"],"tags":["联邦学习"]},{"title":"认证协议","url":"/posts/f6c879e6.html","content":"\n认证协议\n认证这一概念可以分为三个子概念，数据源认证（验证消息的某个声称属性），实体认证（验证消息发送者所声称的身份），认证的密钥建立（产生一条安全信道，用于后继的应用层安全通话）\n\n数据源认证\n数据源认证涉及通信，是一种安全服务，消息接收者用它来验证消息是否来源于所声称的消息源，数据完整性不一定包含通信过程。其次，数据源认证必然涉及消息源的识别，数据完整性不一定涉及。数据源认证必然涉及确认消息的新鲜性。\n我们可以将数据源认证这一概念的特征总结如下：\n\n\n包含从某个声称的源(发送者)到接收者的消息传输过程,该接收者在接收时会验证消息。\n\n\n接收方执行消息验证的目的在于确认消息发送者的身份。\n\n\n接收方执行消息验证的目的还在于确认在原消息离开消息发送者之后的数据完整性。\n\n\n验证的进一步目的在于确认消息传输的“活现性”。\n\n\n实体认证\n实体认证是一个通信过程，通过这个过程某个实体和另一个实体建立一种真实通信，并且第二主体声称的身份应该和第一主体所寻求的通信方一致。\n根据协议主体的不同归类方法，在分布式系统中，实体认证可以分为若干类型，包括如下：主机-主机类型，用户-主机类型，进程-主机类型，成员-俱乐部类型\n认证的密钥建立\n在现代密码学中，密钥是安全通信信道的基础，因此，为了进行高层或应用层安全通信而运行的实体认证协议通常都有一个子任务，即密钥建立、\n基本认证技术\n消息新鲜性和主体活现性\n判断某条消息是否新鲜是数据源认证必不可少的一部分。\n询问-应答机制\n在询问-应答机制中，B在协议消息的组合中拥有他的输入信息，并且该合成消息涉及了A所进行的密码操作，于是B能够通过他自己输入的消息的新鲜性来验证A通信的真实性。假设NBN_BNB​代表B生成的一次性随机数，这种机制通常有以下交互方式：\n\n\nBob→Alice:NBBob \\rarr Alice:N_BBob→Alice:NB​\n\n\nAlice→Bob:εKAB(M,NB)Alice \\rarr Bob: \\varepsilon_{KAB}(M,N_B)Alice→Bob:εKAB​(M,NB​)\n\n\nB接收到密文分组并接受/拒绝\n\n\n发送的第一条消息通常为B对A的询问，第二条消息为A对B的应答\n以上给出的机制使用了对称加密技术。\n","categories":["密码学基础"],"tags":["认证协议"]},{"title":"论文阅读_FedIPR","url":"/posts/f9a8f369.html","content":"\n今天的论文题目是《FedIPR: Ownership Verification for Federated Deep Neural Network Models》\n论文地址：https://arxiv.org/abs/2109.13236\n\nFedIPR: Ownership Verification for Federated Deep Neural Network Models\nFedIPR： 联合深层神经网络模型的所有权验证\n为了解决联合学习模型开发和部署过程中，面临的非法复制，再分配，滥用等风险，本文提出一种联合深度神经网络（FedDNN）所有权验证方案，允许嵌入和验证私人水印，以保证联合学习模型知识产权（IPR）。本文所做的主要工作在不透露其私人水印的情况下证明训练模型的所有权。\n考虑到水印和联合学习中的威胁模型，本文提出了名为FedIPR的统一框架，它由两个独立的过程组成：1）水印嵌入过程，允许多方嵌入它们基于特征和后门的秘密水印。2）验证过程，允许每一方独立验证模型的所有权。\n技术挑战\n挑战A：如何确保不同的客户嵌入到同一个FedDNN模型中的私人水印不会相互诋毁？\n挑战B：如何确保嵌入式水印对保护隐私的学习策略具有鲁棒性？\n安全水平联合学习\n一个安全的水平联合学习系统由KKK个客户组成，它们用自己的数据建立自己的模型然后把本地模型Wkk=1K{W_k}_{k=1}^KWk​k=1K​发送到一个聚合器以获得一个全局模型，如下：\nW←∑k=1KnkKWkW\\leftarrow\\sum_{k=1}^K \\frac{n_k}{K}W_k\nW←k=1∑K​Knk​​Wk​\n其中nkn_knk​是每个客户的本地模型Wk的权重。\n自由人\nfreeider自由人，表示不贡献数据或计算资源，只为免费获得全局模型。自由人创建模型：\nWfree=Free(Wt,Wt−1)W^{free}=Free(W^t,W^{t-1})\nWfree=Free(Wt,Wt−1)\n带高斯噪声的自由人\nWfree=Wt+ξt,ξt∽N(0,σt)W^{free}=W^t+\\xi_t \\quad,\\quad \\xi_t\\backsim N(0,\\sigma_t)\nWfree=Wt+ξt​,ξt​∽N(0,σt​)\nDNN水印\nDNN水印有两类\n基于后门的水印：基于后门的水印T=(XT1,YT1),...(XTNT,YTNT)T={(X_T^1,Y_T^1),...(X_T^{N_T},Y_T^{N_T})}T=(XT1​,YT1​),...(XTNT​​,YTNT​​)是在训练期间通过加入后门样本的损失函数嵌入到模型函数N中\n基于特征的水印：在水印嵌入步骤中，在模型参数W的学习过程中，通过在原始学习任务中加入正则化项，嵌入N比特目标二进制水印B∈{0,1}NB \\in \\lbrace{0,1}\\rbrace^NB∈{0,1}N。\nFedIPR水印\n一个给定的联邦深度神经网络（FedDNN）模型所有权验证方案（FedIPR）被定义为元组 V=(g,ξ,A,VW,VB)V=(g,\\xi,A,V_W,V_B)V=(g,ξ,A,VW​,VB​)，由以下构成\n1）对于每个客户端K∈{1,...k}K \\in \\lbrace1,...k \\rbraceK∈{1,...k}，密钥生成过程G()→(Bk,θk,Tk)G()\\rightarrow (B_k,\\theta_k,T_k)G()→(Bk​,θk​,Tk​)生成水印BkB_kBk​，水印提取参数θk={Sk,Ek}\\theta_k=\\lbrace S_k,E_k\\rbraceθk​={Sk​,Ek​}，触发器Tk={(XTk1,YTk1),...(XTkNT,YTkNT)}T_k=\\lbrace (X_{T_k}^1,Y_{T_k}^1),...(X_{T_k}^{N_T},Y_{T_k}^{N_T})\\rbraceTk​={(XTk​1​,YTk​1​),...(XTk​NT​​,YTk​NT​​)}，注意：以上参数均应得到保密，其中SkS_kSk​表示水印BkB_kBk​的位置，EkE_kEk​表示水印BkB_kBk​的秘密嵌入矩阵。\n2）嵌入过程：Lk:=LDk(Wt)+αkLTk(Wt)+βkLBk,θk(Wt)L_k:=L_{D_k}(W^t)+\\alpha_kL_{T_k}(W^t)+\\beta_kL_{B_k,\\theta_k(W^t)}Lk​:=LDk​​(Wt)+αk​LTk​​(Wt)+βk​LBk​,θk​(Wt)​\n3）聚合过程：使用 FedAvg algorithm： Wt+1←Σk=1KnknWkt+1W^{t+1}\\larr \\Sigma_{k=1}^K \\frac{n_k}{n}W^{t+1}_kWt+1←Σk=1K​nnk​​Wkt+1​，其中，Wkt+1←ClentUpdate(Lk,Wt)W^{t+1}_k \\larr ClentUpdate(L_k,W^t)Wkt+1​←ClentUpdate(Lk​,Wt)是客户端k在第t轮的本地模型。nkn\\frac{n_k}{n}nnk​​ 表示聚合权重\n4）黑盒验证过程，检查由触发器样本XTkX_{T_k}XTk​​产生的指定标签YTkY_{T_k}YTk​​的检测误差是否小于 ϵB\\epsilon_BϵB​\nVb(N,Tk)={TRUE,ifETk(I(YTk!=N(XTk)))≤ϵBFALSE,otherwiseV_b(N,T_k)=\n\\begin{cases}\nTRUE,\\quad if \\quad E_{T_k}(I(Y_{T_k}!=N(X_{T_k}))) \\leq \\epsilon_B\\\\\nFALSE,\\quad otherwise\n\\end{cases}\nVb​(N,Tk​)={TRUE,ifETk​​(I(YTk​​!=N(XTk​​)))≤ϵB​FALSE,otherwise​\n5）白盒验证过程：验证模型参数是否嵌入能证明所属权的“水印”。\nVw(W,(Bk,θk)){TRUEH(Bk,Bk )≤ϵWFALSEV_w(W,(B_k,\\theta_k))\n\\begin {cases}\nTRUE \\quad H(B_k,B_k^~)\\leq \\epsilon_W\\\\\nFALSE\n\\end {cases}\nVw​(W,(Bk​,θk​)){TRUEH(Bk​,Bk ​)≤ϵW​FALSE​\nFedIPR 框架创新性地解决了模型所有权验证在联邦学习中的两大挑战：\n（1）多水印冲突问题，特别是对于基于特征的水印，对于不同的客户是否有一个通用的解决方案来嵌入他们的私人指定水印。如下图所示，当不同客户端希望各自嵌入水印进全局联邦学习模型当中，多个水印可能彼此发生冲突。\n\n为了解决该挑战, FedIPR提出用秘密提取矩阵的方式，解决了多个水印在联邦学习模型之中互相冲突的挑战。\n（2）性能问题，水印的鲁棒性表明模型水印是否能在联邦学习模型各种训练策略中适用和是否能抵御各种去除水印的攻击。FedIPR采用客户端嵌入的方式在差分隐私、鲁棒聚合、模型剪枝、微调等多种设定下进行了实验。\n\n","categories":["论文阅读"],"tags":["模型产权"]},{"title":"选择明文攻击下的不可区分性","url":"/posts/3da54cd7.html","content":"\n公钥加密方案在选择明文攻击（Chosen Plaintext Attack，CPA）下的IDA（Indistinguishability）游戏称为IND-CPA游戏如下：\n（1） 初始化。挑战者产生系统Π\\mathcal{\\Pi}Π，敌手A\\mathcal {A}A获得系统的公开钥。\n（2） 敌手产生明文消息，得到系统加密后的密文（可多项式有界次）。\n（3） 挑战。敌手输出出两个长度相同的消息M0M_0M0​和M1M_1M1​。挑战者随机选择β←R{0,1}\\beta \\larr _R\\{0,1\\}β←R​{0,1}，将MβM_{\\beta}Mβ​加密，并将密文C∗C^*C∗（称为目标密文）给敌手。\n（4） 猜测。敌手输出β′\\beta^{\\prime}β′，如果β=β′\\beta=\\beta^{\\prime}β=β′，则敌手攻击成功。\n敌手的优势可定义为参数K\\mathcal{K}K的函数：\nAdvΠ,ACPA(K)=∣Pr[β′=β]−12∣Adv_{\\mathcal{\\Pi},\\mathcal{A}}^{CPA}(\\mathcal{K})=|Pr[\\beta^{\\prime}=\\beta]-\\frac{1}{2}|\nAdvΠ,ACPA​(K)=∣Pr[β′=β]−21​∣\n其中，K\\mathcal{K}K是安全参数，用来确定加密方案密钥的长度。因为任一个不作为（仅做监听）的敌手A\\mathcal{A}A，都能通过对β\\betaβ做随即猜测，而以12\\frac{1}{2}21​的概率赢得IND-CPA游戏。而∣Pr[β′=β]−12∣|Pr[\\beta^{\\prime}=\\beta]-\\frac{1}{2}|∣Pr[β′=β]−21​∣是敌手通过努力得到的，故称为敌手的优势。\n因为\n∣Pr[β′=β]−12∣=∣Pr[β=0]Pr[β′=β∣β=0]+Pr[β=1]Pr[β′=β∣β=1]−12∣=∣Pr[β=0]Pr[β′=0∣β=0]+Pr[β=1]Pr[β′=1∣β=1]−12∣=∣12[1−Pr[β′=1∣β=0]]+12Pr[β′=1∣β=1]−12∣=12∣Pr[β′=1∣β=1]−Pr[β′=1∣β=0]∣|Pr[\\beta^{\\prime}=\\beta]-\\frac{1}{2}|\\\\\n=|Pr[\\beta=0]Pr[\\beta^{\\prime}=\\beta|\\beta=0]+Pr[\\beta=1]Pr[\\beta^{\\prime}=\\beta|\\beta=1]-\\frac{1}{2}|\\\\\n=|Pr[\\beta=0]Pr[\\beta^{\\prime}=0|\\beta=0]+Pr[\\beta=1]Pr[\\beta^{\\prime}=1|\\beta=1]-\\frac{1}{2}|\\\\\n=|\\frac{1}{2}[1-Pr[\\beta^{\\prime}=1|\\beta=0]]+\\frac{1}{2}Pr[\\beta^{\\prime}=1|\\beta=1]-\\frac{1}{2}|\\\\\n=\\frac{1}{2}|Pr[\\beta^{\\prime}=1|\\beta=1]-Pr[\\beta^{\\prime}=1|\\beta=0]|\n∣Pr[β′=β]−21​∣=∣Pr[β=0]Pr[β′=β∣β=0]+Pr[β=1]Pr[β′=β∣β=1]−21​∣=∣Pr[β=0]Pr[β′=0∣β=0]+Pr[β=1]Pr[β′=1∣β=1]−21​∣=∣21​[1−Pr[β′=1∣β=0]]+21​Pr[β′=1∣β=1]−21​∣=21​∣Pr[β′=1∣β=1]−Pr[β′=1∣β=0]∣\n敌手的优势也可定义为\nAdvΠ,ACPA(K)=∣Pr[β′=1∣β=1]−Pr[β′=1∣β=0]∣Adv_{\\mathcal{\\Pi},\\mathcal{A}}^{CPA}(\\mathcal{K})=|Pr[\\beta^{\\prime}=1|\\beta=1]-Pr[\\beta^{\\prime}=1|\\beta=0]|\nAdvΠ,ACPA​(K)=∣Pr[β′=1∣β=1]−Pr[β′=1∣β=0]∣\n只不过这种定义的优势是之前的2倍。\n上述的IND-CPA游戏可形式化地描述如下，其中公钥加密方案是三元组Π=(KeyGen,ε,D)\\mathcal{\\Pi}=(KeyGen,\\varepsilon,D)Π=(KeyGen,ε,D)，游戏的主体是挑战者。\nExpΠ,ACPA(K):(pk,sk)←KeyGen(K);(M0,M1)←A(pk) , when∣M0∣=∣M1∣;β←R{0,1},C∗=εpk(Mβ);β′←A(pk,C∗);if β′=β , return 1 , else return 0;Exp_{\\mathcal{\\Pi},\\mathcal{A}}^{CPA}(\\mathcal{K}):\\\\\n(pk,sk)\\larr KeyGen(\\mathcal K);\\\\\n(M_0,M_1)\\larr \\mathcal{A}(pk)\\ ,\\ when |M_0|=|M_1|;\\\\\n\\beta \\larr_R\\{0,1\\},C^*=\\varepsilon_{pk}(M_{\\beta});\\\\\n\\beta^{\\prime}\\larr\\mathcal{A}(pk,C^*);\\\\\nif\\ \\beta^{\\prime}=\\beta\\ , \\ return\\ 1\\ , \\ else\\ return\\ 0;\nExpΠ,ACPA​(K):(pk,sk)←KeyGen(K);(M0​,M1​)←A(pk) , when∣M0​∣=∣M1​∣;β←R​{0,1},C∗=εpk​(Mβ​);β′←A(pk,C∗);if β′=β , return 1 , else return 0;\n敌手的优势定义为\nAdvΠ,ACPA(K)=∣Pr[ExpΠ,ACPA(K)=1]−12∣Adv_{\\mathcal{\\Pi},\\mathcal{A}}^{CPA}(\\mathcal{K})=|Pr[Exp_{\\mathcal{\\Pi},\\mathcal{A}}^{CPA}(\\mathcal{K})=1]-\\frac{1}{2}|\nAdvΠ,ACPA​(K)=∣Pr[ExpΠ,ACPA​(K)=1]−21​∣\n如果在任何多项式时间的敌手A\\mathcal{A}A，存在一个可忽略的函数ϵ(K)\\epsilon(\\mathcal K)ϵ(K)，使得AdvΠ,ACPA(K)≤ϵ(K)Adv_{\\mathcal{\\Pi},\\mathcal{A}}^{CPA}(\\mathcal{K}) \\le \\epsilon (\\mathcal K)AdvΠ,ACPA​(K)≤ϵ(K)，那么就称这个加密算法Π\\mathcal{\\Pi}Π是语义安全的，或者称为在选择明文攻击下具有不可区分性，简称为IND-CPA安全。\n如果敌手通过MβM_{\\beta}Mβ​的密文能得到MβM_{\\beta}Mβ​的一个比特，就有可能区分MβM_{\\beta}Mβ​是M0M_0M0​还是M1M_1M1​，因此，IND游戏刻画了语义安全的概念。\n定义中需要注意以下几点：\n（1）定义中敌手是多项式时间的，否则因为它有系统的公开钥，可得到M0M_0M0​和M1M_1M1​的任意多个密文，再和目标密文逐一进行比较，即可赢得游戏。\n（2）M0,M1M_0,M_1M0​,M1​应该是等长的，否则由密文，有可能区分MβM_{\\beta}Mβ​是M0M_0M0​还是M1M_1M1​。\n（3）如果加密方案是确定的，每个明文对应的密文只有一个，敌手只需重新对M0M_0M0​和M1M_1M1​加密后与目标密文进行比较，即赢得游戏。因此，语义安全性不适用于确定性的加密方案。\n","categories":["密码学基础"],"tags":["密码学基础"]},{"title":"论文阅读DPIS","url":"/posts/4d931e35.html","content":"\n今天的论文题目是《Private and Reliable Neural Network Inference》\n论文地址：https://doi.org/10.1145/3548606.3560562\n\nDPIS: An Enhanced Mechanism for Differentially Private SGD with Importance Sampling\n摘要\n如今，差分隐私（DP）已成为隐私保护的广泛认可标准，而深度神经网络（DNN）在机器学习领域取得了巨大成功。将这两种技术相结合，即具有差分隐私的深度学习，有望保护隐私地发布使用敏感数据（如医疗记录）训练的高效用模型。为此，经典的机制是 DP-SGD，它是一种用于 DNN 训练的差分隐私版本的随机梯度下降（SGD）优化器。随后的方法改进了模型训练过程的各个方面，包括噪声衰减时间表、模型架构、特征工程和超参数调整。然而，自原始 DP-SGD 算法以来，SGD 优化器中强制执行 DP 的核心机制一直未发生变化，这越来越成为限制 DP 合规机器学习解决方案性能的基本障碍。受此启发，我们提出了 DPIS，一种新颖的差分隐私SGD训练机制，可作为 DP-SGD 核心优化器的替代品，与后者相比具有一致且显著的准确性提升。主要思想是在每次 SGD 迭代中，使用重要性采样（IS）进行小批量选择，从而减少采样方差和满足 DP 所需注入梯度的随机噪声量。尽管在非隐私设置中，使用 IS 的 SGD 在机器学习文献中已被广泛研究，但将 IS 集成到 DP-SGD 的复杂数学机制中是非常重要的；此外，IS 还涉及到额外的私有数据发布，这些数据必须在差分隐私下受到保护，以及计算密集型梯度计算。DPIS 通过新颖的机制设计、细粒度的隐私分析、效率增强和自适应梯度裁剪优化来应对这些挑战。在四个基准数据集（即 MNIST、FMNIST、CIFAR-10 和 IMDb）上进行的大量实验，涉及卷积神经网络和循环神经网络，证明了 DPIS 在具有差分隐私的深度学习方面优于现有解决方案的有效性。\nINTRODUCTION\n传统的深度学习将会带来隐私上的困扰。现如今，DP-SGD被看作是具有隐私保护性质的机器学习模型，DP-SGD 向 SGD 算法每次迭代中计算出的梯度注入随机噪音，但是，由于梯度中注入了噪声，在典型的隐私参数设置下，用 DP-SGD 训练出来的模型与不考虑隐私因素的普通 SGD 训练出来的模型在性能上仍有相当大的差距\n本文提出在核心层面优化DP-SGD的DPIS，其主要思想是每次SGD迭代中加入重要性采样（IS），以取代非私有SGD和DP-SGD中的随机抽样步骤。IS有助于降低SGD的采样方差并加快收敛速度，并且还有助于减少注入梯度的噪声量。\n在每次迭代中，DPIS 都会以与其梯度规范成比例的概率对每条记录进行采样，并对梯度进行加权，以获得对总梯度的无偏估计。\n本文采用了四个实验数据集：MNIST、Fashion MNIST (FMNIST)、CIFAR-10 和 IMDb。\n","categories":["论文阅读"],"tags":["差分隐私"]},{"title":"论文阅读_Platypus","url":"/posts/8ad5d7eb.html","content":"\nPlatypus: A Central Bank Digital Currency with Unlinkable Transactions and Privacy-Preserving Regulation\n论文地址：https://dl.acm.org/doi/10.1145/3548606.3560617\n\n摘要\n由于基于区块链的加密货币的普及，支付的日益数字化以及现金在社会中的作用不断减弱，各国央行对部署央行数字货币（CBDC）表现出越来越大的兴趣，这种数字货币可以作为数字现金的替代品。尽管大多数关于CBDC的研究都集中在区块链技术上，但这种技术选择是否提供了最优解决方案尚不明确。特别是，CBDC的集中信任模型为不同的设计提供了机会。在本文中，我们摒弃区块链设计，转而借鉴传统电子现金方案的思想。我们提出了一种新的构建数字货币的方法，将电子现金的交易处理模型与基于账户的资金管理模型相结合。我们认为，这种构建数字货币的方式特别适用于CBDC。我们还设计了第一个这样的数字货币系统，名为Platypus，它提供了强大的隐私保护、高可扩展性以及简单却具有表现力的监管，这些都是CBDC的关键特性。Platypus通过采用类似于Zcash等匿名区块链加密货币中使用的技术来适应我们的账户模型，并将它们应用于电子现金环境，从而实现了这些特性。\n关键词 数字货币\n问题介绍\n区块链在无权限数字货币（即不依赖于可信中央机构的数字货币）中的普及。中央银行数字货币（CBDC）受到这种启发，具有不同于无许可加密货币的信任模式和要求。传统的电子现金为发送者提供了隐私，但泄露了交易金额，在分布帐的系统中，硬币不需要存入，而是进行价值转移。\n与基于分类账的系统相比，电子现金系统有几个优点。电子现金系统更容易扩展，对客户端的要求可能会降低，因为在基于分类账的系统中，客户端会随时更新整个分类账或使用轻量级客户端，这就降低了客户端的隐私性。\n本文的目标：希望利用中央银行数字货币的不同信任模型，并结合基于账本的数字货币和传统电子现金方案的优势。\n为了实现这些目标，作为本文的第一个主要贡献，我们提出了一种构建数字货币的新方式，它将电子现金支付的交易处理模式与基于账户的用户资金管理模式相结合。\n作为本文的第二个主要贡献，我们设计了第一个遵循这种设计模式的数字货币系统，名为Platypus。在Platypus中，每个参与者都拥有一个账户，该账户由中央银行签署的一个序列号和余额的承诺（称为账户状态承诺）来表示。交易包括更新发送方和接收方的承诺。发送方和接收方披露其当前账户状态的序列号，以零知识证明他们拥有由中央银行签署的相应状态承诺，并且他们的余额之和保持不变。\n动机和目标\n目前，在许多司法管辖区，现金的获取和使用都在下降，这就造成了一些企业和家庭无法获取无风险的中央银行货币的风险。CBDC可以填补这一空白，确保人们对货币的信心。\n现金不仅提供无风险的中央银行货币，而且还提供非常强大的隐私保证。在现金支付中，第三方既不会知道交易双方的身份，也不会知道交易的价值。这也是CBDC应该具有的特性。对CBDC的另一个监管要求是执行反洗钱法。然而，这与改善支付隐私的目标存在部分冲突。解决这一冲突的方法是允许匿名支付，但每单位时间内的支付金额不得超过一定限额，超过限额后收款人需向监管机构披露身份。基于这些动机和想法，我们将重点放在零售CBDC上。\n假设\n我们假设中央银行的隐私是不可信的。\n我们认为完全防范基于网络的去匿名化攻击（例如，将一个IP地址与多个交易联系起来）不在本文的讨论范围之内。\n我们假设客户之间通过安全通道进行通信，并且所有使用的加密原语根据其安全性的标准定义都是安全的。\n我们假设承诺具有计算约束力和隐藏性，签名是不可伪造的，零知识证明系统是零知识并提供健全性，加密是CPA安全的。\n我们还假设零知识证明提供语句的不可并行性\nPlatypus 设计\nPlatypus采用账户模型和电子现金的混合设计，每个参与者负责跟踪自己的账户状态，账户状态被保存为类似于电子现金系统中硬币的对象。然而，与电子现金不同的是，客户通常拥有多个可用于交易的硬币，而客户只有一个账户状态，该账户状态在每次交易中都会被消耗，并被新的账户状态取代。该账户状态由账户余额balibal_ibali​和序列号serialiserial_iseriali​的账户状态承诺stateistate_istatei​表示。账户状态承诺由之前的交易产生，并由中央银行签署。为了签署这些状态承诺，中央银行使用其秘密密钥skCsk_CskC​（与公钥pkCpk_CpkC​相对应）。\n\n如图显示了在发送方和接收方均已参与系统的正常情况下交易的处理过程。\n在步骤1中，Alice发起交易，通过创建发送方账户更新向接收方Bob发送vTxv_{Tx}vTx​值。Alice 使用随机盲因子 blindTxblind_{Tx}blindTx​ 对值 vTxv_TxvT​x 创建一个承诺，称为交易承诺，用 commTx=comm(vTx,blindTx)comm_{Tx}=comm(v_{Tx},blind_{Tx})commTx​=comm(vTx​,blindTx​) 表示。\n然后，爱丽丝创建一个新的状态承诺statei+1Astate_{i+1}^Astatei+1A​，该状态承诺statei+1Astate_{i+1}^Astatei+1A​承诺一个新的伪随机（基于长期密钥）选择的序列号seriali+1Aserial^A_{i+1}seriali+1A​和一个值bali+1A=baliA−vTxbal_i+1^A=bal_i^A-v_{Tx}bali​+1A=baliA​−vTx​，其中baliAbal^A_ibaliA​是在当前状态承诺stateiAstate_i^AstateiA​中承诺的余额。然后 Alice 创建一个非交互式零知识证明zkpi+1Azkp_{i+1}^Azkpi+1A​ 来证明她正确地执行了这些步骤。\n零知识证明zkpi+1Azkp_{i+1}^Azkpi+1A​ 以及交易承诺commTxcomm_{Tx}commTx​、旧状态serialiAserial_i^AserialiA​和新账户状态承诺statei+1Astate_{i+1}^Astatei+1A​随后被发送给接收者Bob。Alice还提供了打开承诺commTxcomm_{Tx}commTx​所需的随机值blindTxblind_{Tx}blindTx​，这样Bob就可以用它为自己的账户更新创建零知识证明。\n为了完成交易（步骤 2 ），Bob 接着创建一个接收方的账户更新，其步骤与 Alice 类似，不同之处在于他的零知识证明zkpj+1Bzkp_{j+1}^Bzkpj+1B​重复使用了交易承诺 commTxcomm_{Tx}commTx​，并证明了他在新状态statej+1Bstate^B_{j+1}statej+1B​ 中的账户余额与他之前的状态statejBstate_j^BstatejB​相比，正好增加了vTxv_{Tx}vTx​，序列号为 serialjBserial_j^BserialjB​ 。\n一旦 Bob 创建了证明 zkpj+1Bzkp_{j+1}^Bzkpj+1B​，他就会发送交易承诺 commTxcomm_{Tx}commTx​、Alice’ 和他的序列号(serial𝑖𝐴,serial𝑗𝐵)(serial_𝑖^𝐴, serial^𝐵_𝑗 )(serialiA​,serialjB​)、 向中央银行提交两个新的状态承诺(statei+1𝐴,state𝑗+1𝐵)(state_{i+1}^{𝐴}, state^𝐵_{𝑗+1})(statei+1A​,statej+1B​)和两个零知识证明zkpi+1A,zkp𝑗+1𝐵zkp^A_{i+1}, zkp^𝐵_{𝑗+1}zkpi+1A​,zkpj+1B​。\n然后，中央银行通过验证两个零知识证明并检查序列号(serial𝑖𝐴,serial𝑗𝐵)(serial_𝑖^𝐴, serial^𝐵_𝑗 )(serialiA​,serialjB​)是否在以前的交易中使用过来执行交易（步骤 3 ）。如果是这种情况，中央银行会将这两个序列号添加到已使用的序列号集合中，用其私人密钥skCsk_CskC​签署两个新的状态承诺(statei+1𝐴,state𝑗+1𝐵)(state_{i+1}^{𝐴}, state^𝐵_{𝑗+1})(statei+1A​,statej+1B​)，并发送签署的序列号σ𝑖+1A=Sign(𝑠𝑘𝐶,state𝑖+1A)\\sigma _{𝑖+1}^A = Sign(𝑠𝑘_𝐶, state^A_{𝑖+1})σi+1A​=Sign(skC​,statei+1A​) 和 σ𝑖+1B=Sign(𝑠𝑘𝐶,statej+1B)\\sigma _{𝑖+1}^B = Sign(𝑠𝑘_𝐶, state^B_{j+1})σi+1B​=Sign(skC​,statej+1B​) 返回给 Bob，Bob 检查签名是否有效，如果有效，则接受付款（步骤 4）。然后，鲍勃将σi+1A\\sigma_{i+1}^Aσi+1A​ 转发给爱丽丝，爱丽丝验证签名并更新其存储的状态信息，从而完成支付（第 5 步）。\n交易细节\nSetup\n为建立系统，中央银行创建一个用于签署账户状态承诺的私钥/公钥对skC,pkCsk_C,pk_CskC​,pkC​，并公布其公钥pkCpk_CpkC​。中央银行还设置了一个参数 balmaxbal_{max}balmax​，这是账户余额的最大限制，以防止数值溢出（即由于所有数值都是有限域元素，因此可确保余额不能为负），其值可设置为大于账户余额的所有实际数值。\n当用户𝑈 注册进入系统时，他们会创建一个密钥𝑠𝑘𝑈=(𝑠𝑘U1,𝑠𝑘𝑈2)𝑠𝑘_𝑈 = (𝑠𝑘_{U1},𝑠𝑘_{𝑈2})skU​=(skU1​,skU2​)，由两个随机选择的密钥𝑠𝑘𝑈1,𝑠𝑘𝑈2𝑠𝑘_{𝑈 1},𝑠𝑘_{𝑈 2}skU1​,skU2​ 组成。\n为了创建注册交易，𝑈 会生成伪随机值 $serial^𝑈_1,blind^𝑈_1 从他们的私钥从他们的私钥从他们的私钥serial_1^U=f_{sku1},blind_1^U=g_{shku2}$，并用它们创建新的状态承诺 state1𝑈=comm(serial1𝑈,bal1𝑈,blind1𝑈)state^𝑈_1 = comm(serial^𝑈_1,bal^𝑈_1,blind^𝑈_1 )state1U​=comm(serial1U​,bal1U​,blind1U​)，表示没有余额的账户，即 bal1U=0bal_1^U=0bal1U​=0，𝑈 创建一个非交互式零知识证明 zkp1𝑈zkp^𝑈_1zkp1U​，证明账户状态承诺对应于余额为零的账户，即 zkp𝑈1 证明了以下语句\n给出公众值：state1Ustate_1^Ustate1U​，知晓私值： skU1,serial1U,blind1Usk_{U1},serial_1^U,blind_1^UskU1​,serial1U​,blind1U​\n这样：state1U=comm(serial1U,0,blind1U),serial1U=fskU1(0)state_1^U=comm(serial_1^U,0,blind_1^U),serial_1^U=f_{skU1}(0)state1U​=comm(serial1U​,0,blind1U​),serial1U​=fskU1​(0)\n然后𝑈 将状态state1Ustate_1^Ustate1U​和 zkp1𝑈zkp^𝑈_1zkp1U​ 发送给中央银行。银行检查证明是否正确，然后签署账户状态承诺状态state1Ustate_1^Ustate1U​，并将签名发回给𝑈。\nTransaction Creation\n我们将介绍发送方（Alice）和接收方（Bob）之间的交易是如何创建的。我们假定，除非另有说明，客户会对所有值保密，并且他们会通过安全通道进行通信。在实践中，发送方需要通过认证通道（类似于接收比特币地址）从接收方那里接收一个公钥，然后用来建立通道。这个公钥可以作为二维码显示在支付终端、电子商务网站或手机上。\nA当前账户状态：state𝑖𝐴=comm(serial𝑖𝐴,bal𝑖𝐴,blind𝑖𝐴)state_𝑖^𝐴 = comm(serial_𝑖^𝐴, bal_𝑖^𝐴, blind_𝑖^𝐴)stateiA​=comm(serialiA​,baliA​,blindiA​)\nB前账户状态：statejB=comm(serialjB,baljB,blindjB)state_j^B = comm(serial_j^B, bal_j^B, blind_j^B)statejB​=comm(serialjB​,baljB​,blindjB​)\n此外，两人都持有中央银行对其账户状态承诺的签名：σiA=Sign(skC,stateiA),σjB=Sign(skC,statejB)\\sigma _i^A =Sign(sk_C,state_i^A),\\sigma _j^B =Sign(sk_C,state_j^B)σiA​=Sign(skC​,stateiA​),σjB​=Sign(skC​,statejB​)\n\nTransaction Initiation:\n\n(i) 为了给 Bob 创建一个值为vTxv_{Tx}vTx​的交易，Alice 选择一个新的随机值 blindTxblind_TxblindT​x 并创建一个承诺 commTx=comm(𝑣Tx,blindTx)comm_{Tx} = comm(𝑣_{Tx},blind_{Tx})commTx​=comm(vTx​,blindTx​)。\n(ii) Alice 还从她的秘钥推导出伪随机值 serial𝑖+1A,blind𝑖+1Aserial_{𝑖+1}^A, blind_{𝑖+1}^Aseriali+1A​,blindi+1A​ 从serial𝑖+1A=𝑓𝑠𝑘𝐴1(serial𝑖𝐴),blind𝑖+1A=𝑔𝑠𝑘𝐴2(blind𝑖𝐴)serial_{𝑖+1}^A = 𝑓_{𝑠𝑘𝐴1} (serial_𝑖^𝐴) ,blind_{𝑖+1}^A = 𝑔_{𝑠𝑘𝐴2} (blind_𝑖^𝐴)seriali+1A​=fskA1​(serialiA​),blindi+1A​=gskA2​(blindiA​) 并创建新的账户状态 state𝑖+1A=comm(serial𝑖+1A,bal𝑖𝐴−𝑣Tx,blind𝑖+1A)state_{𝑖+1}^A =comm(serial_{𝑖+1}^A, bal_𝑖^𝐴 - 𝑣Tx, blind_{𝑖+1}^A)statei+1A​=comm(seriali+1A​,baliA​−vTx,blindi+1A​).\n(iii) 然后，爱丽丝创建一个非交互式零知识证明 zkp𝑖+1Azkp_{𝑖+1}^Azkpi+1A​，证明以下语句： 给定公共值\nserial𝑖𝐴,commTx,state𝑖+1A,balmax,𝑝𝑘𝐶serial_𝑖^𝐴, comm_{Tx}, state_{𝑖+1}^A, bal_{max}, 𝑝𝑘_𝐶serialiA​,commTx​,statei+1A​,balmax​,pkC​\n我知道秘密值\n𝑠𝑘_{𝐴1}，bal_𝑖^𝐴，bal_{𝑖+1}^A，blind_𝑖^𝐴，𝜎_𝑖^𝐴，𝑣_{Tx}，blind_{Tx}，serial_{𝑖+1}^A，blind_{𝑖+1}^A，\n使得\nTrue = Vrfy(𝑝𝑘_𝐶, comm(serial_𝑖^𝐴, bal_𝑖^𝐴, blind_𝑖^𝐴), 𝜎_𝑖^𝐴)\ncommTx=comm(𝑣Tx,blindTx)comm_{Tx} = comm(𝑣_{Tx}, blind_{Tx})commTx​=comm(vTx​,blindTx​)\nstate𝑖+1A=comm(serial𝑖+1A,bal𝑖+1A,blind𝑖+1A)state_{𝑖+1}^A = comm(serial_{𝑖+1}^A, bal_{𝑖+1}^A, blind_{𝑖+1}^A)statei+1A​=comm(seriali+1A​,bali+1A​,blindi+1A​)\nbalmax≥bal𝑖+1Abal_{max} ≥ bal_{𝑖+1}^Abalmax​≥bali+1A​\nbal𝑖+1A=bal𝑖𝐴−𝑣Txbal_{𝑖+1}^A = bal_𝑖^𝐴 - 𝑣_{Tx}bali+1A​=baliA​−vTx​\nserial𝑖+1A=𝑓𝑠𝑘𝐴1(seriali𝐴)serial_{𝑖+1}^A = 𝑓_{𝑠𝑘𝐴1} (serial_i^𝐴)seriali+1A​=fskA1​(serialiA​)\n(iv) 然后 Alice 将𝑣Tx、blindTx、commTx、serial𝑖𝐴、state𝑖+1A、zkp𝑖+1A𝑣_{Tx}、blind_{Tx}、comm_{Tx}、serial_𝑖^𝐴、state_{𝑖+1}^A、zkp_{𝑖+1}^AvTx​、blindTx​、commTx​、serialiA​、statei+1A​、zkpi+1A​发送给 Bob。\n\nTransaction Completion\n\n(i) 收到 Alice 发送的部分交易后，Bob 会删除serialj+1B=fskB1(serialjB),blind𝑗+1𝐵=gskB2(blindjB)serial_{j+1}^B=f_{skB1}(serial_j^B),blind^𝐵_{𝑗+1}=g_{skB2}(blind_j^B)serialj+1B​=fskB1​(serialjB​),blindj+1B​=gskB2​(blindjB​)的伪随机值serialj+1B,blindj+1Bserial_{j+1}^B,blind_{j+1}^Bserialj+1B​,blindj+1B​并且创建新的statej+1B=comm(serialj+1B，baljB+vTx,blindj+1B)state_{j+1}^B=comm(serial^B_{j+1}，bal_j^B+v_{Tx},blind_{j+1}^B)statej+1B​=comm(serialj+1B​，baljB​+vTx​,blindj+1B​)\n(ii) 如果B已经有一个账户，鲍勃创建一个非交互式零知识证明 zkp𝑗+1𝐵zkp^𝐵_{𝑗+1}zkpj+1B​，与A的证明类似（不同之处在于证明他的余额增加了交易值），证明以下语句：\nserialjB,commTx,statej+1B,balmax,pkCserial_j^B,comm_{Tx},state_{j+1}^B,bal_{max},pk_CserialjB​,commTx​,statej+1B​,balmax​,pkC​\n知道秘密值\n𝑠𝑘_{B1}，bal_j^B，bal_{j+1}^B，blind_j^B，𝜎_j^B，𝑣_{Tx}，blind_{Tx}，serial_{j+1}^B，blind_{j+1}^B，\n使得\nTrue = Vrfy(𝑝𝑘_𝐶, comm(serial_j^B, bal_j^B, blind_j^B), 𝜎_j^B)\ncommTx=comm(𝑣Tx,blindTx)comm_{Tx} = comm(𝑣_{Tx}, blind_{Tx})commTx​=comm(vTx​,blindTx​)\nstatej+1B=comm(serialj+1B,balj+1B,blindj+1B)state_{j+1}^B = comm(serial_{j+1}^B, bal_{j+1}^B, blind_{j+1}^B)statej+1B​=comm(serialj+1B​,balj+1B​,blindj+1B​)\nbalmax≥balj+1Bbal_{max} ≥ bal_{j+1}^Bbalmax​≥balj+1B​\nbalj+1B=baljB−𝑣Txbal_{j+1}^B = bal_j^B - 𝑣_{Tx}balj+1B​=baljB​−vTx​\nserialj+1B=𝑓𝑠𝑘B1(serialjB)serial_{j+1}^B = 𝑓_{𝑠𝑘B1} (serial_j^B)serialj+1B​=fskB1​(serialjB​)\n(iii) 然后 B将commTx,serial𝑖𝐴,state𝑖+1A,zkp𝑖+1A,serialiB,statei+1B,zkpi+1Bcomm_{Tx},serial_𝑖^𝐴,state_{𝑖+1}^A,zkp_{𝑖+1}^A,serial_i^B,state_{i+1}^B,zkp_{i+1}^BcommTx​,serialiA​,statei+1A​,zkpi+1A​,serialiB​,statei+1B​,zkpi+1B​发送给 银行。\n\nTransaction Execution\n\n(i) 中央银行检查序列号serialiAserial_i^AserialiA​、serial𝑗𝐵serial^𝐵_𝑗serialjB​ 是否出现在其存储的以前使用过的序列号集中，并且两个零知识证明 zkpi+1Azkp_{i+1}^Azkpi+1A​、zkp𝑗+1𝐵zkp^𝐵_{𝑗+1}zkpj+1B​ 均已验证。如果情况并非如此，则中央银行拒绝交易并通知 Bob。\n(ii) 否则，中央银行接受交易，并将这两个序列号添加到之前使用过的序列号集合中，将新的状态承诺签名为 𝜎^𝐴_{i+1} =Sign(𝑠𝑘_𝐶, state_{𝑖+1}^A) 和𝜎^𝐵_{𝑗+1} = Sign(𝑠𝑘_𝐶, state^𝐵_{𝑗+1}) 并发送给B。此外，中央银行还会发布转行动（即从 B 收到的所有值加上 𝜎_{𝑖+1}^A 和 𝜎^𝐵_{𝑗+1}）。\n\nPayment Acceptance\n\nBob 检查从中央银行收到的签名是否有效，接受付款并存储𝜎^𝐵_{𝑗+1}，以便在这种情况下更新其账户，并将𝜎^A_{i+1}转发到A。否则，他会拒绝付款并通知 Alice。\n\nPayment Completion\n\nAlice 检查从 Bob 收到的签名是否有效。否则，或者如果超时后仍未收到 Bob 的签名，她会检查中央银行的公共交易日志，以检索交易和新账户状态承诺上的签名。然后，她存储 σi+1A\\sigma ^A_{i+1}σi+1A​ 来更新她的账户，支付完成。\n","categories":["论文阅读"],"tags":["数字货币"]},{"title":"铜锁杂谈","url":"/posts/28392de5.html","content":"\n铜锁/Tongsuo是一个提供现代密码学算法和安全通信协议的开源基础密码库，为存储、网络、密钥管理、隐私计算等诸多业务场景提供底层的密码学基础能力，实现数据在传输、使用、存储等过程中的私密性、完整性和可认证性，为数据生命周期中的隐私和安全提供保护能力。\n项目地址：https://github.com/Tongsuo-Project/Tongsuo\n安装Tongsuo\n本节将介绍如何在ubuntu的虚拟机中安装Tongsuo。\n常见的安装方法有两种：直接安装和使用docker安装，没有本质上的区别，docker只是更方便我们卸载，你可以省略前面的安装dockers过程，直接到Tongsuo的安装步骤。\n安装docker\n在这一步，建议大家进入root权限\n卸载旧版本\nubuntu下自带了docker的库，不需要添加新的源。\n但是ubuntu自带的docker版本太低，需要先卸载旧的再安装新的\nsudo apt-get remove docker docker-engine docker.io containerd runc(su)apt-get remove docker docker-engine docker.io containerd runc\n获取软件最新源\nsudo apt-get update\n安装 apt 依赖包\n用于通过HTTPS来获取仓库\nsudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common\n安装GPG证书\ncurl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -\n验证\nsudo apt-key fingerprint 0EBFCD88\n设置稳定版仓库\nsudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;\n安装 Docker Engine-Community\n更新 apt 包索引\nsudo apt-get update\n以下两种安装方式，选择一种即可\n安装最新版本\nsudo apt-get install docker-ce docker-ce-cli containerd.io\n安装特定版本\napt-cache madison docker-ce\n测试\nsudo docker run hello-world\n启动\nsystemctl start docker\n停止\nsystemctl stop docker\n重启\nsystemctl restart docker\n查看安装的dockers版本\nsudo docker version\n安装tongsuo容器\n安装 docker 成功之后，打开你的命令行工具，并执行如下命令，创建一个 docker 容器：\ndocker run -d -it --name tongsuo_lab ubuntu:20.04 bash\n继续在命令行中执行如下命令，进入 docker 容器：\ndocker exec -it tongsuolab bash\n此时docker安装成功，并且创建容器\n下载Tongsuo密码库\n我们将在容器中下载同事密码库。因为 ubuntu 自带 apt 命令，因此可以用过 apt 命令安装 git 命令下载铜锁密码库，并通过 make 命令编译它。\n首先，我们先更新软件包索引，执行如下命令：\napt update\n接着安装 git gcc, make开发工具：\napt install git gcc make -y\n使用 git 命令克隆铜锁密码库的代码\ngit clone https://github.com/Tongsuo-Project/Tongsuo.git\n接着，对铜锁密码库进行一些配置，进入到 Tongsuo 文件夹下，执行如下命令：\ncd Tongsuo\n此时我们要开始编译，注意编译的时候要选择好你想使用的配置，常见的有：\n\nenable-xx：编译 xx 算法、协议或者功能，比如 我想使用bulletproof，就要enable-bulletproofs，根据自己的需求添加即可\n–prefix=DIR：指定 openssl 的安装目录，如果只是想生成库文件，没有必要执行 make install 命令，也就可以不用指定该选项，默认值：/usr/local\n-Wl,-rpath,/opt/tongsuo/lib：rpath 指定编译出的 openssl 二进制程序依赖的 libcrypto.so 和 libssl.so 目录，效果与 LD_LIBRARY_PATH 和 DYLD_LIBRARY_PATH环境变量一样\n–debug：如果需要 gdb 或者 lldb 调试需要加这个选项\n\n例如：\n./config --prefix=/opt/tongsuo enable-bulletproofs enable-paillier enable-ntls enable-ssl-trace -Wl,-rpath,/opt/tongsuo/lib64 --debug./config --prefix=/opt/tongsuo -Wl,-rpath,/opt/tongsuo/lib enable-bulletproofs\n关于更多的编译选项请看：https://www.yuque.com/tsdoc/ts/rp7ul8a4ttav8ql9\n最后，执行如下命令进行编译和安装：\nmake -jmake install\n此时，便安装成功了，可以通过如下命令查看安装情况：\nls -l /opt/tongsuo\n以及通过 /opt/tongsuo/bin/tongsuo version 命令查看铜锁密码库的版本\nTongsuo的零知识证明\n零知识证明（ZKP，Zero Knowledge Proof）是隐私计算和区块链领域中非常重要的密码学技术，能够在证明者不向验证者提供任何有用信息的情况下，使验证者相信某个论断是正确的。\nTongsuo使用的零知识证明技术是Bulletproofs，这是一种相比于zk-SNARKs和 zk-STARKs 更加高效和紧凑的零知识证明方案。具体介绍可以见：https://www.yuque.com/tsdoc/ts/bulletproofs\n本文介绍Tongsuo的零知识证明中一些需要注意的事。\n编译注意事项\n如果你想使用Bulletproofs算法，切记在Tongsuo代码拉去后编译时，添加enable-bulletproofs，例如：\n./config --prefix=/opt/tongsuo enable-bulletproofs enable-paillier enable-ntls enable-ssl-trace -Wl,-rpath,/opt/tongsuo/lib64 --debug\n基本的零知识证明\n对于零知识证明，一般分为四步：公共参数，证据，证明，验证。详情可以看：https://www.yuque.com/tsdoc/ts/bulletproofs#RoXBu，下面我说一些值得注意的事情。\n首先，官网给出的命令行是这样子的：\n$ tongsuo bulletproofs -ppgen -out ./pp.pem -curve_name sm2 -gens_capacity 16 -party_capacity 4\n很显然不能直接用，我们要修改路径，把tongsuo修改成自己的路径，例如我的就是：\n/opt/tongsuo/bin/tongsuo bulletproofs -ppgen -out ./pp.pem -curve_name sm2 -gens_capacity 16 -party_capacity 4\n后续指令同理。\n基于Tongsuo的range_proof\nTongsuo的官方说明文档给出了一个range_proof的教程：https://www.yuque.com/tsdoc/ts/bulletproofs-range。本文给出一些简单的补充。\n在给出的demo例子中，如下\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;openssl/bulletproofs.h&gt;static int range_proofs_test(int bits, int64_t secrets[], int len)&#123;    int ret = 0, i;    BIGNUM *v = NULL;    BP_TRANSCRIPT *transcript = NULL;    BP_PUB_PARAM *pp = NULL;    BP_WITNESS *witness = NULL;    BP_RANGE_CTX *ctx = NULL;    BP_RANGE_PROOF *proof = NULL;    v = BN_new();        /* 创建交互抄本对象，证明者和验证者需要使用相同的方法和标签，否则验证失败 */    transcript = BP_TRANSCRIPT_new(BP_TRANSCRIPT_METHOD_sha256(), &quot;test&quot;);        /* 创建公共参数对象，这里最大的批量验证个数为8 */    pp = BP_PUB_PARAM_new_by_curve_id(NID_secp256k1, bits, 8);    if (v == NULL || transcript == NULL || pp == NULL)        goto err;    /* 创建该公共参数下的证据对象 */    witness = BP_WITNESS_new(pp);    if (witness == NULL)        goto err;    for (i = 0; i &lt; len; i++) &#123;        if (!BN_lebin2bn((const unsigned char *)&amp;secrets[i], sizeof(secrets[i]), v))            goto err;        /* 往证据对象中提交明文证据，由于是 range proof，不需要绑定名称，所以名称可以直接传 NULL */        if (!BP_WITNESS_commit(witness, NULL, v))            goto err;    &#125;    /* 创建 range proof 上下文对象 */    ctx = BP_RANGE_CTX_new(pp, witness, transcript);    if (ctx == NULL)        goto err;    /* 创建证明对象 */    proof = BP_RANGE_PROOF_new_prove(ctx);    if (proof == NULL)        goto err;    /* 验证证明对象是否有效 */    if (!BP_RANGE_PROOF_verify(ctx, proof))        goto err;    ret = 1;err:    BP_RANGE_PROOF_free(proof);    BP_RANGE_CTX_free(ctx);    BP_WITNESS_free(witness);    BP_PUB_PARAM_free(pp);    BP_TRANSCRIPT_free(transcript);    BN_free(v);    return ret;&#125;int main(int argc, char *argv[])&#123;    int i, ret;    int64_t secrets[16];    if (argc &lt;= 1 || argc &gt;= sizeof(secrets)/sizeof(secrets[0])) &#123;        printf(&quot;Invalid parameter!\\n&quot;);        return -1;    &#125;    printf(&quot;number: &quot;);    for (i = 1; i &lt; argc; i++) &#123;        secrets[i-1] = atoi(argv[i]);        printf(&quot;%lld &quot;, secrets[i-1]);    &#125;    /* 这里指定的位数为16，即 range 范围为：[0, 65535] */    ret = range_proofs_test(16, secrets, argc - 1);    printf(&quot;%s range: [0, 65535]\\n&quot;, ret == 1 ? &quot;in&quot; : &quot;not in&quot;);    return 0;&#125;\n需要注意的是：argc表示命令行输入参数的个数，其中从第二个参数开始才表示我要验证的数字，例如\n./range_proof 11 22 65535\n./range_proof是第一个参数，11 22 65535才表示我想要验证的数字。\n此外，这个程序很明显经历了零知识证明中必须的四步：公共参数，证据，证明，验证。\ntranscript = BP_TRANSCRIPT_new(BP_TRANSCRIPT_METHOD_sha256(), &quot;test&quot;)\n所谓交互抄本，主要是指零知识证明中双方交流的有效信息，其中的&quot;test&quot;可以更改成任意值。\npp = BP_PUB_PARAM_new_by_curve_id(NID_secp256k1, bits, 8);\n创建公共参数中，选取了根据椭圆曲线的id生成公共参数的方法\nwitness = BP_WITNESS_new(pp);\n这是根据公共参数生成证据对象。\n然后就是根据证据对象和输入，生成证明和验证。\n此外，在编译的时候，我们也需要修改官方文档给出的命令行示例：\ngcc -Wall -g -o my_range_proof ./my_range_proof.c -I/opt/tongsuo/include -L/opt/tongsuo/lib64 -lcrypto -Wl,-rpath=/opt/tongsuo/lib64./config --prefix=/opt/tongsuo -Wl,-rpath,/opt/tongsuo/lib enable-zkp-gadget enable-bulletproofs enable-nizk enable-twisted_ec_elgamal enable-ec_elgamal\n需要修改你的Tongsuo安装目录，以及参数最后的依赖目录，这将决定range_proof.c的密码学库指向哪种依赖。\n","categories":["零知识证明"],"tags":["零知识证明"]},{"title":"隐私计算","url":"/posts/b6d1aa03.html","content":"\n隐私计算\n什么是隐私计算\n百度百科：隐私计算(Privacy compute 或Privacy computing)是指在保护数据本身不对外泄露的前提下实现数据分析计算的技术集合，达到对数据“可用、不可见”的目的；在充分保护数据和隐私安全的前提下，实现数据价值的转化和释放。\n简单来说：隐私+技术=数据可用不可见\n\n隐私计算前景\n隐私数据相关法律法规\n目前，随着智能化社会的日益推广，许多人都意识到隐私和数据的重要性，各国政府和组织机构，从政策法规层面进行了规范，如下：\n\n\nGDPR全称General Data Protection Regulation，中文是通用数据保护条例，是在欧盟法律中对所有欧盟个人关于数据保护和隐私的规范，主要目标为取回个人对于个人数据的控制，以及为国际商务而简化在欧盟内的统一规范。\n\n\n2021年8月，美国通过UPDPA，《统一个人数据保护法》，是旨在统一州隐私立法的示范法案。\n\n\n2021年6月《中华人民共和国数据安全法》（以下称《数据安全法》）历经三审三读，于2021年6月10日经第十三届全国人民代表大会常务委员会第二十九次会议通过。\n\n\n行业前景\n隐私计算概述\n隐私计算本质上是在保护数据隐私的前提下，解决数据流通、数据应用等数据服务问题，在保证数据提供方不泄露原始数据的前提下，对数据进行计算、分析与建模的一系列信息技术，涵盖数据的产生、采集、存储、计算、应用、销毁等数据流转的全生命周期。说得更通俗一些，就是在保证数据安全的前提下，让数据可以自由流通或共享，消除数据孤岛问题，从而释放更大的数据价值，提升生产效率，推进产业创新。\n隐私计算技术路线\n隐私计算的理念包括“数据可用不可见，数据不动模型动”，“数据可用不可见，数据不动模型动”。这门技术综合性强，涉及众多领域，包括数学，密码学，高性能计算，传统机器学习框架与算法。网络安全体系，隐私计算基础技术等等。\n根据目前市场上隐私计算的主要相关技术特性，整体总结可分为三大方向与五大基座\n三大方向：安全多方计算（MPC），可信执行环境（TEE），联邦学习（FL）\n五大基座：\n\n基座一：隐私计算基础组件，包含同态加密、秘密分享、不经意传输、混淆电路等；\n基座二：传统的安全机制，包含网络安全、主机安全、破解与反破解（横向联邦需要端侧计算的能力，需要安全防护）\n基座三：机器学习能力，传统机器学习与深度学习的算法与框架能力\n基座四：工程架构，分布式、高并发、大数据、实时计算等\n基座五：数学与密码学知识，传统学科知识，例如数学、统计学习、密码学等；\n\n","categories":["隐私计算"],"tags":["隐私计算"]},{"title":"隐私，安全及机器学习","url":"/posts/ecc00b19.html","content":"\n\n面向隐私保护的机器学习\n不断发生的数据泄露和隐私侵权事件使得社会公众更加认识到，在人工智能系统的构建与使用中，需要保护用户隐私和数据机密性，由此产生的系统便称作面向隐私保护的机器学习（Privacy-Preserving Machine Learning，PPML）系统。\n我们对于信息安全有如下定义：由个人，团体或机构自行决定何时，如何以及在多大程度上将有关他们的信息传达给他人。\n面向隐私保护的机器学习与安全机器学习\n我们首先要分清PPML和安全机器学习（Secure ML）的区别。这二者的区别在于它们被设计用来应用不同类型的安全威胁。在安全机器学习中，敌手被假设违反了机器学习系统的完整性和可用性。在PPML中，递手被假设违反了机器学习的隐私性和机密性\n完整性（Integrity）\n对完整性的攻击可能导致机器学习系统会出现检测错误，例如可能会将入侵点检测为正常。\n可用性（Availability）\n对可用性的攻击可能导致系统会出现分类错误（假阴性和假阳性），即系统会变成不可用的。这是比完整性攻击更宽泛的一种攻击类型。\n机密性（Confidentiality）\n对机密性的攻击可能会导致一些机器学习系统中的敏感信息（如训练数据或训练模型）出现错误。\n威胁与安全模型\n隐私威胁模型\n在机器学习任务中，参与方会扮演三种不同的角色\n\n输入方：数据的原始拥有者\n计算方：模型建立者和推理服务提供者\n结果方：模型查询者和用户\n\n对机器学习系统的攻击可能在任何阶段发生，包括数据发布，模型训练和模型推理。在模型训练阶段发生的攻击叫做重构攻击，在数据发布阶段，发生模型反演攻击，成员推理攻击，特征推理攻击。\n重构攻击\n在模型的训练期间抽取训练数据，或抽取训练数据的特征向量。\n在集中式学习中，来自不同数据方的数据被上传至计算方，这使得数据很容易受到敌手的攻击。大型企业可能会从用户中收集原始数据，然而收集到的数据可能会用于其他目的或者是未经用户知情同意便传达给第三方。\n在联邦学习中，每一个参与方使用自己的本地数据来训练机器学习模型，只将模型的权重更新和梯度信息与其他参与方共享。\n然而，如果数据结构是已知的，梯度信息可能也会被利用，从而泄露关于训练数据的额外信息\n为了抵御重构攻击，应当避免使用明文存储特征值的机器学习模型，例如**支持向量机（SVM）和k-近邻（kNN）**模型。\n模型反演攻击\n从模型中抽取训练数据或训练数据的特征向量。\n对于白盒访问，攻击方不需要存储特征向量便能获取模型的明文内容。对于黑盒访问，攻击方只能查询模型的数据和收集返回结果。\n理论上，对于一个NNN维的线性模型，一个敌手可以通过N+1N+1N+1次查询来窃取整个模型的内容。该问题的形式化是从(X,hθ(x))(X,h_\\theta(x))(X,hθ​(x))中求解θ\\thetaθ；攻击方能通过“查询-回应”过程对来模拟出一个与原始模型相似的模型。\n为了抵御模型反演攻击，应当向敌手暴露尽可能少的关于模型的信息，对模型的访问应当被限制为黑盒访问，模型输出同样应当受限。\n成员推理攻击\n判断模型的训练集中是否包含特定的样本。\n攻击者被假设为对模型拥有白盒访问权限或黑盒访问权限和一个样本，通过机器学习模型的输出试图推断此样本是否属于模型的训练集。攻击者的目标是获知给定样本是否在模型的训练集中。\n特征推理攻击\n攻击者出于恶意目的，将数据去匿名化或锁定记录的拥有者。\n在数据被发布之前，通过删除用户的个人可识别信息（也称为敏感特征）来实现匿名化，是保护用户隐私的一种常用方法。\n攻击者和安全模型\n现阶段对于PPML技术，设计两种类型的敌手：\n\n半诚实（Seni-honest）的敌手，在半诚实敌手模型中，敌手诚实地遵守协议，但也会试图从接收到的信息中学习更多除输出以外的信息。\n恶意（Malicious）的敌手，在恶意的敌手模型中，敌手不遵守协议，可以执行任意的攻击行为。\n\n在联邦学习中，诚实地遵守协议是对各方都有利的，恶意的行为也会损害敌手自身的利益。另外，在密码学中首先建立一个针对半诚实的敌手的安全协议是一种标准的方法，然后可以通过零知识证明对其进行加强，进而防御恶意的敌手的攻击。\n","categories":["联邦学习"],"tags":["联邦学习"]},{"title":"随机数","url":"/posts/7c9eec8d.html","content":"\n安全随机数生成\n在密码学中，随机性是不可或缺的一个角色。许多密码学算法都要求使用一个不可预测的随机数，只有在生成的随机数不可预测时，这些算法才可以保证足够的安全性。例如MAC 算法中的 key，ElGamal，ECC算法的k。\n另外许多高性能算法如快速排序，布隆过滤器都依赖于随机性，如果随机性可以被预测，或者能够找到特定的输入值使这些算法变慢，那么黑客就有攻击可循。\npython随机数\n在python中最简单方便的是使用random生成随机数。\n#需要的库import randomimport string#random.randint(a,b) 在[a,b]内生成随机数random.randint(1,50)#随机生成最小值为1，最大值为50的整数（可以等于上下限）random.randint(20, 20)  #上下限一样时结果永远是20 #random.randrange(a, b), random.randrange([start], stop[, step]), [a,b)random.randrange(0, 101, 2)#0-1之间的随机浮点数random.random() #用于生成一个0到1的随机符点数: 0 &lt;= n &lt; 1.0#随机浮点数：random.uniform(a, b)random.uniform(1, 10)  #随机生成1到10之间的浮点数，可等于1或10random.uniform(10, 1)  #随机生成1到10之间的浮点数，可等于1或10\n但很显然，这种随机数生成的方式并不安全。\nPRNG 伪随机数生成器\nPseudo-Random Number Generators(PRNG) 是一种数字序列的生成算法，它生成出的数字序列的统计学属性跟真正的随机数序列非常相似，但它生成的伪随机数序列并不是真正的随机数序列！因为该序列完全依赖于提供给 PRNG 的初始值，这个值被称为 PRNG 的种子。\nPRNG的算法流程如下，每次迭代都会生成一个新的伪随机数。\n\n实际上目前也有所谓的「硬件随机数生成器 TRNG」能生成出真正的随机数，但是因为 PRNG 的高速、低成本、可复现等原因，它仍然被大量使用在现代软件开发中。\nPRNG 的实现\nimport hmac, hashlibdef random_number_generator(seed: bytes, max_num: int):  state = seed  counter = 0  while True:    state = hmac.new(state, bytes(counter), hashlib.sha1).digest()        counter += 1    # 这里取余实际上是压缩了信息，某种程度上说，这可以保证内部的真实状态 state 不被逆向出来    yield int.from_bytes(state, byteorder=&quot;big&quot;) % max_num# 测试下，计算 20 个 100 以内的随机数gen = random_number_generator(b&quot;abc&quot;, 100)print([next(gen) for _ in range(20)])\n如果初始的 PRNG 种子是完全不可预测的，PRNG 就能保证整个随机序列都不可预测。\n因此在 PRNG 中，生成出一个足够随机的种子，就变得非常重要了。\nCSPRNG\nCryptography Secure Random Number Generators(CSPRNG) 是一种适用于密码学领域的 PRNG，一个 PRNG 如果能够具备如下两个条件，它就是一个 CSPRNG:\n\n能通过「下一比特测试 next-bit test」：即使有人获知了该 PRNG 的 k 位，他也无法使用合理的资源预测第 k+1 位的值\n如果攻击者猜出了 PRNG 的内部状态或该状态因某种原因而泄漏，攻击者也无法重建出内部状态泄漏之前生成的所有随机数\n\n有许多的设计都被证明可以用于构造一个 CSPRNG:\n\n基于计数器(CTR)模式下的安全分组密码、流密码**或**安全散列函数的 CSPRNG\n基于数论设计的 CSPRNG，它依靠整数分解问题（IFP）、离散对数问题（DLP）或椭圆曲线离散对数问题（ECDLP）的高难度来确保安全性\nCSPRNG 基于加密安全随机性的特殊设计，例如 Yarrow algorithm 和 Fortuna，这俩分别被用于 MacOS 和 FreeBSD.\n\n大多数的 CSPRNG 结合使用来自 OS 的熵与高质量的 PRNG，并且一旦系统生成了新的熵（这可能来自用户输入、磁盘 IO、系统中断、或者硬件 RNG），CSPRNG 会立即使用新的熵来作为 PRNG 新的种子。 这种不断重置 PRNG 种子的行为，使随机数变得非常难以预测。\npython中可以使用secrets模块来实现CSPRNG\nsecrets模块：\npython的secrets库是在Python 3.6中引入的，它提供了生成加密安全随机数的函数。其中包括下面的几个函数：\n\nsecrets.token_bytes(nbytes=None)：返回一个指定长度的随机字节数组。\nsecrets.token_hex(nbytes=None)：返回一个指定长度的随机十六进制数字符串。\nsecrets.token_urlsafe(nbytes=None)：返回一个指定长度的随机URL安全的Base64编码字符串，去掉了’='字符。\n\n这些函数的实现使用的是安全的随机数发生器，因此生成的随机数可以用于密码学应用程序等需要高安全性的场合。\n#生成一个指定长度的随机十六进制数字符串import secretsprint(secrets.token_hex(16))  # 生成一个16字节的随机十六进制数字符串\n使用 Python 实现一个简单但足够安全的随机密码生成器：\nimport stringimport secrets# 定义密码生成函数def generate_password(length: int) -&gt; str:    # 定义所有可用的字符集合    alphabet = string.ascii_letters + string.digits + string.punctuation    # 使用 secrets 模块生成随机密码    password = &#x27;&#x27;.join(secrets.choice(alphabet) for i in range(length))    return password# 调用函数生成密码password = generate_password(16)print(password)\n","categories":["密码学基础"],"tags":["密码学基础"]},{"title":"零知识证明","url":"/posts/63b33bfc.html","content":"\n零知识证明\n零知识证明（Zero Knowledge Proof）由S.Goldwasser、S.Micali 及 C.Rackoff于1985年在论文《The Knowledge Complexity of Interactive Proof Systems》（交互式证明系统中的知识复杂性）首次提出，是一种用于证明者在不泄露任何其他信息的情况下证明其掌握知识正确性的密码学协议。零知识证明目前有多种实现方式，如zk-SNARKS、zk-STARKS、PLONK以及Bulletproofs。每种方式在证明大小、证明者时间以及验证时间上都有自己的优缺点。\n\n该协议的一方称为证明者（Prover），用PPP表示；另一方称为验证者（Verifier），用VVV表示。零知识证明指PPP试图使VVV相信某个论断是正确的，但却不向VVV泄露任何有用的信息，即PPP在论证的过程中VVV得不到任何有用的信息。零知识证明除了证明证明者论断的正确性外不泄露任何其他信息或知识。\n零知识证明一般包含以下阶段：\n\n\n承诺（Commit）：证明者针对命题做出承诺，该承诺等待验证者提出挑战并进行验证。\n\n\n挑战（Challenge）：验证者选择随机数（即上述例子中的行、列或格）对提出的承诺进行挑战。\n\n\n回应挑战（Response）：证明者将收到的随机数结合给出的承诺（承诺不可修改），返回挑战的回应。\n\n\n验证（Verify）：验证者验证挑战的回应是否正确，如果错误，则证明失败。\n\n\n证明者与验证者重复执行以上步骤，直到可以相信的概率达到验证者接受的条件，证明成功。\n零知识证明具有以下特点：\n完备性（Completeness）：如果证明者和验证者都是诚实的，并遵守证明过程的每一步进行正确的计算，则该证明一定会成功，验证者也一定能够接受证明者；\n合理性（Soundness）：没有人能够假冒证明者，从而使这个证明成功；\n零知识性（Zero-Knowledge）：证明过程执行完后，验证者只会得悉&quot;证明者拥有这项知识&quot;，而没有获得关于这项知识本身的任何信息。\n零知识证明的例子\n山洞问题\n如果要用一个概念直观地解释零知识证明如何证明用户拥有数据，可以想象一个山洞只有一个入口，洞里面有两条路（路径A和路径B），这两条路由一扇门连接，要说出密码才能通过这扇门。\nAlice希望向Bob证明她知道开门的密码，但不想将密码透露给Bob。因此，Bob需要站在山洞外，Alice从其中一条路走进山洞，而Bob并不知道她选了哪条路。接着，Bob指定Alice从其中一条路回到山洞入口（注：这是随机选择的）。\n如果Alice最初选择从路径A走到门口，但Bob让她从路径B回来，唯一的方法就是穿过那扇门，而穿过门必须知道密码。为了充分证明Alice真的知道门的密码，而不是运气好刚好选到了同一条路，这个过程可以反复重复好几次。\n这一步操作完成后，Bob就可以非常确信Alice知道门的密码，与此同时Alice也不用向Bob透露密码是什么。虽然以上只是零知识证明机制简单的概念演示，但真正的零知识证明运用的是密码学，在不透露数据的情况下证明数据的存在。在这个山洞的示例中有一个输入数据，一条路径和一个输出数据。在计算机中也存在类似的系统和电路，传入数据，数据通过某些电路门之后再输出。零知识证明利用了类似这种电路机制来创建证明。\n\n红绿色盲问题\nQ：有两颗形状、大小完全一样的球：一颗红球、一颗绿球，X XX是红绿色盲，Y YY能够向X XX证明这两颗球是一红一绿吗？\nA：X左手拿着红球，右手拿着绿球，并在背后不让Y看到，进行交换（或者不交换）两只球\nY能够根据颜色精准判断X是否进行了交换\n执行上述操作N次后，即能在X是色盲的情况下，Y仍能够向X证明能这两颗球是一红一绿\n数独问题\n假设PPP给出一道数独题目，由VVV来完成，但VVV过了很久都未能解出，他怀疑该数独题目没有解，要求PPP证明该题目有解。因此PPP希望在不告诉VVV答案相关的任何信息的情况下证明这道题有解且自己知道这个解。\n1）承诺\nPPP将答案的每个数字写在纸片上，并按照答案摆放(正面朝下)，题目中已有的数字正面朝上，这81个纸片的放置为PPP的“承诺”。\n2）挑战\nVVV不能直接将纸片翻转查看数字，但是VVV可以在行、列、格中任意指定一种验证方式。如图所示，VVV选择按照行的方式进行挑战。\n3）挑战回应\nPPP按照VVV选择行验证方式将桌面上每行的9张卡片装入一个袋子里，并且将纸片进行混淆后，把袋子交给VVV，作为挑战的回应。\n4）验证\nVVV打开纸袋可验证每个纸袋里的9张纸片刚好为1 − 9，即PPP在承诺阶段做出的承诺满足“每行1 − 9都出现且只出现一次”的要求，同时在一定程度上说明PPP做出的承诺很可能是一个合法的解（因为随意给出的数字不会满足这一要求，并且在承诺的时候并不知道VVV会选择行、列、格哪种验证方式）。\n三染色问题\n如何用三种颜色染色一个地图，保证任意两个相邻的地区都是不同的颜色。\n该问题可转变成连通图的顶点三染色问题，即不同城市（节点）之间修建了一些道路（边），是否存在一种染色方式，使得每个城市都用特定的三种颜色之一表示，并且任意有道路相连的两个城市都不是相同颜色。\n思路：\n1）Alice 先要对染过色的图进行一些变换，把颜色做一次全改，例如把所有的绿色变成橙色，把所有的黄色变成蓝色，把所有的红色变成粉色。然后 Alice 得到了一个新的染色答案，这时候她把新的图的每一个顶点都用纸片盖上，然后出示给 Bob 看。\n2）Bob要随机挑选一条边，并由Alice揭开这条边两端的纸片，让Bob检查，Bob发现这两个顶点的颜色是不同的，那么Bob认为这次检验同构。\n经过多次验证，可以证明Bob认为这个图满足三染色的要求。\n","categories":["零知识证明"],"tags":["零知识证明"]},{"title":"零知识证明zk-SNARKs","url":"/posts/6c3f0187.html","content":"\n本文介绍经典零只是证明协议——zk-SNARKs\n\nzk-SNARK 算法简介\nzk-SNARK 是 zero-knowledge succint non-interactive arguments of knowledge 的简称，其中：\n非交互指的是 Prover 和 Ver­i­fier 之间可以不进行任何的交互（P 和 V 来回发送消息）\n零知识允许 Prover 向 Ver­i­fier 证明一项陈述为真，而不泄露除了该陈述为真以外的任何有效的信息（比如给定一个随机数的散列，Prover 可以向 Ver­i­fier 证明其知道这个随机数而不透露这个数）\n简洁则意味着证明可以在短时间内完成（比如毫秒级别的时间），即便对于非常大的陈述而言证明也是非常快的，且不需要太多的通信量（仅需要几百字节）\n因为以往的交互式证明系统中 P 和 V 需要互相发送消息，甚至为了降低合理性错误需要很多的交互轮次，从而导致通信量急剧增加，而非交互的简洁的结构中，P 可以仅向 V 发送一个包含少量自己的消息就可以完成验证，为了做到这种短到足以让其发布到区块链上的非交互式的证明，目前采用的方法是 P 和 V 之间生成一个 CRS 并将其作为公共参数（参见之前的文章），从而完成证明。\nzk-SNARKs的构建方式\nzk-SNARKs 先将需要证明的内容转化为一系列代数方程的解的形式，具体而言是先将计算转化为算术电路，再到 R1CS，QAP，最后到 zk-SNARKs\n在这个过程中，需要将验证交易合法性的函数转化为一个数学表达式，第一步是将逻辑步骤分解为尽可能小的操作，即创建一个算术电路，这和布尔电路类似（程序被编译为离散的单个步骤，如 AND、OR、NOT 等），转换为算术电路后，函数就分解为加减乘除等基本算术运算（特殊情况下会尽可能避免除法，或直接不使用除法）\n比如说想要计算表达式(a+b)∗(b∗c)(a+b)*(b*c)(a+b)∗(b∗c)，转化为下面这个算术电路\n\n上述电路中各个输入按照表达式经过对应的门，最终达到输出，接下来是建立一阶约束系统（R1CS），以检查值是否正确的经过了应当经过的门，比如在上述例子中，R1CS 会检查 Gate2 的输出是否是b∗cb*cb∗c\n在 R1CS 中，Ver­i­fier 必须检查许多约束条件（几乎电路中的每一个路径都有一个约束条件），然后是将所有的约束条件捆绑在一起\n","categories":["零知识证明"],"tags":["零知识证明"]},{"title":"非对称密码体制","url":"/posts/2933aa2b.html","content":"加密-非对称技术\n\n在公钥密码体制中，加密不用密钥，密钥仅在解密阶段使用，Diffie和Hellman描述了几个可能用来实现公钥密码的数学变换，它们称之为单向陷门函数。\n单向陷门函数 单向陷门函数 ft(x):D→Rf_t(x):D\\rarr Rft​(x):D→R，是一个单向函数，即对任意的 x∈Dx\\in Dx∈D，容易计算，而对几乎所有的 x∈Dx\\in Dx∈D，求逆困难，但是如果知道陷门信息 ttt ，则对所有的 y∈Ry \\in Ry∈R，容易计算满足 y=ft(x)y=f_t(x)y=ft​(x) 的 x∈Dx\\in Dx∈D。\n\nDiffie-Hellman密钥交换协议\n与对称密码体制相比，公钥密码体制的一个显著优点就是远程通信各方无需安全信道就能实现相互交换密钥。最早实现这一点的方案是Diffie-Hellman指数密钥交换协议。\n首先，假设用户Alice和Bob约定有限域FqF_qFq​和元素 g∈Fpg\\in F_pg∈Fp​，g生成一个群。为简化，我们考虑有限域 FpF_pFp​，p为素数。协议如下：\n协议：Diffie-Hellman密钥交换协议\n共同输入 (p，g)：p为大素数，g为FqF_qFq​ 的生成元。\n输出：Alice和Bob共享FpF_pFp​ 中的一个元素\n\n\nAlice选择 a∈[1,p−1)a \\in [1,p-1)a∈[1,p−1)，计算 ga=ga(modp)g_a=g^a(modp)ga​=ga(modp)，发送gag_aga​给Bob\n\n\nBob选择 b∈[1,p−1)b \\in [1,p-1)b∈[1,p−1)，计算 gb=gb(modp)g_b=g^b(modp)gb​=gb(modp)，发送gbg_bgb​给Alice\n\n\nAlice计算 k=gba(modp)k=g_b^a(modp)k=gba​(modp)\n\n\nBob计算 k=gba(modp)k=g_b^a(modp)k=gba​(modp)\n\n\n可以不难看出，对于Alice和Bob都有: k=gabmodpk=g^{ab}modpk=gabmodp\n中间人攻击\n处于Alice和Bob通信中间的主动攻击者能够操纵这个协议的消息以达到成功的攻击，称为中间人攻击。\n在对协议运行的攻击当中，Malice截获Alice发送给Bob的第一条消息gag_aga​，并伪装成Alice向Bob发送消息。\nMalice发送给Bob：gm(modp)g_m(modp)gm​(modp)\nBob将按照协议的规则回复gbg_bgb​给Malice，这个发送的数值再一次被Malice截获，现在M和B写上了一个密钥gbm(modp)g^{bm}(modp)gbm(modp)，而Bob以为这个密钥就是他和Alice所共享的密钥。\n\n\nAlice选择 a∈[1,p−1)a \\in [1,p-1)a∈[1,p−1)，计算 ga=ga(modp)g_a=g^a(modp)ga​=ga(modp)，发送gag_aga​给Malice(’“Bob”)\n\n1`. M(“Alice”)对某个 m∈[1,p−1)m \\in [1,p-1)m∈[1,p−1),计算gm=gm(modp)g_m=g^m(modp)gm​=gm(modp)\n\nBob选择 b∈[1,p−1)b \\in [1,p-1)b∈[1,p−1)，计算 gb=gb(modp)g_b=g^b(modp)gb​=gb(modp)，发送gbg_bgb​给Malice(“Alice”)\n\n2`. M(“B”)向A发送：gmg_mgm​\n\n\nAlice计算 k1=gma(modp)k_1=g_m^a(modp)k1​=gma​(modp)\n\n\nBob计算k2=gmb(modp)k_2=g_m^b(modp)k2​=gmb​(modp)\n\n\nDiffie-Hellman问题和离散对数问题\nDH密钥交换协议中共享密钥的保密性就是已知ga,gbg_a,g_bga​,gb​，计算gab(modp)g^{ab}(modp)gab(modp)的问题，这个问题被称为CDH。\nCDH 输入：Fq,g,ga,gbF_q,g,g^a,g^bFq​,g,ga,gb，输出：gabg^{ab}gab\n如果CDH问题是容易的，则gab(modp)g^{ab}(modp)gab(modp)可以由p,g,ga,gbp,g,g_a,g_bp,g,ga​,gb​来计算得到，而这些参数是作为协议消息的一部分传送的。\n进一步，CDH问题是基于**离散对数问题（DL）**的困难性。\nDL 输入： Fq,g,hF_q,g,hFq​,g,h，输出：唯一的整数a，满足h=gah=g^ah=ga，我们用 logghlog_ghlogg​h来表示整数a\nRSA密码体制\nRSA是最熟悉的公钥密码体制，是基于DH所想象的单向陷门函数的定义，而给出的第一个公钥密码的实现。\nRSA密码体制\n密钥建立\n为了生成用户的基本参数，A执行以下步骤：\n\n\n随机选择两个素数p和q，p≈qp\\approx qp≈q\n\n\n计算N=pq\n\n\n计算 ϕ(N)=(p−1)(q−1)\\phi (N) =(p-1)(q-1)ϕ(N)=(p−1)(q−1)\n\n\n随机选择整数 e&lt;ϕ(N)e &lt; \\phi(N)e&lt;ϕ(N)，满足gcd(e,ϕ(N))=1gcd(e,\\phi(N))=1gcd(e,ϕ(N))=1，并计算整数d满足ed≡1(modϕ(N)ed \\equiv1 (mod\\phi(N)ed≡1(modϕ(N)\n\n\n公开公钥(N,e)(N,e)(N,e)，安全销毁p,q,ϕ(N)p,q,\\phi(N)p,q,ϕ(N)，并保留ddd作为私钥\n\n\n加密\n为了秘密的发送m给A，发送者B生成密文c如下：\nc←me(modN)c \\larr m^e(modN)c←me(modN)\n解密\n为了解密密文c，A计算 m←cd(modN)m \\larr c^d(modN)m←cd(modN)\n公钥密码体制的分析\n密码体制的安全性是根据攻击来定义的，\n密码体制的主动攻击\n选择明文攻击（CPA） 攻击者选择明文消息并得到加密服务，产生相应的密文。攻击者的任务是用所得到的明-密文来降低目标密码体制的安全性。\n选择密文攻击（CCA） 攻击者选择密文消息并得到解密服务，产生相应的明文。攻击者的任务是用所得到的明-密文对来降低目标密码体制的安全性。在解密服务停止后，即在得到目标密文之后，解密服务立即停止，如果攻击者能够从“目标密文”中得到保密明文的信息，则就说明攻击是成功的。\n适用性选择密文攻击（CCA2） 这是一个CCA，而且除了对“目标密文”解密外，永远能够得到解密服务。\n我们可以用以下情形来想象上述攻击类型：\n\n在CPA中，攻击者有一个加密盒子\n在CCA中，攻击者可以有条件地使用解密盒子，在交给攻击者目标密文之前关闭解密盒子。\n在CCA2中，在攻击者得到目标密文之前或之后，只要攻击者不把目标密文输入解密盒子，他就可以一直使用这个解密盒子。\n\n在所有的情况下，攻击者都不应该拥有相应的密钥。\nRSA问题\n抵抗CPA，RSA的安全性基于计算密文CCC模合数nen^ene的困难性，这就是RSA问题。\nRSA问题\n输入：n=pqn=pqn=pq，pq均是素数，e满足gcd(e,((p−1)(q−1)))=1gcd(e,((p-1)(q-1)))=1gcd(e,((p−1)(q−1)))=1，c\n输出：唯一的整数m，满足me≡c(modN)m^e \\equiv c (modN)me≡c(modN)\nRSA假设 RSA算法是一个PPT算法AAA，对于一个概率ϵ&gt;0\\epsilon &gt; 0ϵ&gt;0满足：\nϵ=Prob[m←A(N,e,me(modN))]\\epsilon = Prob[m\\larr A(N,e,m^e(modN))]ϵ=Prob[m←A(N,e,me(modN))]\n令IgIgIg是一个RSA生成器，输入1k1^k1k，在k的多项式时间内输出（i）一个2k比特的模N=pq，其中p和q是两个不同的均匀分布的素数，长度均为k比特，（ii）e∈Z(p−1)(q−1)∗e\\in Z^*_{(p-1)(q-1)}e∈Z(p−1)(q−1)∗​\n我们说满足RSA假设，如果对于所有充分大的k，对于k不可忽略的概率ϵ&gt;0\\epsilon&gt;0ϵ&gt;0不存在Ig(1k)Ig(1^k)Ig(1k)满足所产生的RSA问题的求解算法。\n强RSA问题 对于某些奇数的加密指数e&gt;1e&gt;1e&gt;1，可能是根据算法的选择，已知这样的e，解RSA问题。普遍认为强RSA问题仍然是不可求解的，所以某些加密算法或者协议的安全性基于这个困难性。\n整数分解问题\nRSA问题的困难性依赖于整数分解问题的困难性\n整数分解问题（IF） 输入：N，奇合数，至少有两个素因子\n输出：素数p满足p∣Np|Np∣N\n一个能解决IF问题的算法就能解决RSA问题，因为Alice知道了大整数N的分解，就能先计算出d≡e−1mod(p−1)(q−1)d\\equiv e^{-1}mod(p-1)(q-1)d≡e−1mod(p−1)(q−1)，从而可准确地对RSA密文解密。\n","categories":["密码学基础"],"tags":["非对称密码"]},{"title":"solana开发","url":"/posts/69939f56.html","content":"\nSolana入门\nSolana Playground 提供了一个基于浏览器的开发环境：https://beta.solpg.io/\n基础概念：\n\n\n钱包地址：一个由 Ed25519 keypair 生成的 32 字节公钥，通常显示为 base-58 编码的字符串\n\n\n常见的集群：\ndevnet：开发网络\ntestnet：测试网络\nmainnet-beta：实时交易的网络\n\n\n","categories":["solana"],"tags":["solana开发"]}]