<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AKE</title>
    <url>/posts/9b221d34.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="AKE"><a href="#AKE" class="headerlink" title="AKE"></a>AKE</h1><p>本文将介绍密码学中的经典算法：密钥认证交换技术。以及一些常见的AKE及其变体。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>密码学基础</category>
      </categories>
      <tags>
        <tag>密钥认证交换</tag>
      </tags>
  </entry>
  <entry>
    <title>Bulletproofs</title>
    <url>/posts/8b0de499.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>本文将介绍Bulletproofs，是一种简短的非交互式零知识证明，不需要可信设置。</p>
<span id="more"></span>
<h1 id="Bulletproofs"><a href="#Bulletproofs" class="headerlink" title="Bulletproofs"></a>Bulletproofs</h1><p>Bulletproofs是是一种简短的非交互式零知识证明，不需要可信设置。<a href="https://crypto.stanford.edu/bulletproofs/">STF官网介绍</a>，<a href="https://eprint.iacr.org/2017/1066.pdf">论文网址</a></p>
<p>防弹可用于让验证者相信加密的明文格式良好。例如，证明加密数字在给定范围内，而不泄露有关该数字的任何其他信息。与SNARK相比，Bulletproof 不需要可信设置。然而，验证防弹证明比验证 SNARK 证明更耗时。</p>
<p>Bulletproof 在加密协议中还有许多其他应用，例如缩短偿付能力证明、简短的可验证洗牌、机密智能合约以及作为 Sigma 协议的通用替代品。</p>
<h1 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h1>]]></content>
      <categories>
        <category>零知识证明</category>
      </categories>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>GSW同态加密</title>
    <url>/posts/1a0df74e.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="同态加密GSW方案"><a href="#同态加密GSW方案" class="headerlink" title="同态加密GSW方案"></a>同态加密GSW方案</h1><p>本文将介绍同态加密中的一个方案——GSW，它利用近似特征向量技术，设计了无需计算密钥的全同态加密方案。原论文：《Homomorphic Encryption from Learning with Errors: Conceptually-Simpler, Asymptotically-Faster, Attribute-Based》</p>
<span id="more"></span>
<h1 id="GSW整体思想"><a href="#GSW整体思想" class="headerlink" title="GSW整体思想"></a>GSW整体思想</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>矩阵有着这样的一个性质：一个矩阵$C$乘以$v$等于一个特征值乘以$v$，$v$是这个矩阵的特征向量，$\mu$是特征值:$C\cdot v =\mu \cdot mod \ q$</p>
<p>那么，我们现在可以把$C$看作密文，$v$看作密钥，要加密的消息是$\mu$: </p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307302022806.png" alt></p>
<p>很容易可以发现这个形式具有同态的性质：密文的加或乘相当于明文的加或者乘。</p>
<script type="math/tex; mode=display">
C_1\cdot v=\mu_1 \cdot v\ mod \ q \\
C_2\cdot v=\mu_2 \cdot v\ mod \ q \\
C_1\cdot C_1\cdot v=\mu_1\cdot \mu_2 \cdot v\ mod \ q</script><p>然而，这个形式虽然具有同态的性质，但是很明显非常的不安全，因为找到一个<strong>矩阵的特征向量</strong>很简单，密钥很容易得到。为了保证安全性，我们可以将其转换为 LWE 的形式：</p>
<p>$C\cdot v =\mu \cdot v +e \ mod \ q$，</p>
<p>其中，$C$代表密文，$\mu$代表消息，$e$代表密钥，是系数很小的噪声向量($e&lt;&lt;q$)，$v$是一个近似特征向量。</p>
<h2 id="同态性质"><a href="#同态性质" class="headerlink" title="同态性质"></a>同态性质</h2><p>我们来验证一下这个方案的同态性质：</p>
<p>$C_1\cdot v =\mu_1 \cdot v +e_1 \ mod \ q,\ C_2\cdot v =\mu_2 \cdot v +e_2 \ mod \ q$</p>
<p>加法运算:$(C_1+C_2)\cdot v=(\mu_1+\mu_2)\cdot v +(e_1+e_2)\ mod\ q$</p>
<p>乘法运算：$(C_1 \times C_2)\cdot v =C_1\cdot (\mu_2\cdot v+e_2)=(\mu_1\cdot \mu_2)\cdot v+(\mu_2\cdot e_1+C_1\cdot e_2)$</p>
<p>同态加法和乘法满足，但乘法会导致额外噪声的出现。</p>
<h2 id="噪声处理"><a href="#噪声处理" class="headerlink" title="噪声处理"></a>噪声处理</h2><p>为了让这个噪声项尽量小，我们对这个新的噪声进行分析：</p>
<ul>
<li>可以减小$\mu_2$，即让消息空间变小。要达到这个目的仅需将消息空间设置成${0,1}$即可。GSW 方案中使用与非门 (NAND gats) 可将消息空间设置成${0,1}$。</li>
<li>可以使密文 $C$变小。密文可能是两个密文的乘法，即使初始的密文很小，计算后也可能得到较大的密文。是否能有什么技术能够使得密文一直保持在很小的范围内（甚至在 {0, 1} 内）？文中提出一种 Flatten ciphertext 的技术。</li>
</ul>
<h2 id="密文大小限制"><a href="#密文大小限制" class="headerlink" title="密文大小限制"></a>密文大小限制</h2><p>限制密文大小：分解技术</p>
<p>我们有以下定义：</p>
<p>$a\in Z^k_q$其中k是维度，q是模。$l=log_q+1$是q的对数，$N=k\cdot l$</p>
<p>有一些函数：</p>
<ul>
<li>$BitDecomp(a)=(a<em>{1,0},…,a</em>{1,l-1},…,a<em>{k,0},…,a</em>{k,l-1})$是a的每个系数的比特分解，从低位到高位</li>
<li>$BitDecomp^{-1}(b\in Z^N_q)$是上面分解函数的逆分解</li>
<li>$Flattern(b\in Z^N_q)=BitDecomp(BitDecomp^{-1}(b))$是一个系数都在${0,1}$中的向量</li>
<li>$Powersof2(s)=(s_1,2s_1,…,2^{l-1}s_1,…,s_k,2s_k,…,2^{l-1}s_k)$</li>
</ul>
<p>然后我们给出近似特征向量的一个特殊形式：$v=Powersof2(s)$其中s是随机的</p>
<p>开始 Flatten Ciphertext （展平密文）：</p>
<ul>
<li>假设对于一个与非门（NAND）： $C^{NAND}=I_N-C_1\cdot C_2\ mod\ q $</li>
<li>令 $C_3\larr Flatten(C^{NAND})$为$C^{NAND}$每一行的展开结果，$C_3$中所有的系数都在集合${0,1}$中</li>
<li>$C_3\cdot v=C^{NAND}\cdot v\ mod\ q$我们没有改变加密的消息，甚至没有增加噪声。</li>
</ul>
<h1 id="GSW加密方案"><a href="#GSW加密方案" class="headerlink" title="GSW加密方案"></a>GSW加密方案</h1><ul>
<li><p>$Setup(1^n,1^L)$，选择$k=k(\lambda,L)$bit的模q，格的维度参数是$n=n(\lambda,L)$，适当的为LWE取误差分布$X=X(\lambda,L)$使得在已知攻击下达到$2^{\lambda}$的安全性。同时，选择参数$m=m(\lambda,L)=O(nlogq)$，参数$params=(n,q,X,m)$，令$l=log_q+1,N=(n+1)\cdot l$</p>
</li>
<li><p>$KeyGen(params)$，采样$t\larr Z^n_q$，输出$sk=s\larr (1,-t_1,…,-t_n)\in Z_q^{n+1}$，$v\larr Powersof2(s)\in Z_q^N$</p>
</li>
<li><p>$PubKeyGen(params,sk)$，均匀生成一个矩阵$B\larr Z^{m\times n}_q$和一个向量$e\larr \chi ^m$，设$b=B\cdot t+e$，设A为（n+1）列矩阵，设置公钥$pk=A$，公钥可以看作一个LWE实例，是由向量组成的矩阵，且与密钥点积得到的结果很小。</p>
</li>
<li>$Enc(A,\mu)$，为了加密消息$\mu\in Z_q$，均匀采样一个矩阵$R\in {0,1}^{N\times m}$，可得$A\cdot R$的每一行为0的加密，因为他们与密钥的点积的结果非常小，同时输出如下密文:</li>
</ul>
<script type="math/tex; mode=display">
C=Flatten(\mu \cdot I_N+BitDecomp(R\cdot A))\in Z_q^{N\times N}</script><ul>
<li>解密$Dec(C,v)$，计算$C\cdot v=\mu \cdot v+BitDecomp(R\cdot A) \cdot v =\mu \cdot v+ R\cdot A\cdot s=\mu \cdot v+small$</li>
</ul>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307302022949.png" alt="image-20230725195628371"></p>
<ul>
<li>同态操作：在密文上进行加法/乘法后，展平密文。</li>
</ul>
<p><strong>加法</strong>，$Add(C_1,C_2)=Flattem(C_1+C_2)$，噪音为$e_1+e_2$，增长因子为20</p>
]]></content>
      <categories>
        <category>同态加密</category>
      </categories>
      <tags>
        <tag>同态加密</tag>
      </tags>
  </entry>
  <entry>
    <title>LLM</title>
    <url>/posts/d2609092.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="LLM"><a href="#LLM" class="headerlink" title="LLM"></a>LLM</h1><p>大语言模型（large language model，LLM）是一种语言模型，由具有许多参数的人工神经网络组成，使用<strong>自监督学习</strong>或<strong>半监督学习</strong>对未标记文本进行训练。</p>
<span id="more"></span>
<p><strong>大型语言模型被训练来解决通用（常见）的语言问题，如文本分类、问答、文档总结和文本生成等</strong>。</p>
<p>（1）<strong>文本分类</strong>：大型语言模型可以通过对输入文本进行分析和学习，将其归类到一个或多个预定义的类别中。例如，可以使用大型语言模型来分类电子邮件是否为垃圾邮件，或将推文归类为积极、消极或中立。<br>（2）<strong>问答</strong>：大型语言模型可以回答用户提出的自然语言问题。例如，可以使用大型语言模型来回答搜索引擎中的用户查询，或者回答智能助手中的用户问题。<br>（3）<strong>文档总结</strong>：大型语言模型可以自动提取文本中的主要信息，以生成文档摘要或摘录。例如，可以使用大型语言模型来生成新闻文章的概要，或从长篇小说中提取关键情节和事件。<br>（4）<strong>文本生成</strong>：大型语言模型可以使用先前学习的模式和结构来生成新的文本。例如，可以使用大型语言模型来生成诗歌、短故事、或者以特定主题的文章。</p>
<p><strong>大语言模型特征</strong></p>
<p><strong>Large（大）</strong>：在”大语言模型”的上下文中，”大”主要有两层含义。一方面，它指的是模型的<strong>参数数量</strong>。在这些模型中，参数的数量通常会非常大，达到数十亿甚至数百亿。另一方面，”大”也指的是<strong>训练数据的规模</strong>。大语言模型通常在大规模的文本数据上进行训练。</p>
<p><strong>General-purpose（通用）</strong>：这个词描述的是模型的应用范围。通用语言模型在训练时使用了来自各种领域的数据，因此它们能够处理各种类型的任务，不仅限于某一个特定的任务或领域。这使得这些模型在处理新的、未见过的任务时具有很强的泛化能力。</p>
<p><strong>Pre-trained and fine-tuned（预训练和微调）</strong>：这是描述模型训练过程的关键词。在预训练阶段，模型在大规模的通用文本数据上进行训练，学习语言的基本结构和各种常识。然后，在<strong>微调阶段</strong>，模型在更小、更特定的数据集上进行进一步的训练。</p>
<p><strong>大语言模型的好处</strong></p>
<p><strong>单一模型可用于不同任务</strong>：由于大语言模型是通用的，并且具有强大的泛化能力，所以它们可以处理各种类型的任务，比如文本分类、命名实体识别、情感分析、问答系统、文本生成等。这意味着我们可以使用同一个预训练的模型来处理不同的任务，只需要进行相应的微调就可以。这大大减少了开发和维护不同模型的复杂性和成本。</p>
<p><strong>微调过程只需要最小的数据</strong>：尽管大语言模型在预训练阶段需要大量的通用文本数据，但在微调阶段，它们通常只需要相对较小的领域特定数据。这是因为模型在预训练阶段已经学习了大量的语言知识和常识，微调阶段主要是让模型适应特定的任务或领域。这使得大语言模型能够在数据稀缺的领域中也能表现出色。</p>
<p><strong>随着更多的数据和参数，性能持续提</strong>升：大语言模型的性能通常随着训练数据的增加和模型参数的增加而提升。这意味着，通过训练更大的模型，并使用更多的数据，我们可以获得更好的性能。这是因为更大的模型有更多的参数，能够学习和表示更复杂的模式；同时，更多的数据能够提供更丰富的信息，帮助模型更好地理解语言。</p>
]]></content>
      <categories>
        <category>AI安全</category>
      </categories>
      <tags>
        <tag>大语言模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Sigma零知识证明协议</title>
    <url>/posts/8c0d2487.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p><strong>Sigma零知识证明</strong>，知道秘密$\omega$，且与公开输入$Q$满足离散对数关系$Q=\omega G$</p>
<span id="more"></span>
<h1 id="Sigma零知识证明协议"><a href="#Sigma零知识证明协议" class="headerlink" title="Sigma零知识证明协议"></a>Sigma零知识证明协议</h1><p>设关系$R\subseteq X *Y$, 那么<P, v> 构建在R上的一个Sigma 协议为：</P,></p>
<p>P是一个叫证明的交互式协议，其输入为一个witness-statement对$(x,y)\in R$.<br>V是一个叫验证的交互式协议，其输入为一个statement，$y\in R$</p>
<p>P和V交互过程为：</p>
<ol>
<li><p>首先，P计算一个承诺(commitment) t ，将其发送给V；</p>
</li>
<li><p>在收到来自P的消息后，V在有限的挑战空间C中随机选取一个挑战元素(challenge) c，并将其发送给P ；</p>
</li>
<li><p>在接收到来自V的挑战后， P计算出一个反馈(response) z ,将其发送给V</p>
</li>
<li><p>在收到了来自P的反馈后, V输出accept或者reject。</p>
</li>
</ol>
<p>   <strong>例子</strong></p>
<p>1）P计算$h=g^xmod\ p$作为秘密</p>
<p>2）P选择随机数$r\in z_q$，计算$a=g^rmodp$, P将a值发送给V</p>
<p>3）V选择随机数challenge e，V将e值发送给P；</p>
<p>4） P计算$z=r+ex\ mod p$, 将z值发送给V，</p>
<p>5） V判断$g^z=?=ah^emod p$是否成立，同时检验e的哈希结果是否正确，都通过后，则V接受认为P确实知道正确的x.</p>
<h3 id="正确性-completeness"><a href="#正确性-completeness" class="headerlink" title="正确性(completeness)"></a>正确性(completeness)</h3><p>在上面的协议中，正确性意味着如果每个人都遵守协议，那么协议正常执行。在Sigma协议的中，这意味着P和V这么做，V最后应该接受状态。</p>
<h3 id="公平性-special-soundness"><a href="#公平性-special-soundness" class="headerlink" title="公平性(special soundness)"></a>公平性(special soundness)</h3><p>公平性意味着P不能证明一个错误的陈述statement. Sigma协议实现公平的。准确地说，特殊公平性！特殊公平性是说，如果P能让V在挑战中找到两个挑战，那么这两个挑战分别是(e,z)和(e′,z′)。通过代数计算【幂除法】可以得到$d=(e-e^{\prime}),x=d(s-s^{\prime})$。这样计算出x那么只能满足其中一个等式。</p>
<h3 id="零知识性-special-honest-verifier-zk"><a href="#零知识性-special-honest-verifier-zk" class="headerlink" title="零知识性 (special honest verifier zk)"></a>零知识性 (special honest verifier zk)</h3><p>V既不能从协议中知道x的值，而且还不能向第三者，证明V知道这个秘密（即V无法冒充P）。也就是V从协议中什么也没学到（除了P知道x之外）。</p>
<p>sigma协议又称为诚实验证者的（特殊）零知识证明。即假设验证者是诚实的</p>
<p>交互式方式有其应用局限，比如得双方或多方同时在线等。Fiat-Shamir变换，又叫Fiat-Shamir Heurisitc（启发式），或者Fiat-Shamir Paradigm（范式），是Fiat和Shamir在1986年提出的一个变换，其特点是可以将交互式零知识证明转换为非交互式零知识证明。这样就通过减少通信步骤而提高了通信的效率！</p>
<p>该算法允许将交互步骤中随机挑战替换为非交互随机数预言机（Random oracle）。</p>
<p>1）P计算$h=g^xmod\ p$作为秘密</p>
<p>2）P选择随机数$r\in z_q$，计算$a=g^rmodp$, P将a值发送给V</p>
<p>3）P计算$e=Hash(h,a)$</p>
<p>4） P计算$z=r+ex\ mod p$, 将z值发送给V，</p>
<p>5） V判断$g^z=?=ah^emod p$是否成立，同时检验e的哈希结果是否正确，都通过后，则V接受认为P确实知道正确的x.</p>
<h1 id="Sigma协议应用到ElGamal同态加密"><a href="#Sigma协议应用到ElGamal同态加密" class="headerlink" title="Sigma协议应用到ElGamal同态加密"></a>Sigma协议应用到ElGamal同态加密</h1><h2 id="同态密文运算"><a href="#同态密文运算" class="headerlink" title="同态密文运算"></a>同态密文运算</h2><p><strong>密钥生成</strong>：A,B,C,D的私钥和公钥分别是：</p>
<script type="math/tex; mode=display">
A:(\alpha_1,g_1),g_1=g^{\alpha_1}\\
B:(\alpha_2,g_2),g_2=g^{\alpha_2}\\
C:(\alpha_3,g_3),g_3=g^{\alpha_1}\\
D:(\alpha_4,g_4),g_4=g^{\alpha_2}\\</script><p>余额初始状态：</p>
<ul>
<li><p>A余额初始状态密文为$[C_0,D_0]$，其中$C_0=g^{r_0},D_0=g^{m_0}g_1^{r_0}$</p>
</li>
<li><p>B余额初始状态密文为$[C_0^{\prime},D_0^{\prime}]$，其中$C_0^{\prime}=g^{r_0^{\prime}},D_0^{\prime}=g^{m_0^{\prime}}g_1^{r_0^{\prime}}$</p>
</li>
<li><p>C,D起始状态金额为0</p>
</li>
</ul>
<p>A支付给C金额数量为$m_1$，使用ElGamal同态加密生成密文$[C_1,D_1],[C_1^{\prime},D_1^{\prime}]$并生成零知识证明$zkProof$和范围证明$BulletProof$</p>
<ul>
<li>A选择随机数$r_1$，基于C的公钥$g_3$，生成$[C_1,D_1]$</li>
<li>A选择随机数$r_1$，基于自己的公钥$g_1$，生成$[C_1^{\prime},D_1^{\prime}]$</li>
</ul>
<script type="math/tex; mode=display">
C_1=g^{r_1},\ D_1=g^{m_1}g_3^{r_1}\\
C_1^{\prime}=g^{r_1^{\prime}},D_1^{\prime}=g^{m_1^{\prime}}g_3^{r_1^{\prime}}\\
ZK\{r_1,r_1^{\prime},m_1,m_1^{\prime},m_1=m_1^{\prime}|C_1,D_1,C_1^{\prime},D_1^{\prime}\}\\
BulletProof\{0\le m_0-m_1\le2^{32},0\le m_1\le2^{32} \}</script><p>A对交易单签名;矿工验证签名、零知识证明和范围证明。然后:</p>
<ul>
<li>更新C金额记作$[C_1,D_1]$，则C能够解密获得$m_1$并进行支付，解密过程：$g^{m_1}=D_1/(C_1)^{\alpha_3}$</li>
<li>更新A的金额状态记为$[C_0/C_1^{\prime},D_0/D_1^{\prime}]$，则A能过够解密获得$m_0-m_1$并进行支付。解密过程：$g^{m_0-m_1^{\prime}}=(D_0/D_1^{\prime})/(C_0/C_1^{\prime})^{\alpha_1}$</li>
</ul>
<p>C余额增加$m_1$，A余额减少$m_1^{\prime}$</p>
<p>B支付给C金额为$m_2$，使用ElGamal同态加密生成密文$[C_2,D_2],[C_2^{\prime},D_2^{\prime}]$，并生成零知识证明$zkProof$和范围证明$BulletProof$</p>
<script type="math/tex; mode=display">
C_2=g^{r_2},\ D_2=g^{m_2}g_3^{r_2}\\
C_2^{\prime}=g^{r_2^{\prime}},D_2^{\prime}=g^{m_2^{\prime}}g_3^{r_2^{\prime}}\\
ZK\{r_2,r_2^{\prime},m_2,m_2^{\prime},m_2=m_2^{\prime}|C_2,D_2,C_2^{\prime},D_2^{\prime}\}\\
BulletProof\{0\le m_0-m_2\le2^{32},0\le m_2\le2^{32} \}</script><p>B对交易单签名;矿工验证签名、零知识证明和范围证明。然后:</p>
<ul>
<li>更新C金额记作$[C_1C_2,D_1D_2]$，则C能够解密获得$m_1+m_2$并进行支付，解密过程：$g^{m_1+m_2}=D_1D_2/(C_1C_2)^{\alpha_3}$</li>
<li>更新A的金额状态记为$[C_0/C_2^{\prime},D_0/D_2^{\prime}]$，则A能过够解密获得$m_0^{}\prime-m_2$并进行支付。解密过程：$g^{m_0^{\prime}-m_2^{\prime}}=(D_0^{\prime}/D_2^{\prime})/(C_0/C_2^{\prime})^{\alpha_2}$</li>
</ul>
<p>C支付给D金额数量为$m_3$，使用ElGamal同态加密生成密文$[C_3,D_3],[C_3^{\prime},D_3^{\prime}]$，并生成零知识证明$zkProof$和范围证明$BulletProof$</p>
<script type="math/tex; mode=display">
C_3=g^{r_3},\ D_3=g^{m_3}g_4^{r_3}\\
C_3^{\prime}=g^{r_3^{\prime}},D_3^{\prime}=g^{m_3^{\prime}}g_3^{r_3^{\prime}}\\
ZK\{r_3,r_3^{\prime},m_3,m_3^{\prime},m_3=m_3^{\prime}|C_3,D_3,C_3^{\prime},D_3^{\prime}\}\\
BulletProof\{0\le m_1+m_2-m_3\le2^{32},0\le m_3\le2^{32} \}</script><p>C对交易单签名;矿工验证签名、零知识证明和范围证明。然后:</p>
<ul>
<li>更新C金额记作$[C_1C_2/C_3^{\prime},D_1D_2/D_3{\prime}]$，则C能够解密获得$m_1+m_2-m_3$并进行支付，解密过程：$g^{m_1+m_2-m_3}=(D_1D_2/D_3^{\prime})/(C_1C_2/C_3)^{\alpha_3}$</li>
<li>更新A的金额状态记为$[C_3,D_3]$，则A能过够解密获得$m_3$并进行支付。解密过程：$g^{m_3}=(D_3)/(C_3)^{\alpha_4}$</li>
</ul>
<p>Sigma 零知识证明确保：支付方的减少额 == 接收方的增加额。</p>
]]></content>
      <categories>
        <category>零知识证明</category>
      </categories>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>R1CS</title>
    <url>/posts/4cdf8b1a.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>本文介绍零知识证明中的一对概念：R1CS和QAP</p>
<span id="more"></span>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>zk-SNARKS是目前最常用的零知识证明系统，但是由于其复杂性，不能直接应用于任何计算问题，因此需要对计算问题进行一步步的转化，其中就包含了R1CS和QAP。</p>
<p>R1CS 全程 Rank-1 Con­straint Sys­tem，一阶约束系统，其本质是一个可计算的三元方程组。</p>
<p>而 QAP 全称 Qua­dratic Arith­metic Peoblem，二次算术问题，QAP 转换不仅可以将函数的代码转换为 QAP，还可以在转换的同时构建一个对应于代码输入的解（又称为 QAP 的 Wit­ness），之后再基于这个 wit­ness 构建一个实际的零知识证明系统。</p>
<p>本文的参考是<a href="https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649">V神</a></p>
<h1 id="QAP"><a href="#QAP" class="headerlink" title="QAP"></a>QAP</h1><p>在V神的文章中，给出了一个例子：P希望向V证明其知道方程$x^3+x+5=35$的解（P知道这个方程的解，因此witness为$x=3$），接下来是如何转化为QAP问题</p>
<p>首先，我们用程序语言描述这个问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">    y=x**<span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> y+x+<span class="number">5</span></span><br></pre></td></tr></table></figure>
<h1 id="Flattening"><a href="#Flattening" class="headerlink" title="Flattening"></a>Flattening</h1><p>第一步就是将这个语言中的代码转换为下列两个操作</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1.x=y（y可以是变量或数字）</span><br><span class="line">2.x=y op z（op代表一种基本运算操作）</span><br></pre></td></tr></table></figure>
<p>经过 Flat­ten­ing 后，上述的语言可以转换为下面这个结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sym_1 = x * x</span><br><span class="line">y = sym_1 * x</span><br><span class="line">sym_2 = y + x</span><br><span class="line">~out = sym_2 + <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>这里可以将上述转换后的每一行都理解为一个数学电路中的逻辑门（一个仅包含加法门和乘法门的电路），与原始代码相比，这里引入了两个中间变量 <code>sym_1</code> 和 <code>sym_2</code>，输出标记为 <code>~out</code>，不难验证其与原始代码的等价性</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">~out = sym<span class="emphasis">_2 + 5 = y + x + 5 = sym_</span>1 <span class="emphasis">* x + x + 5 = x *</span> x <span class="emphasis">* x + x + 5</span></span><br></pre></td></tr></table></figure>
<h1 id="R1CS"><a href="#R1CS" class="headerlink" title="R1CS"></a>R1CS</h1><p>第二步需要将 Flat­ten­ing 的结果转化为一阶约束系统 R1CS，一个 R1CS 是一个由三个向量构成的向量组$(\vec a,\vec b,\vec c)$，假设 R1CS 的解也是一个向量，记为$\vec s$，则$\vec s$满足</p>
<script type="math/tex; mode=display">
(\vec s \cdot \vec a)*(\vec s \cdot \vec b)-(\vec s \cdot \vec c)=0</script><p>其中⋅⋅表示向量内积，∗∗表示算数乘法</p>
<p>举例，假设向量组和解向量分别如下：</p>
<script type="math/tex; mode=display">
\vec a =[0,1,0,0,0,0]\\
\vec b=[0,1,0,0,0,0]\\
\vec c=[0,0,0,1,0,0]\\
\vec s=[1,3,35,9,27,30]</script><p>此时这个$\vec s$满足R1CS</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202308061947510.png" alt="img"></p>
<p>这个例子中只有一个约束条件（也即只有一个 R1CS），接下来需要将之前的每个逻辑门都转化为一个约束（也即将 Flat­ten­ing 之后的每一个语句都转化为一个 R1CS 向量组），转化的方法很简单，只需要声明何种运算与声明的参数是常量还是变量。</p>
<p>因此，将上述 Flat­ten­ing 的结果转化之前，需要先将所有用到的变量用解向量$\vec s$表示，根据前面的分析，需要有五个变量$(x,\sim out,sym_1,y,sym_2)$，此外还需要一个冗余变量表示数字 1，记为$\sim one$，因此得到解向量$\vec s$如下</p>
<script type="math/tex; mode=display">
\vec s=[\sim one,x,\sim out,sym\_1,y,sym\_2]</script><p>接下来看第一个逻辑门$sym_1=x∗x$，其等价于$x∗x−sym_1=0$，因此不难得出R1CS 向量组如下</p>
<script type="math/tex; mode=display">
\vec a_1=[0,1,0,0,0,0]\\
\vec b_1=[0,1,0,0,0,0]\\
\vec c_1=[0,0,0,1,0,0]\\</script><p>然后第二个逻辑门$y=sym_1∗x$同理，其等价于$sym_1∗x−y=0$，得到第二个 R1CS 向量组</p>
<script type="math/tex; mode=display">
\vec a_1=[0,0,0,1,0,0]\\
\vec b_1=[0,1,0,0,0,0]\\
\vec c_1=[0,0,0,0,1,0]\\</script><p>第三个逻辑门$sym_2=y+x$同理，其等价于$(y+x)∗1−sym_2=0$，得到第三个 R1CS 向量组</p>
<script type="math/tex; mode=display">
\vec a_1=[0,1,0,0,1,0]\\
\vec b_1=[1,0,0,0,0,0]\\
\vec c_1=[0,0,0,0,0,1]\\</script><p>最后是第四个逻辑门$\sim out =sym_2+5$同理，其等价于$(sym_2+5)*1-(\sim out)=0$得到第四个 R1CS 向量组</p>
<script type="math/tex; mode=display">
\vec a_1=[5,0,0,0,0,1]\\
\vec b_1=[1,0,0,0,0,0]\\
\vec c_1=[0,0,1,0,0,0]\\</script><p>此时之前的 wit­ness 为$x=3$，经过 R1CS 转换后 wit­ness 就转换为了使得这四个 R1CS 同时成立的解向量$\vec s$</p>
<script type="math/tex; mode=display">
\vec s=[1,3,35,9,27,30]</script><p>将上述结果整理一下，把每个 R1CS 中的三个向量分别整理成一个向量组</p>
<script type="math/tex; mode=display">
A=\left(
\begin{matrix}
0 & 1 & 0 &0 &0 &0\\
0 & 0 & 0 &1 &0 &0\\
0 & 1 & 0 &0 &1 &0\\
5 & 0 & 0 &0 &0 &1
\end{matrix}
\right)\\

B=\left(
\begin{matrix}
0 & 1 & 0 &0 &0 &0\\
0 & 1 & 0 &0 &0 &0\\
1 & 0 & 0 &0 &1 &0\\
1 & 0 & 0 &0 &0 &0
\end{matrix}
\right)\\

C=\left(
\begin{matrix}
0 & 0 & 0 &1 &0 &0\\
0 & 0 & 0 &0 &1 &0\\
0 & 0 & 0 &0 &0 &1\\
0 & 0 & 1 &0 &0 &0
\end{matrix}
\right)\\</script><h1 id="R1CS-to-QAP"><a href="#R1CS-to-QAP" class="headerlink" title="R1CS to QAP"></a>R1CS to QAP</h1><p>下一步是将这个 R1CS 转换成 QAP 的形式，QAP 实现了与 R1CS 完全相同的逻辑，只不过使用的是多项式而不是向量内积，具体做法如下</p>
<p>在上述三个向量组A,B,C中，利用在每个$x$坐标处求多项式代表一个约束条件（每个向量组的第一个行向量代表$x=1$），将每个向量组的四个长度为 6 的行向量转换成六个长度为 4 的向量（六个阶为 3 的多项式）</p>
<p>也就是说，如果我们求出$x=1$处的多项式，我们就得到了第一组向量，如果我们求出$x=2$处的多项式，我们就得到第二组向量，以此类推</p>
<p>在每个$x$点处来评估不同的约束，每个向量组都有四个约束，因此我们分别用多项式在 $x=1,2,3,4$处来评估这四个向量组，然后使用拉格朗日差值公式来将 R1CS 转化为 QAP 形式</p>
<p>以向量组 A 举例，首先需要求出四个约束所对应的每个$\vec a$向量的第一个值的多项式，也就是对向量组 A 的第一列采用拉格朗日插值法，求过点(1,0),(2,0),(3,0),(4,5)四个点的多项式（可以用在线工具 <a href="http://skisickness.com/2010/04/28/">Cubic Polynomial Generator</a> 求解，或者自己写脚本也行），求得三阶多项式如下</p>
<script type="math/tex; mode=display">
y_1=-5+9.166x-5x^2+0.833x^3</script><p>将多项式的系数按$x$的阶数升序排列，得到系数向量(−5.0,9.166,−5.0,0.833)</p>
<p>不难验证，将$x=1,2,3,4$分别带入上述多项式，可以恢复向量组 A 的第一个列向量</p>
<p>同理可以求出剩下的17个系数向量</p>
<script type="math/tex; mode=display">
A=\left(
\begin{matrix}
-5 & 9.166 & -5 &0.833\\
8 & -11.333 & 5 &-0.666\\
0 & 0 & 0 &0\\
-6 & 9.5 & -4 &0.5\\
4 & -7 & 3.5 &-0.5\\
-1 & 1.833 & -1 &0.166\\
\end{matrix}
\right)\\

B=\left(
\begin{matrix}
3 & -5.166 & 2.5 &-0.333\\
-2 & 5.166 & -2.5 &0.333\\
0 & 0 & 0 &0\\
0 & 0 & 0 &0\\
0 & 0 & 0 &0\\
0 & 0 & 0 &0\\
\end{matrix}
\right)\\

C=\left(
\begin{matrix}
0 & 0 & 0 &0\\
0 & 0 & 0 &0\\
-1 & 1.833 & -1 &0.166\\
4 &-4.333 &1.5 &-0.166\\
-6 & 9.5 & -4 &0.5\\
4 & -7 & 3.5 &-0.5
\end{matrix}
\right)\\</script><p>将$x=1$带入这些十八组系数构成的多项式，可以恢复出三个 R1CS 中第一个约束的三个向量(0,1,0,0,0,0),(0,1,0,0,0,0) 和(0,0,0,1,0,0)</p>
<p>将$x=2,3,4$带入这些多项式，则可以完全恢复三个 R1CS 向量组</p>
]]></content>
      <categories>
        <category>零知识证明</category>
      </categories>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>crypto</title>
    <url>/posts/68282885.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h1><p><strong>什么是密码学</strong></p>
<p>百度百科：密码学是<strong>研究编制密码和破译密码的技术科学</strong>。 研究密码变化的客观规律，应用于编制密码以保守通信秘密的，称为编码学；应用于破译密码以获取通信情报的，称为破译学，总称密码学</p>
<p>本博客密码学参考教程：《现代密码学：理论与实践》</p>
<span id="more"></span>
<p>本密码学系列仅用来回顾我的密码学心得历程，如有错误，还请联系我jhuaiyu3@gmail.com</p>
]]></content>
      <categories>
        <category>密码学基础</category>
      </categories>
      <tags>
        <tag>密码学基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/posts/f134a8e5.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="markdown常用数学公式和符号"><a href="#markdown常用数学公式和符号" class="headerlink" title="markdown常用数学公式和符号"></a>markdown常用数学公式和符号</h1><p>如何插入公式：行内公式(此时插入公式需要修改markdown配置文件，打开偏好设置中的内联公式)</p>
<span id="more"></span>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$数学公式$</span><br></pre></td></tr></table></figure>
<p>行间公式</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">公式xxx</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p><strong>常见公式和符号</strong></p>
<p><strong>希腊字母</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">显示</td>
<td style="text-align:center">命令</td>
<td style="text-align:center">显示</td>
<td style="text-align:center">命令</td>
</tr>
<tr>
<td style="text-align:center">α</td>
<td style="text-align:center">\alpha</td>
<td style="text-align:center">β</td>
<td style="text-align:center">\beta</td>
</tr>
<tr>
<td style="text-align:center">γ</td>
<td style="text-align:center">\gamma</td>
<td style="text-align:center">δ</td>
<td style="text-align:center">\delta</td>
</tr>
<tr>
<td style="text-align:center">ε</td>
<td style="text-align:center">\epsilon</td>
<td style="text-align:center">ζ</td>
<td style="text-align:center">\zeta</td>
</tr>
<tr>
<td style="text-align:center">η</td>
<td style="text-align:center">\eta</td>
<td style="text-align:center">θ</td>
<td style="text-align:center">\theta</td>
</tr>
<tr>
<td style="text-align:center">ι</td>
<td style="text-align:center">\iota</td>
<td style="text-align:center">κ</td>
<td style="text-align:center">\kappa</td>
</tr>
<tr>
<td style="text-align:center">λ</td>
<td style="text-align:center">\lambda</td>
<td style="text-align:center">μ</td>
<td style="text-align:center">\mu</td>
</tr>
<tr>
<td style="text-align:center">ν</td>
<td style="text-align:center">\nu</td>
<td style="text-align:center">ξ</td>
<td style="text-align:center">\xi</td>
</tr>
<tr>
<td style="text-align:center">π</td>
<td style="text-align:center">\pi</td>
<td style="text-align:center">ρ</td>
<td style="text-align:center">\rho</td>
</tr>
<tr>
<td style="text-align:center">σ</td>
<td style="text-align:center">\sigma</td>
<td style="text-align:center">τ</td>
<td style="text-align:center">\tau</td>
</tr>
<tr>
<td style="text-align:center">υ</td>
<td style="text-align:center">\upsilon</td>
<td style="text-align:center">φ</td>
<td style="text-align:center">\phi</td>
</tr>
<tr>
<td style="text-align:center">χ</td>
<td style="text-align:center">\chi</td>
<td style="text-align:center">ψ</td>
<td style="text-align:center">\psi</td>
</tr>
<tr>
<td style="text-align:center">ω</td>
<td style="text-align:center">\omega</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p><strong>矩阵</strong></p>
<ul>
<li>pmatrix ：小括号边框</li>
<li>bmatrix ：中括号边框</li>
<li>Bmatrix ：大括号边框</li>
<li>vmatrix ：单竖线边框</li>
<li>Vmatrix ：双竖线边框</li>
<li>横省略号：\cdots</li>
<li>竖省略号：\vdots</li>
<li>斜省略号：\ddots</li>
</ul>
<p>不带括号的矩阵</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$</span><br><span class="line">  \begin&#123;matrix&#125;</span><br><span class="line">   1 &amp; 2 &amp; 3 \\\</span><br><span class="line">   4 &amp; 5 &amp; 6 \\\</span><br><span class="line">   7 &amp; 8 &amp; 9</span><br><span class="line">  \end&#123;matrix&#125;</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>$<br>  \begin{matrix}<br>   1 &amp; 2 &amp; 3 \\<br>   4 &amp; 5 &amp; 6 \\<br>   7 &amp; 8 &amp; 9<br>  \end{matrix}<br>$</p>
<p>带括号{}的矩阵</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$</span><br><span class="line"> \begin&#123;Bmatrix&#125;</span><br><span class="line">   1 &amp; 2 &amp; 3 \\\</span><br><span class="line">   4 &amp; 5 &amp; 6 \\\</span><br><span class="line">   7 &amp; 8 &amp; 9</span><br><span class="line">  \end&#123;Bmatrix&#125;</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>带括号[]的矩阵</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$</span><br><span class="line"> \begin&#123;bmatrix&#125;</span><br><span class="line">   1 &amp; 2 &amp; 3 \\\</span><br><span class="line">   4 &amp; 5 &amp; 6 \\\</span><br><span class="line">   7 &amp; 8 &amp; 9</span><br><span class="line">  \end&#123;bmatrix&#125;</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>带省略号的矩阵</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$</span><br><span class="line">\left[</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line"> 1      &amp; 2      &amp; \cdots &amp; 4      \\\</span><br><span class="line"> 7      &amp; 6      &amp; \cdots &amp; 5      \\\</span><br><span class="line"> \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\</span><br><span class="line"> 8      &amp; 9      &amp; \cdots &amp; 0      \\\</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">\right]</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>方程组</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$\begin&#123;cases&#125;</span><br><span class="line">a<span class="emphasis">_1x+b_</span>1y+c<span class="emphasis">_1z=d_</span>1\\\</span><br><span class="line">a<span class="emphasis">_2x+b_</span>2y+c<span class="emphasis">_2z=d_</span>2\\\</span><br><span class="line">a<span class="emphasis">_3x+b_</span>3y+c<span class="emphasis">_3z=d_</span>3\\\</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p><strong>集合</strong></p>
<p>属于运算，符号：<code>\in</code>，如：$x \in y$</p>
<p>不属于运算，符号：<code>\notin</code>，如：$x \notin y$</p>
<p>不属于运算，符号：<code>\not\in</code>，如：$x \not\in y$</p>
<p>子集运算，符号：<code>\subset</code>，如：$x \subset y$</p>
<p>子集运算，符号：<code>\supset</code>，如：$x \supset y$</p>
<p>真子集运算，符号：<code>\subseteq</code>，如：$x \subseteq y$</p>
<p>非真子集运算，符号：<code>\subsetneq</code>，如：$x \subsetneq y$</p>
<p>真子集运算，符号：<code>\supseteq</code>，如：$x \supseteq y$</p>
<p>非真子集运算，符号：<code>\supsetneq</code>，如：$x \supsetneq y$</p>
<p>非子集运算，符号：<code>\not\subset</code>，如：$x \not\subset y$</p>
<p>非子集运算，符号：<code>\not\supset</code>，如：$x \not\supset y$</p>
<p>并集运算，符号：<code>\cup</code>，如：$x \cup y$</p>
<p>交集运算，符号：<code>\cap</code>，如：$x \cap y$</p>
<p>差集运算，符号：<code>\setminus</code>，如：$x \setminus y$</p>
<p>同或运算，符号：<code>\bigodot</code>，如：$x \bigodot y$</p>
<p>同与运算，符号：<code>\bigotimes</code>，如：$x \bigotimes y$</p>
<p>实数集合，符号：<code>\mathbb&#123;R&#125;</code>，如：<code>\mathbb&#123;R&#125;</code></p>
<p>自然数集合，符号：<code>\mathbb&#123;Z&#125;</code>，如：<code>\mathbb&#123;Z&#125;</code></p>
<p>空集，符号：<code>\emptyset</code>，如：$\emptyset$</p>
<p><strong>数学符号</strong></p>
<p>无穷，符号：<code>\infty</code>，如：$\infty$</p>
<p>虚数，符号：<code>\imath</code>，如：$\imath$</p>
<p>虚数，符号：<code>\jmath</code>，如：$\jmath$</p>
<p>数学符号，符号<code>\hat&#123;a&#125;</code>，如：$\hat{a}$</p>
<p>数学符号，符号<code>\check&#123;a&#125;</code>，如：$\check{a}$</p>
<p>数学符号，符号<code>\breve&#123;a&#125;</code>，如：$\breve{a}$</p>
<p>数学符号，符号<code>\tilde&#123;a&#125;</code>，如：$\tilde{a}$</p>
<p>数学符号，符号<code>\bar&#123;a&#125;</code>，如：$\bar{a}$</p>
<p>矢量符号，符号<code>\vec&#123;a&#125;</code>，如：$\vec{a}$</p>
<p>数学符号，符号<code>\acute&#123;a&#125;</code>，如：$\acute{a}$</p>
<p>数学符号，符号<code>\grave&#123;a&#125;</code>，如：$\grave{a}$</p>
<p>数学符号，符号<code>\mathring&#123;a&#125;</code>，如：$\mathring{a}$</p>
<p>一阶导数符号，符号<code>\dot&#123;a&#125;</code>，如：$\dot{a}$</p>
<p>二阶导数符号，符号<code>\ddot&#123;a&#125;</code>，如：$\ddot{a}$</p>
<p>上箭头，符号：<code>\uparrow</code>，如：$\uparrow$</p>
<p>上箭头，符号：<code>\Uparrow</code>，如：$\Uparrow$</p>
<p>下箭头，符号：<code>\downarrow</code>，如：$\downarrow$</p>
<p>下箭头，符号：<code>\Downarrow</code>，如：$\Downarrow$</p>
<p>左箭头，符号：<code>\leftarrow</code>，如：$\leftarrow$</p>
<p>左箭头，符号：<code>\Leftarrow</code>，如：$\Leftarrow$</p>
<p>右箭头，符号：<code>\rightarrow</code>，如：$\rightarrow$</p>
<p>右箭头，符号：<code>\Rightarrow</code>，如：$\Rightarrow$</p>
<p>底端对齐的省略号，符号：<code>\ldots</code>，如：$1,2,\ldots,n$</p>
<p>中线对齐的省略号，符号：<code>\cdots</code>，如：$x_1^2 + x_2^2 + \cdots + x_n^2$</p>
<p>竖直对齐的省略号，符号：<code>\vdots</code>，如：$\vdots$</p>
<p>斜对齐的省略号，符号：<code>\ddots</code>，如：$\ddots$</p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>一个简单的通信游戏</title>
    <url>/posts/f95d038c.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>从本文开始，我们将开启密码学的历程。</p>
<span id="more"></span>
<h1 id="一个简单的通信游戏"><a href="#一个简单的通信游戏" class="headerlink" title="一个简单的通信游戏"></a>一个简单的通信游戏</h1><h2 id="第一个应用实例"><a href="#第一个应用实例" class="headerlink" title="第一个应用实例"></a>第一个应用实例</h2><p><strong>我们给出密码学的第一个应用实例</strong></p>
<p>这是个简单的问题，两个朋友Alice和Bob，他们在玩一个叫做抛硬币的游戏。</p>
<p>如果Alice对Bob说，“你选一面，我抛硬币并告诉你结果”，显然Bob不能同意，因为他不能验证抛硬币的结果。</p>
<p>为了解决这个问题，便有了这样的想法：</p>
<p>为此我们先了解一个奇妙函数$f(x)$</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">奇妙函数f</span><br><span class="line">1) 对任意整数x计算f(x)是容易的，给出f(x)计算x是不可能的</span><br><span class="line">2) 不可能找到一对整数(x,y)，满足x!=y且f(x)=f(y)</span><br></pre></td></tr></table></figure>
<p>在这个基础上，我们可以得到第一个密码协议：</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202306251101064.png" alt="game"></p>
<p><strong>安全性分析</strong></p>
<p>首先，由于性质2）Alice无法找到两个数x和y，其中一个是奇数另一个是偶数，满足$f(x)=f(y)$，因此，一旦Alice告诉Bob$f(x)$的值，她就完成了抛硬币的过程。</p>
<p>其次，由于$f$具有性质1），Bob不能判断Alice使用的x是奇数还是偶数，因此他不得不把其猜测真是地给出。</p>
<p>虽然这个协议听上去十分简单，但它的确是一个合格的密码协议，因为协议中使用了现代密码学的一个基本要素——<strong>单向函数</strong>。</p>
<h2 id="密码学的新作用——保证游戏的公平性"><a href="#密码学的新作用——保证游戏的公平性" class="headerlink" title="密码学的新作用——保证游戏的公平性"></a>密码学的新作用——保证游戏的公平性</h2><p>密码学一度曾为政府所独占，军事和外交部门使用它来保密消息。</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307281952368.png" alt="img"></p>
<p>图一：《模仿游戏》（The Imitation Game）是一部2014年英美合拍的历史剧情片。讲述英国数学家、逻辑学家、密码分析学家和计算机科学家艾伦·图灵在二战中帮助盟军破译纳粹德国的军事密码的真实故事。</p>
<p>可是今天，密码学除了用于对信息进行保密外，还有一个新的用途：在有大量“玩家”的“游戏”中保证公平性，正如我们刚才讨论过的通信游戏。</p>
<p>在一个娱乐场所进行判决可能不是一件大不了的事情，因而通过电话掷硬币来做决定只可能被看成是一种取乐的通信游戏。可是，有很多通信“游戏”必须更加认真地对待。随着越来越多的事务处理和电子商务活动在开放的网络中以电子方式开展，我们通信中的许多实例将会涉及各种各样的“游戏”。</p>
<p>一般来说,这种“游戏”的“玩家”往往彼此物理上相距很远，要依靠不安全的开放网络进行通信。物理距离和缺少安全性组合到一块儿，有助于和/或激励一些“玩家”(甚至一些未受邀请的玩家)以某种聪明的方式挫败游戏规则。违背规则的企图是为了获得某种未授权的优势，例如造成秘密信息的泄露、改变数据而不被发现、伪造证据、责任否认、破坏审计和信任、降低可用性或完全不提供服务等。现代通信在事务处理、商业运作、提供服务(以及很多其他方面，如公司业务、个人信息、军事活动和国家事务的保密)方面的重要性意味着要求不遵守游戏规则的玩家不应该获得任何未授权的优势。</p>
<h1 id="密码系统和协议的准则"><a href="#密码系统和协议的准则" class="headerlink" title="密码系统和协议的准则"></a>密码系统和协议的准则</h1><p>我们应当从一个基本的问题开始：什么是好的密码系统和协议？</p>
<p>显然，这个问题不好答，各有各的说法，每个人对于好的定义是不一样的。有说难以计算的，有说不易察觉的。本博客的主要任务就是对这个基本问题给出更深入的答案。</p>
<p>简单来说它应该有以下特点：</p>
<ul>
<li>保护的程度与应用需求相符合：不应该去设计过于复杂的密码系统来保护价值不匹配的信息，好的密码系统复杂程度应该刚刚好。</li>
<li>对安全性的信心要依据所建立的“种系”：对于一个密码协议或系统，攻破它的困难性应该归结于某个困难的数学问题</li>
<li>实际效率：我们所说的数学问题应该是高效可解的，该问题能在问题规模的多项式时间内可解。</li>
<li>采用实际的和可用的原型和服务：</li>
<li>明确性：要明确所需要的所有假定，要明确所提供的确切的安全服务，要明确数学方面的一些特殊情况</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>密码学基础</category>
      </categories>
      <tags>
        <tag>密码学基础</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式机器学习</title>
    <url>/posts/59707b04.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<span id="more"></span>
<h1 id="分布式机器学习介绍"><a href="#分布式机器学习介绍" class="headerlink" title="分布式机器学习介绍"></a>分布式机器学习介绍</h1><p>分布式机器学习也称为分布式学习，是指利用多个计算节点（也可称为工作者，worker）进行机器学习或者深度学习的算法和系统，旨在提高性能，保护隐私，并可扩展至更大规模的训练数据和更大的模型。如图所示。训练数据被分为不相交的数据分片并被发送给各个工作者，工作者将在本地执行随机梯度下降（Stochastic Gradient Descent，SGD）。工作者将梯度$\nabla W^i$或者模型参数$W^i$发送至服务器。参数服务器对收到的梯度或者模型参数进行聚合，从而得到全局梯度$\nabla W$或全局模型参数$W$。</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202308072017308.png" alt="img"></p>
<h1 id="面向扩展性的DML"><a href="#面向扩展性的DML" class="headerlink" title="面向扩展性的DML"></a>面向扩展性的DML</h1><h2 id="大规模机器学习"><a href="#大规模机器学习" class="headerlink" title="大规模机器学习"></a>大规模机器学习</h2><p>在大数据时代，ML面临的主要问题是如何处理大规模的高纬度数据集，随着大趋势的变化，ML社区正面临着计算性能和好事与数据规模不匹配的挑战，这使得大规模的训练样本中耗费合理的计算代价和时间进行学习变得愈加不可能。</p>
<h3 id="内存短缺"><a href="#内存短缺" class="headerlink" title="内存短缺"></a>内存短缺</h3><p>传统ML方法只在一块独立内存中对训练样本进行所有的操作，因此，可能出现：训练模型可能不能收敛或性能低下（低准确率和召回率）。</p>
<h3 id="不合理的训练时间"><a href="#不合理的训练时间" class="headerlink" title="不合理的训练时间"></a>不合理的训练时间</h3><p>ML算法中的一些优化过程可能不能匹配训练样本的规模。因此，当处理大规模训练样本时，在训练处理中耗费的时间可能过长，在模型训练过程中，如果需要尝试多种不同的参数设置，ML模型的超参调校也将耗费大量时间。</p>
<h2 id="面向扩展性的DML-1"><a href="#面向扩展性的DML-1" class="headerlink" title="面向扩展性的DML"></a>面向扩展性的DML</h2>]]></content>
      <categories>
        <category>联邦学习</category>
      </categories>
      <tags>
        <tag>联邦学习</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链</title>
    <url>/posts/89374c81.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="区块链基础"><a href="#区块链基础" class="headerlink" title="区块链基础"></a>区块链基础</h1><p>区块链究竟是什么？狭义地说，区块链就是比特币的底层技术；不过，经过7年的发展，区块链已经不再“依附于”比特币，而是独立地发展成为了一种革命性的技术，比特币则是区块链最大、最成功的应用。</p>
<span id="more"></span>
<p>从技术层面来看，区块链是一个<strong>基于共识机制、去中心化的公开数据库</strong>。共识机制是指在分布式系统中保证数据一致性的算法；去中心化是指参与区块链的所有节点都是权力对等的，没有高低之分，同时也指所有人都可以平等自由地参与区块链网络，唯一的限制就是个人自己的选择；公开数据库则意味着所有人都可以看到过往的区块和交易，这也保证了无法造假和改写。基于以上特性，可以总结得出：区块链由许多对等的节点组成，通过共识算法保证区块数据和交易数据的一致性，从而形成一个统一的分布式账本。<br>从价值层面来看，区块链是一个价值互联网，用于<strong>传递价值</strong>。目前的互联网仅用来传递消息，但是还不能可靠地传递价值；而比特币区块链却可以在全球范围内自由地传递比特币，并且能够保证不被双花、不被冒用。从这个角度来说，区块链是记录价值、传递消息和价值本身转移的一个可信账本。</p>
<p>以区块链技术为核心的系统包括如下四大最主要的特点。</p>
<p>Distributed（分布式的）</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">区块链是全球化的，系统上的节点是运行在太平洋某个小岛的笔记本电脑上还是运行在中国某个小镇的服务器上，对系统本身来说都是一样的，除了网络连接速度有区别之外，其他没有任何区别。区块链没有中心节点，数据分布式地存储在各个节点上，即使绝大部分节点毁灭了，只要还有1个节点存在，就可以重新建立并还原区块链数据。</span><br></pre></td></tr></table></figure>
<p>Autonomous（自治的）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">区块链是一种去中心化的、自治的交易体系，这种自治性表现在两个方面：1）所有节点都是对等的，每个节点都可以自由加入和离开，并且这一行为对整个区块链系统的运行没有任何影响。所有的节点都是按照相同的规则来达成共识，且无需其他节点的参与。2）区块链系统本身一旦运行起来，就可自行产生区块并且同步数据，无需人工参与。</span><br></pre></td></tr></table></figure>
<p>Contractual（按照合约执行的）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">区块链是按照合约执行的，第一体现在各个节点的运行规则（指的是交易、区块链或协议）上，按照既定的规则执行，一旦出现违背规则的行为，就会被其他节点所抛弃；第二体现在智能合约上，智能合约是一种可程序化的合同条款、规则或规定，包含在每个交易中，交易验证时必须先运行智能合约，只有通过了验证的交易才能被接受。</span><br></pre></td></tr></table></figure>
<p>Trackable（可追溯的）</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">区块链的数据是公开透明的，不能被篡改，而且相关交易之间有一定的关联性，因而很容易被追溯。比如比特币区块链，每一枚比特币都有其特定的来源，通过输入可以追溯到上一个交易，或者通过输出追溯到下一个交易。</span><br><span class="line">此外，区块链代码本身也是可追溯的，区块链系统是开源软件，其对于所有的人都是公开的，因此任何人都可以查看并修改这些代码，不过修改后的代码需要经过开源社区上其他程序员的审核。</span><br></pre></td></tr></table></figure>
<h2 id="交易合交易链"><a href="#交易合交易链" class="headerlink" title="交易合交易链"></a>交易合交易链</h2><p><strong>交易</strong>是签过名的数据结构，该数据结构会在区块链网络中广播，并被收集到区块中。它会引用以前的交易，从该交易中发送特定数量的比特币到一个或多个公钥中（即比特币地址），并且交易未被加密（比特 币体系中没有加密任何数据）。多个交易可组成一个区块（block）， 这些区块同样也会在区块链网络中传播，一个区块会引用上一个区块。</p>
<p>区块链就是由<strong>区块（block）</strong>用某种方式组织起来的<strong>链条 （chain）</strong>。</p>
<h3 id="比特币地址"><a href="#比特币地址" class="headerlink" title="比特币地址"></a>比特币地址</h3><p>比特币地址是一个由数字和字母组成的字符串，可以与任何想给你 比特币的人分享。由公钥（一个同样由数字和字母组成的字符串）生成 的比特币地址以数字“1”开头。例子：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</span><br></pre></td></tr></table></figure>
<p>在交易中，比特币地址通常是以收款方的形式出现。比特币地址可以代表一对公钥和私钥的所有者，也可以代表其他东西。</p>
<p>比特币地址是由公钥经过单向的Hash函数生成的。用户通常所见到 的比特币地址是过“Base58Check”编码的，这种编码使用了58个字 （一种Base58数字系统）和校验码，提高了可读性、避免了歧义，并有效地防止了在地址转录和输入中产生错误。</p>
<h3 id="交易的本质"><a href="#交易的本质" class="headerlink" title="交易的本质"></a>交易的本质</h3><p>交易实质上就是包含一组输入列表和输出列表的数据结构，也可称之为转账记录，这其中就包括了交易金额、来源和收款人等信息。</p>
<h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><p>输入是对其他交易输出的引用，一个交易中通常列有多个输入。所有被引用的输出值相加，得出的总和值会在该交易A的输出中用到。 </p>
<p>Previous tx：以前交易的Hash值</p>
<p>Index：被引用交易的特定输出号</p>
<p>ScriptSig：一个脚本的前一半</p>
<p>脚本包含两个部分，一个签名和一个公钥，公钥属于交易输出的收款人，并且表明交易创建者允许收款人获得的输出金额；另一个部分是 ECDSA签名，是通过对交易的Hash值进行ECDSA签名而得到的。</p>
<p>输出中包含了发送比特币的指令，金额（Value）是以聪（Satoshi,1BTC=100000000聪）为单位的数值。ScriptPubKey是脚本的另一半（这点将在后文中详细讨论），可以有多个输出，它们共享了输入金额。</p>
<h3 id="交易类型"><a href="#交易类型" class="headerlink" title="交易类型"></a>交易类型</h3><p>根据目标地址的不同，可以把交易分为如下几种类型：</p>
<ol>
<li>支付到公钥Hash</li>
</ol>
<p>一个比特币地址只是一个Hash值，因而发送者无法在scriptPubKey 中提供完整的公钥，当要赎回比特币时，接收者需要同时提供签名scriptSig和公钥scriptPubKey，脚本系统会验证公钥的Hash值与scriptPubKey中的Hash值是否匹配，同时还会检查公钥和签名是否匹配。</p>
<ol>
<li>支付到脚本Hash</li>
</ol>
<p>该类交易非常有意义，未来应该会在某些场合频繁使用。该类交易的接受地址不是通常意义上的地址，而是一个多签地址，以3开头。比如，三对公钥对可以生成一个多签地址。</p>
<p>地址以3开头，可以实现多方管理资产，极大地提高安全性，也可以轻松实现基于比特币原生的三方交易担保支付。一个m-of-n的模式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">m &#123;pubkey&#125;...&#123;pubkey&#125; n OP<span class="emphasis">_CHECKMULTISIG</span></span><br></pre></td></tr></table></figure>
<p>其中，m和n需要满足：1≤n≤20，m≤n。</p>
<p>1 of 3，<strong>最大程度私钥冗余</strong>。防丢私钥损失，3把私钥中任意一把即可签名发币，即使丢失2把也可以保障不受损失。</p>
<p>2 of 3，<strong>提高私钥冗余度的同时解决单点信任问题</strong>。3把私钥中的任 意2把私钥可签名发币，对于三方不完全信任的情形，即中介交易，非常适用。</p>
<p>3 of 3，<strong>最大程度解决资金信任问题，无私钥冗余</strong>。必须3把私钥全部签名才能发币，适用于多方共同管理的重要资产，但是任何一方遗失私钥均会造成严重损失。</p>
<ol>
<li>挖矿交易</li>
</ol>
<p>挖矿（coinbase）交易用于凭空产生比特币。</p>
<p>挖矿交易只有一个输 入，该输入有一个“coinbase”参数，没有scriptSig，“coinbase”中的数据可以是任意内容，它不会被使用。</p>
<p>挖矿交易的输出金额在一段时间内是固定值，现在是12.5个比特币。输出地址可以是任何地址，一般是矿工或矿池的比特币地址。</p>
<h3 id="找零地址"><a href="#找零地址" class="headerlink" title="找零地址"></a>找零地址</h3><p>在实际的交易中，假设A有一个比特币地址，并且包含着没有花费的10个比特币，B也有一个比特币地址，里面一分钱没有。当A向B支付10个比特币时，此时就不需要找零钱的问题。</p>
<p>假设A的地址上有35个比特币（如图1-2所示），当A想向B支付8个 比特币时，如图所示，只需要使用包含着20个比特币的那一笔未消费支出，并设置好要支持的金额即可，剩下的12个比特币则会返回给A，以便A在将来可以继续使用。</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307211709773.png" alt="image-20230721170933653"></p>
<p>这样就有了一个找零机制，实际上，比特币在交易时会把消费时所用的地址（消费地址）的余额设置为零。当需要支付的金额小于可用余额时，在交易信息中必须告诉比特币网络零钱将要被发送至哪个地址， 即“找零地址”。找零地址可能是也可能不是原先的发送地址。</p>
<p><strong>隐私的保证</strong> 根据设计，每一笔比特币交易将在一个称为“区块链”的全球性的公共总账上永久可见，这就意味着任何人随时都可以在上面进行跟踪查询。通过将某个比特币地址与其使用者关联起来，好事者都可以据此绘制关于这个人与他人之间的资金转移的关系图。但如果是将找回的零钱发送至一个<strong>新创建的地址</strong>，那么就可以让这种追踪变得更加困难。</p>
<p>假设从地址A发送比特币到地址B后，零钱返回地址为A，则区块链会揭示地址A向地址B支付了一笔钱。 同样的道理，如果有两个或两个以上地址参与其中，任何涉及这个接收零钱的找零地址都会揭示A作为支付方的交易。假如某个控制着的任何接收地址或付款地址的人其身份是众所周知的，那么其他有过交易往来的各方的身份也有可能被推断出来。</p>
<p>但加入说交易后的找零地址是新的C地址，如果没有更多的信息，其他人所能知道的，只有一个差分了地址A的余额至地址B和C，而地址B或C的主人可能是也可能不是A。</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307211718658.png" alt="image-20230721171853609"></p>
<h2 id="区块和区块链"><a href="#区块和区块链" class="headerlink" title="区块和区块链"></a>区块和区块链</h2><p>比特币网络中，数据会以文件的形式被永久记录，我们称这些文件为区块。一个区块是一些或所有最新比特币交易的记录集，且未被其他先前的区块记录。</p>
<h3 id="区块结构"><a href="#区块结构" class="headerlink" title="区块结构"></a>区块结构</h3><p>每个区块都包括了一个被称为“魔法数”的常数0xD9B4BEF9、区块的大小、区块头、区块所包含的交易数量及部分或所有的近期新交易。 </p>
<p>在每个区块中，对整个区块链起决定作用的是区块头。</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307241620905.png" alt="image-20230724162029765"></p>
<p>区块头描述：</p>
<p>每个 区块都必须要指向前一个区块，否则无法通过验证。这个区块链条会一 直追溯到源头，也就是指向创世区块。很显然，创世区块的hashPrevBlock的值为零或为空。在区块头中，最关键的一个数据项是一个随机数Nonce，这串数字是一个答案，而这个答案对于每一个区块来说都是唯一的。它的特点如下：</p>
<ul>
<li><p>这个答案很难获得。 </p>
</li>
<li><p>有效答案有多个，不过我们只需要找到一个答案就可以了。 </p>
</li>
<li><p>其他节点对有效答案的验证很容易。</p>
</li>
</ul>
<p>没有固定的算法可以求出答案，所以唯一 的做法就是不断尝试，找寻这个答案的做法就是“挖矿”。</p>
<h3 id="创世块"><a href="#创世块" class="headerlink" title="创世块"></a>创世块</h3><p>创世块（Genesis Block）是指区块链的第一个区块，创世块的收益花不掉。</p>
<h3 id="区块链原理"><a href="#区块链原理" class="headerlink" title="区块链原理"></a>区块链原理</h3><p>区块链是所有比特币节点共享的交易数据库，这些节点基于比特币 协议参与到比特币网络中来。</p>
<p>由于每个区块包含前一个区块的Hash值，这就使得从创世块到当前 块形成了一条块链，每个区块必定按时间顺序跟随在前一个区块之后。</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307241631898.png" alt="image-20230724163129833"></p>
<p>如果一个区块是最长块链的最后一个区块，那么诚实的矿工只会在 这个区块的基础上生成后续块。如果一个区块链中的所有区块和交易均有效，则该区块链有效，并且要以创世块开头。</p>
<h2 id="挖矿和矿池"><a href="#挖矿和矿池" class="headerlink" title="挖矿和矿池"></a>挖矿和矿池</h2><h3 id="挖矿原理与区块的产生"><a href="#挖矿原理与区块的产生" class="headerlink" title="挖矿原理与区块的产生"></a>挖矿原理与区块的产生</h3><p>比特币的挖矿和节点软件是基于对等网络、数字签名来发起和验证交易的。</p>
<p>每一个比特币的节点都会收集所有尚未确认的交易，并且会将其归集到一个数据块中，这个数据块将和前面一个数据块集成在一起。矿工节点会附加一个随机调整数，并计算前一个数据块的SHA-256Hash运算 值。挖矿节点不断进行重复尝试，直到它找到的随机调整数使得产生的 Hash值低于某个特定的目标为止。</p>
<p>当挖矿时，你会经常对区块头进行散列，你正在挖的区块也会时常进行更新。</p>
<p><strong>网络调整时间</strong> 如果当前区块的时间戳大于前11个区块的平均时间戳，并且小于“网络调整时间（Network-Adjusted Time）”+2小时，则认 为该时间戳是有效的。其中的“网络调整时间”是指与你相连接的所有节点的平均时间。当节点A连接到节点B时，A将从B处得到一个UTC的时间戳，A先将其转换成本地UTC并保存起来，网络调整时间等于所有节点的本地UTC时间+所有相连节点的偏移量平均值，然而，该网络时间永远不会调整到超过本地系统时间70分钟以上。</p>
<p>Nonce随机数通常都不会相同，但是它以严格的线性方式在增长，从0开始，每次执行散列时都会增长，当Nonce溢出时（此事经常发生），挖矿交易的extraNonce项就会增长，其将改变Merkle树的根节点。</p>
<h3 id="挖矿难度"><a href="#挖矿难度" class="headerlink" title="挖矿难度"></a>挖矿难度</h3><p><strong>挖矿难度</strong>是对挖矿困难程度的度量，即指计算符合给定目标的一个 Hash值的困难程度。</p>
<p>难度每过2016块就会改变一次，计算公式为： difficulty=difficulty_1_target/current_target </p>
<p>其中，目标（target）是一个256位长的数值。</p>
<h3 id="矿池原理与商业模式"><a href="#矿池原理与商业模式" class="headerlink" title="矿池原理与商业模式"></a>矿池原理与商业模式</h3><p>为了激励计算力较低的用户继续参与挖矿，矿池就出现了。在一个矿池里，许多不同的人贡献出自己的计算力来生成一个区块，然后再根据每个人的贡献比例来分发奖励。</p>
<p>矿池是比特币（Bitcoin）等P2P密码学虚拟货币开采所必需的基础设施，一般是对外开放的团队开采服务器。其存在的意义是提升比特币开采的稳定性，使矿工薪酬趋于稳定。</p>
<h2 id="脚本系统"><a href="#脚本系统" class="headerlink" title="脚本系统"></a>脚本系统</h2><p>比特币在交易中使用脚本系统脚本是简单的、基于堆栈的，并且是从左向右处理的。</p>
<p>一个典型的发送比特币到目标地址D的脚本，要求接收者提供以下两个条件，才能花掉发给他的比特币：</p>
<p>1）一个公钥，当进行散列生成比特币地址时，生成的地址是嵌入在脚本中的目标地址ID</p>
<p>2）一个签名，用于证明接收者保存了与上述公钥相对应的私钥。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>可证明安全</title>
    <url>/posts/69ca7032.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="Provable-Security"><a href="#Provable-Security" class="headerlink" title="Provable Security"></a>Provable Security</h1><p>在密码学中，当我们已经设计出一个密码系统或协议时，我们不能直接说它是安全的，因为这样很缺乏信服力。可证明安全通常是用来确定一个密码系统或协议是安全的。</p>
<span id="more"></span>
<p>针对确定的安全目标，构造一个形式化的敌手模型及思维实验，利用概率论和计算复杂性理论，把敌手对密码算法或密码协议的攻击归约到对已知困难问题（大数分解，离散对数）的攻击。</p>
<p>目前对于安全性有两种角度的理解。</p>
<p><strong>第一种称为“real vs random”</strong>，也就是如果加密所得的真实密文的概率分布，看起来和随机（均匀）选取一个密文一样，那么偷听者将无法从密文中获取信息。下面是形式化定义：</p>
<p>一个密码算法$\Sigma$有一次性的均匀分布的密文（one-time uniform ciphertexts），当且仅当</p>
<script type="math/tex; mode=display">
k\larr \Sigma KeyGen\\
c\larr \Sigma Enc(k,m)\\
return\ c\\
=
c\larr \Sigma C\\
return\ c</script><p><strong>第二种安全性的定义称为“left vs right”</strong>，也就是对于任意的两个明文，他们所得的密文的概率分布是一样的，因此无法区分。下面是形式化定义：</p>
<p>一个密码算法$\Sigma$有一次性安全性（one-time secrecy），当且仅当：</p>
<script type="math/tex; mode=display">
k\larr \Sigma KeyGen\\
c\larr \Sigma Enc(k,m_L)\\
return\ c\\
=
k\larr \Sigma KeyGen\\
c\larr \Sigma Enc(k,m_R)\\
return\ c\\</script><p><strong>两种安全性定义的关系</strong></p>
<p><strong>满足定义1,一定满足定义2</strong>，$L<em>{ots-real}^{\Sigma}=L</em>{ots-rand}^{\Sigma}=&gt;L<em>{ots-L}^{\Sigma}=L</em>{ots-R}^{\Sigma}=$</p>
<p>证明：第1步将其拆成了库的调用，主要是因为已知部分的输入只有一个参数。然后第2步是使用了条件（real和rand等价）。第三步是因为rand算法的结果与输入参数无关，因此可以换参数。第4步再次使用条件，最后得证。</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307302023574.png" alt="image-20230729190634004"></p>
<p><strong>满足定义2,不一定满足定义1</strong></p>
<p>只要给出一个反例即可。比如下面这个密码算法，它是在一次性密码本的基础上，密文末尾加了两个0。由于一次性密码本是满足定义2的，因此对于任意两个明文，末尾加0后，两者的密文的概率分布仍然相同，因此满足定义2。但是在当前的密文空间上，一个明文加密所得的密文必然以00结尾，不满足均匀分布，故不满足定义1。</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307302023349.png" alt="image-20230729191450442"></p>
<p><strong>如何证明不安全</strong></p>
<p>无论是哪种安全性的定义，我们只需要找到一个程序A AA，使得安全性定义中的两个库的执行结果（概率）不一样，就能证明该密码算法是不安全的。<br><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307302023224.png" alt="image-20230729191720871"></p>
<p>要证明如下两个库等价。显然，根据按位与的性质，对于real部分，如果输入的是全0，那么输出的密文一定是全0，这显然与右边的随机算法的输出的概率分布不同。</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307302023148.png" alt="image-20230729191836510"></p>
<p>因此，可以找到如下的一个程序，这个程序将证明 $Pr[A\ L<em>{ots-real}^{\Sigma}=&gt; true] =1,Pr[A\ L</em>{ots_rand}^{\Sigma}=&gt;true]=\frac{1}{2^\lambda}$，因此两个库不等价</p>
<p><strong>使用Hybrid方法证明安全性</strong></p>
<p>根据安全性的定义，证明需要计算概率，如果密码算法十分复杂，那么可能难以计算。因此Hybrid方法是希望通过一些等价转换（中间的库就称为hybrids），将待证明安全的密码算法转化为已证明安全的密码算法，从而简化安全性的证明。在给出具体示例之前，先介绍一些引理。</p>
<p><strong>引理1</strong> $(A\ L_1)\ L_2=A\ (L_1\ L_2)$,前者可以理解为，程序A将一些L1的函数内联，生成一个只调用L2的程序，后者可以理解为是链接了一个复合库，即L1可以调用L2</p>
<p><strong>引理2</strong> $L<em>{left}=L</em>{right},\ L^<em>\ L_{left}=L^</em>\ L_{right}$</p>
<p>下面，给出一个简单的使用Hybrid方法证明安全性的例子：证明如下密码算法的安全性（定义1）。该密码算法是在一次性密码本（OTP）的基础上，多进行了一次加密（两次异或）。</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307302023510.png" alt="image-20230729194836213"></p>
<p>这里的思路是希望转化为已证明过安全性的一次性密码本</p>
<p>因此第一步是转化为一次性密码本。第二步则利用了一次性密码本的安全性（等价），根据第二个引理进行替换。第三步是将库进行内联。最后简化无用代码。</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307302023416.png" alt="image-20230729195831331"></p>
]]></content>
      <categories>
        <category>密码学基础</category>
      </categories>
      <tags>
        <tag>密码学基础</tag>
      </tags>
  </entry>
  <entry>
    <title>对称密码体制</title>
    <url>/posts/c4d6c7e7.html</url>
    <content><![CDATA[<h1 id="加密-对称技术"><a href="#加密-对称技术" class="headerlink" title="加密-对称技术"></a>加密-对称技术</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>保密是密码学的核心，加密是获得信息保密的实用工具。</p>
<p>把有意义区域中的消息和加密算法中的输入称为<strong>原文</strong>，而把加密算法不可理解的输出称为<strong>密文</strong>。为了恢复信息，加密变换必须是可逆的，逆变换称为解密。加密算法和解密算法再加上消息和密钥的形式描述就构成了密码体制。</p>
<meta name="referrer" content="no-referrer">

<span id="more"></span>
<h2 id="密码体制"><a href="#密码体制" class="headerlink" title="密码体制"></a>密码体制</h2><p>密码体制构成如下：</p>
<ul>
<li>明文消息空间M：某个字母表上的串集</li>
<li>密文消息空间C：可能的密文消息集</li>
<li>加密密钥空间K：可能的加密密钥集；解密密钥空间K`：可能的解密密钥集</li>
<li>有效的密钥生成算法g：$N\rarr K * K^\prime$</li>
<li>有效的加密算法：$M*K\rarr C$</li>
<li>有效的解密算法：$C*K^\prime \rarr M$</li>
</ul>
<p>对于整数$1^l$，$g(1^l)$输出长为 $l$ 的密钥对(ke,kd)。</p>
<p>加密变换：$c=\varepsilon <em>{ke}(m)$ ，解密变换：$M=D</em>{kd}(c)$</p>
<p>由此可以得到： $D<em>{kd}(\varepsilon</em>{ke}(m))=m$</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307181103744.png" alt="image-20230718110309626"></p>
<p>当$kd=ke$ 的情况：<strong>对称密码体制</strong></p>
<p><strong>Kerchoffs原理</strong> ：知道算法和密钥的长度还可以获得已知的明文是现代密码分析的标准假设，既然敌手最终可以获得这些信息，那么评估密码强度时最好不要依赖于这些信息的保密性。</p>
<h2 id="代换密码"><a href="#代换密码" class="headerlink" title="代换密码"></a>代换密码</h2><p>在 <strong>代换密码</strong> 中，加密算法是一个代换函数，它将每一个 $m \in M$代换为相应的 $c \in C$，代换函数的参数时密钥k。解密算法只是一个逆代换。</p>
<h3 id="简单的代换密码"><a href="#简单的代换密码" class="headerlink" title="简单的代换密码"></a>简单的代换密码</h3><p>令 $M=C=Z_{26}$，加密算法定义为下面的一个置换：</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307181131537.png" alt="image-20230718113141493"></p>
<p>相应的解密算法为：</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307181132135.png" alt="image-20230718113206096"></p>
<p>历史上出现过几种特殊的简单代换密码，最简单且最著名的密码称为移位密码。在移位密码中，$K=M=C$，加密和解密映射定义为：</p>
<p>$\varepsilon_k(m)\larr m+k (modN)$</p>
<p>$D_k(c)\larr c-k (modN)$</p>
<p>当$M=Z_{26}$时，移位密码也称为凯撒密码。</p>
<p>同理也可以定义一种称为<strong>仿射密码</strong>的简单代换</p>
<p>$\varepsilon_k(m)\larr k_1m+k_2 (modN)$</p>
<p>$D_k(c)\larr k_1^{-1}(c-k_2) (modN)$</p>
<p>单表密码不能抵抗<strong>频度分析攻击</strong>。</p>
<h3 id="多表密码"><a href="#多表密码" class="headerlink" title="多表密码"></a>多表密码</h3><p>如果明文信息元可以代换为许多可能是任意多的密文信息元，这种代换密码称为<strong>多表密码</strong>。</p>
<p><strong>维吉尼亚密码</strong>：密钥是由多于一个的字符所组成的串，令m为密钥长度，那么明文串被分为m个字符的小段。加密算法的运算同于密钥串和明文串之间的移位密码。</p>
<p>例如：</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307181612145.png" alt="image-20230718161206021"></p>
<h3 id="弗纳姆密码和一次一密"><a href="#弗纳姆密码和一次一密" class="headerlink" title="弗纳姆密码和一次一密"></a>弗纳姆密码和一次一密</h3><p><strong>弗纳姆密码</strong> 我们假设消息是比特串：$m=b_1b_2…b_n \in 0,1^n$</p>
<p>那么密钥也是长为n的比特串： $k=k_1k_2…k_n \in 0,1^n$</p>
<p>一次加密一比特，通过将每个消息比特和相应的密钥比特进行比特异或得到密文串 $c=c_1c_2…c_n$，其中$c_i=b_i \bigoplus k_i$</p>
<h2 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h2><p>首先我们要指出古典密码的两个基本工作原理：代换和换位。</p>
<p>古典密码安全使用的条件： $#K \ge #M,k \in K$，每次加密只使用一次。</p>
]]></content>
      <categories>
        <category>密码学基础</category>
      </categories>
      <tags>
        <tag>对称密码</tag>
      </tags>
  </entry>
  <entry>
    <title>同态加密</title>
    <url>/posts/c86299ce.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="同态加密"><a href="#同态加密" class="headerlink" title="同态加密"></a>同态加密</h1><p>同态加密（Homomorphic Encryption）是一种特殊的加密方法，允许对密文进行处理得到仍然是加密的结果。即对密文直接进行处理，跟对明文进行处理后再对处理结果加密，得到的结果相同。从抽象代数的角度讲，保持了同态性。</p>
<p>本文，我们先回顾传统的加密方式，再介绍几种典型的同态加密</p>
<span id="more"></span>
<h1 id="传统的加密方式"><a href="#传统的加密方式" class="headerlink" title="传统的加密方式"></a>传统的加密方式</h1><p>构建一个加密系统，往往需要一个密钥（key），通过这个密钥，我们可以把明文的信息加密成密文，然后通过密钥再把密文变回原来的样子。所有的加密系统，无疑是做了三件事：</p>
<ol>
<li><p>$KeyGen(1^ \lambda)$ 来随机生成一对加密和解密的密钥（$Enc<em>{Key},Dec</em>{Key}$）</p>
</li>
<li><p>加密方通过加密密钥$Enc_{Key}$和加密算法$Encryption$来加密明文$plaintext$，得到密文$ciphertest$</p>
</li>
<li><p>解密方通过解密密钥$Dec_{Key}$和解密算法$Decryption$来解密密文，得到明文$plaintext$</p>
</li>
</ol>
<p>在密码学研究中，每当我们看到一个新的系统的定义之后，接下来往往都要陈述这个系统所应具有的<strong>属性</strong>。</p>
<p><strong>正确性</strong> 如果我拥有一个正确的密钥，那么我就可以通过解密算法$Decryption$来把密文还原成原文。我们如下表示解密的成功率</p>
<script type="math/tex; mode=display">
\forall pt \in PT,(k_{enc},k_{dec})\larr KenGen(1^\lambda)\\
Pr[Decryption(k_{dec},Encryption(k_{enc},pt))=pt]=1</script><p>等式代表了，如果我们拥有<strong>正确的密钥</strong>，那么解密算法可以还原加密算法生成的密文的几率是<strong>100%</strong>。</p>
<p><strong>语义安全（Semantic Security）</strong></p>
<p>如果我们拥有任意两个不同的原文所对应的密文，那么我们是无法区分到底哪个密文是对应了哪个原文的：</p>
<p>$\forall m<em>0.m_1:Enc(k</em>{enc},m<em>0)≈Enc(k</em>{dec},m_1)$</p>
<p>语义安全的主要意义在于旁观者无法区分两条加密的消息。</p>
<h1 id="同态加密的分类"><a href="#同态加密的分类" class="headerlink" title="同态加密的分类"></a>同态加密的分类</h1><p>系统来看，同态加密大致上可以分为四类：部分同台，近似同台，有限级数全同态与完全同态。</p>
<p>$f([x_1],[x_2],…,[x_n])\rarr [f(x_1,x_2,…,x_n)]$</p>
<h2 id="部分同态加密"><a href="#部分同态加密" class="headerlink" title="部分同态加密"></a>部分同态加密</h2><p>同态加密最初级的阶段被称为<strong>部分同态加密</strong>，定义就是密文<strong>只有一种同态特性</strong>，指<strong>同态加密算法只对加法或乘法（其中一种）有同态的性质</strong>。</p>
<p>假如说我们可以通过一个加法同态加密的算法来计算$F$的话，那么代表了这个函数F肯定就只能包含私密输入<br>$x_i$的任意线性组合（加法运算）。一个可行的例子就是把各项私密输入乘以一个常数，然后相加起来：</p>
<p>$f(x_1,…,x_n)\rarr c_1x_1+c_2x_2+…+c_nx_n$</p>
<p>常见的加法同态加密算法就是基于循环群$G$的ElGamal加密算法。</p>
<p>假如我们拥有两条消息$m_0,m_1$的加密，分别为$ct_0,ct_1$，$ct_0=(v_0=g^{y_0},e_0=pk^{y_0}\cdot g^{m_0}),ct_1=(v_1=g^{y_1},e_1=pk^{y_1}\cdot g^{m_1})$</p>
<p>我们把两条密文的两个部分各自相乘的话，可以得到一个新的密文$\hat{ct}$</p>
<p>$\hat{ct}=ct_0\cdot ct_1 = (\hat{v}=g^{y_0+y_1},\hat{e}=pk^{y_0+y_1}\cdot g^{m_0+m_1})$</p>
<p>我们得到的结果恰恰就是原文$m_0+m_1$加在一起之后所对应的加密密文！这样的话，如果我们得到了两条ElGamal加密算法的密文，我们就可以通过这样的方法得到密文的任意线性组合了。</p>
<p>RSA加密就是一个乘法同态的系统。</p>
<p>假如我们拥有两条消息$m_0,m_1$的加密，分别为$ct_0,ct_1$，$ct_0=m_0^e(modN),ct_1=m_1^e(modN)$</p>
<p>我们把两条密文的两个部分各自相乘的话，可以得到一个新的密文$\hat{ct}$</p>
<p>$\hat{ct}=ct_0\cdot ct_1 = m_0^e\cdot m_1^e=(m_0\cdot m_1)^e$</p>
<h3 id="近似同态加密（Somewhat-Homomorphic-Encryption）"><a href="#近似同态加密（Somewhat-Homomorphic-Encryption）" class="headerlink" title="近似同态加密（Somewhat Homomorphic Encryption）"></a>近似同态加密（Somewhat Homomorphic Encryption）</h3><p>单纯的部分同态加密算法（RSA,ElGamal）无法完成加密的线性组合。</p>
<p>如果我们有近似同态加密算法的话，那么我们就可以在密文上<strong>同时计算加法与乘法了</strong>。但是,因为这一阶段是<strong>近似同态（Somewhat Homomorphic）</strong>的，所以可以做的加法和乘法次数非常有限，可以计算的函数$F$也<strong>在一个有限的范围内</strong>。</p>
<p><strong>基于配对（Pairing）的循环群加密算法</strong></p>
<p>配对（pairing）是基于某些特有的椭圆曲线循环群可以进行的一种特殊运算，我们用$e(\cdot,\cdot)$，它的作用是把两个循环群中的值映射到第三个循环群中：$e(g^x\in G,g^y\in G)\rarr g^{xy}_T \in G_T$</p>
<p>但是，Pairing这一特殊属性并不会出现在所有的循环群当中，通过拥有Pairing属性的循环群，我们只能做<strong>非常有限的乘法计算</strong>。假如说我们当前的群$G$支持Pairing，但是新的映射群$G_T$并不支持任何Pairing，那就代表了如果我们要基于当前的体系进行同态加密运算，可以运算的函数F虽然可以包涵任意的线性组合，但是只能包涵最多一层乘法在里面。</p>
<p>这一局限性证明了这个系统是近似同态的，因为我们不能计算任意逻辑和深度的函数F。</p>
<h3 id="有限级数全同态加密"><a href="#有限级数全同态加密" class="headerlink" title="有限级数全同态加密"></a>有限级数全同态加密</h3><p>我们已经可以对密文进行<strong>任意的加法乘法组合</strong>了，没有任何对于次数的局限性。</p>
<p>但是之所以被称之为有限级数全同态的原因是，这个阶段的算法会引入一个新的复杂度上限$L$的概念，这一复杂度上限约束了函数$F$的复杂度。如果我们可以把$F$用二进制电路$C$来表示的话，那么$C$的深度和大小一定要在$L$的范围之内: $\vert C \vert \le L$</p>
<h3 id="全同态加密（Fully-Homomorphic-Encryption，FHE）"><a href="#全同态加密（Fully-Homomorphic-Encryption，FHE）" class="headerlink" title="全同态加密（Fully Homomorphic Encryption，FHE）"></a>全同态加密（Fully Homomorphic Encryption，FHE）</h3><p>一个全同态加密的系统没有任何计算方法的限制，我们可以在没有密钥的情况下，把密文任意的组合起来，形成新的密文，并且新的密文，无论计算的复杂度，都可以完美的被还原成原文。</p>
<p>一个全同态加密系统，一共拥有四个算法：</p>
<ol>
<li>密钥生成算法$KeyGen(1^\lambda)\rarr sk$，生成加密与解密需要用到的密钥$sk$。</li>
<li><p>加密算法$Enc(sk,m)\rarr ct$，把原文$m$加密成密文$ct$</p>
</li>
<li><p>解密算法$Dec(sk,ct)\rarr m$，还原密文</p>
</li>
<li>运算算法$Eval(F,ct_1,…ct_l)\rarr \hat ct$，把l个密文组合起来，通过一个二进制逻辑电路$F$，最后得到密文$\hat ct$，$Dec(sk,\hat ct)=F(m_1,…,m_l)$</li>
</ol>
<p>现在我们来看看这个系统的<strong>属性（Properties）</strong>。首先，这个体系必须得是<strong>正确的（Correctness）</strong>。如果我们任意选择一个电路F，并且任意选择一组原文消息$m_1,…m_l$。如果我们拥有一开始$KeyGen$算法生成的密钥的话，那么$Dec(sk,Eval(F,Enc(sk,m_1),…Enc(sk,m_l)))=F(m_1,…,m_l)$</p>
<p>其次，这个系统需要达到<strong>语义安全</strong>。</p>
<p>为了让全同态加密体系变得有实际的使用意义，我们必须还得加一条额外的规定：<strong>简短性（Compactness）</strong>。简单来说，$Eval$这个算法的输出结果大小必须独立于二进制电路$F$的大小: $\forall F, sk, ct_i \larr Enc(sk,m_i),\vert Eval(F,ct_1,…,ct_l) \vert =poly(\lambda)$</p>
<p>如果没有简短性的要求，我们可以做出一个作弊的全同态加密：</p>
<ol>
<li>密钥生成、加密算法可以任意选择一个语义安全的对称加密算法。</li>
<li>$Eval(F,ct_i)\rarr (F,ct_i)$ ：运算算法$Eval$要做的事情很简单，直接把对于$F$的描述和原来的密文$ct_i$全部输出到新的密文$\hat {ct}$当中。</li>
<li>$Dec(sk,(F,ct_i))\rarr F(Dec(sk,ct_1),…,Dec(sk,ct_l))$ ：最后在解密的时候，先把密文全部依次解密回原文，然后再根据对F的描述手动跑一下得到原来的结果。</li>
</ol>
<p>只要满足<strong>正确、语义安全、简短</strong>这三个要素，我们就拥有一个<strong>有意义（Non-trivial）的全同态加密体系</strong>了。</p>
<h2 id="全同态加密的历史回顾"><a href="#全同态加密的历史回顾" class="headerlink" title="全同态加密的历史回顾"></a>全同态加密的历史回顾</h2><p>1978年，密码学界的几个大牛<strong>Rivest，Adleman和Dertouzos</strong>在他们的论文<strong>On Data Banks and Privacy Homomorphisms</strong>中第一次提到了对于密文进行一定的计算，可以间接地对原文进行操作的系统构想。到后来这一想法就被重新总结命名为<strong>全同态加密</strong>了。</p>
<p>直到2009年，在斯坦福读书的PhD <strong>Craig Gentry</strong>突然灵光一现，攻破了FHE算法的难关。在他的博士毕业论文中，他第一次给出了一个合理并且安全的全同态加密系统！这一系统基于<strong>理想格（ideal lattice）的假设</strong>。Gentry09提出来的全同态系统，我们往往称之为<strong>第一代全同态加密系统</strong>。</p>
<p>在2011年的时候，两位大佬<strong>Brakerski和Vaikuntanathan</strong>提出了一个新的全同态加密体系，这一体系基于<strong>格（lattice）加密</strong>的另一种假设<strong>Learning With Errors（LWE）</strong>。在同一年，Brakerski，Gentry与Vaikuntanathan这三人一起把这个体系做完了，并且正式发表出来。他们发明的全同态系统简称为<strong>BGV系统</strong>。BGV系统是一个<strong>有限级数</strong>的同态加密系统，但是可以通过Bootstrapping的方式来变成全同态系统。BGV系统相比起Gentry09提出的系统，使用了更加实际一点的LWE假设。一般来说我们都把BGV系统称之为<strong>第二代全同态加密系统</strong>。</p>
<p>2013年，<strong>Gentry又卷土重来了</strong>。Gentry，Sahai和Waters三个大佬推出了新的<strong>GSW全同态加密系统</strong>。GSW系统和BGV相似，本身具有有限级数全同态性质，基于更加简单的LWE假设，并且通过Bootstrapping可以达到全同态。我们一般把GSW系统称为<strong>第三代全同态加密系统</strong>。</p>
]]></content>
      <categories>
        <category>同态加密</category>
      </categories>
      <tags>
        <tag>同态加密</tag>
      </tags>
  </entry>
  <entry>
    <title>差分隐私</title>
    <url>/posts/b192ad14.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>本文将介绍差分隐私及其相关概念。</p>
<span id="more"></span>
<h1 id="差分隐私的承诺"><a href="#差分隐私的承诺" class="headerlink" title="差分隐私的承诺"></a>差分隐私的承诺</h1><p>一个有趣的例子：</p>
<p>医学数据库可能会告诉我们，<strong>吸烟会导致癌症</strong>，影响保险公司对吸烟者长期医疗费用的看法。吸烟者受到分析的伤害了吗？如果保险公司知道他吸烟，他的保险费可能会上涨。他可能也会得到帮助。但保险公司学习他的健康风险，使他进入戒烟计划。吸烟者的隐私被侵犯了吗？当然，研究结束后对他的了解比以前更多，但他的信息是不是“泄露”了？差分隐私将认为它不是，理由是<strong>对吸烟者的影响是相同的独立于他是否在研究中</strong>。是这项研究得出的结论影响了吸烟者，而不是他在数据集中的存在与否影响了实验得出的结论。</p>
<p>差分隐私解决了一个问题，即分析人员通过数据集学习整体信息的同时（趋势、统计信息），无法获取个人的详细信息。</p>
<p>对于给定的计算任务 $T$和给定的$\varepsilon$值，将有许多不同的私有算法以$\varepsilon$方式实现$T$。有些算法会比其他算法更准确。当$\varepsilon$很小时，很难为任务$T$找到一个高精度的$\varepsilon$-差分隐私算法，就像为一个特定的计算任务找到一个数值稳定的算法一样。</p>
<p>隐私保护的数据分析</p>
<h3 id="数据不能完全匿名并且仍然有用"><a href="#数据不能完全匿名并且仍然有用" class="headerlink" title="数据不能完全匿名并且仍然有用"></a>数据不能完全匿名并且仍然有用</h3><p>一般来说，数据越丰富，就越有趣和有用。这就产生了“匿名化”和“删除可识别个人信息”的概念，这些概念希望部分数据记录可以被掩盖，其余部分可以发布并用于分析。</p>
<p>然而，由于数据的丰富性使得“个人”数据属性可能与其他领域的数据属性相重合，比如邮政编码、出生日期和性别的组合，甚至三个电影的名字和一个独立的人观看这些电影的大致日期。这种“命名”功能可用于联动攻击，以将不同数据集中的“匿名”记录与非匿名记录进行匹配。有如下两个事例：</p>
<ul>
<li>1.通过将匿名医疗遭遇数据与（公开提供的）选民登记记录相匹配，确定了马萨丘塞特政府的医疗记录。</li>
<li>2.通过与互联网电影数据库（IMDB）的链接，确定了 Netflix 用户，其观看历史记录包含在 Netflix 发布的匿名电影记录集合中，作为推荐竞赛的训练数据。</li>
</ul>
<h3 id="重标识“匿名”记录并非唯一风险"><a href="#重标识“匿名”记录并非唯一风险" class="headerlink" title="重标识“匿名”记录并非唯一风险"></a>重标识“匿名”记录并非唯一风险</h3><p>“匿名”数据记录的重新标识显然是不可取的，这不仅是因为重新标识本身（这肯定揭示了数据集中的成员身份），而且还因为记录可能包含损害信息，如果它与个人相关联，则可能会造成损害。在给定日期从特定紧急护理中心收集的医疗遭遇记录可能只列出少量不同的投诉或诊断。邻居在相关日期访问设施的附加信息给出了邻居病情的一系列可能诊断结果。可能无法将特定记录与邻居匹配这一事实为邻居提供了最低限度的隐私保护。</p>
<h3 id="长期的事实并不“好”"><a href="#长期的事实并不“好”" class="headerlink" title="长期的事实并不“好”"></a>长期的事实并不“好”</h3><p>如果一个数据主体随着时间的推移而被跟踪，那么揭露数据个体长期的行为（例如购买面包）可能会有问题。举个例子，假设某人，他年复一年地定期买面包，直到突然转向很少买面包。一位分析师可能会得出结论，某人很可能被诊断为2型糖尿病。分析员可能是正确的，也可能是不正确的；不管怎样，某人的隐私都会受到伤害。</p>
<h1 id="差分隐私的公式化"><a href="#差分隐私的公式化" class="headerlink" title="差分隐私的公式化"></a>差分隐私的公式化</h1><p><strong>定义1（概率单纯形）</strong>，给定一个离散集$B$，将$B$上的概率单纯形（是一个数学空间，其中的每个点代表有限个互斥事件之间的概率分布），表示为$\Delta(B)$，其定义为：</p>
<script type="math/tex; mode=display">
\Delta(B)=\{x\in R^{\vert B \vert}:\ x_i \ge 0\ for\ all\ o\ and\ \Sigma_{i=1}^{\vert B\vert}x_i=1 \}</script><p>可以理解为将数据库中的数据集映射到各个离散状态集合$B$中</p>
<p><strong>定义2（数据库之间距离）</strong>，将数据库的$l_1$范数距离表示为$\vert \vert x\vert \vert_1$，其定义为</p>
<script type="math/tex; mode=display">
$\vert \vert x\vert \vert_1=\Sigma_{i=1}^{\vert \chi \vert} \vert x_i\vert</script><p>数据库$x,y$之间的距离为$\vert \vert x-y \vert \vert_1$</p>
<p>注意到$\vert \vert x\vert \vert_1$是衡量数据库$x$的大小（也就是说，数据库$x$包含的记录数），而$\vert \vert x-y \vert \vert_1$表示数据库$x$和$y$之间相差多少条记录。我们称这种记录相差为1的数据库为相邻数据集。</p>
]]></content>
      <categories>
        <category>差分隐私</category>
      </categories>
      <tags>
        <tag>差分隐私</tag>
      </tags>
  </entry>
  <entry>
    <title>差分隐私（二）</title>
    <url>/posts/5e047603.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>本文将介绍差分隐私中和熵相关的概念。</p>
<span id="more"></span>
<h1 id="Renyi-Entropy"><a href="#Renyi-Entropy" class="headerlink" title="Renyi Entropy"></a>Renyi Entropy</h1><p><strong>熵</strong>在密码学中有很多应用，比如说常见的<strong>香农熵</strong>和<strong>Hartley Function</strong>，它们都是由<strong>Renyi Entropy</strong>推广得到的：</p>
<script type="math/tex; mode=display">
H_{\alpha}(X)=\frac{1}{1-\alpha}log(\Sigma_{i=1}^np_i^{\alpha}),\ \alpha \ge0,\ \alpha\ne1</script><p>至于说<strong>Renyi Entropy</strong>是如何得到其他熵的？是不同的$\alpha$对应不同的熵</p>
<p>如果将$p$看成向量，括号里的形式实际上可以被看成向量的$\alpha$范数</p>
<script type="math/tex; mode=display">
H_{\alpha}(X)=\frac{1}{1-\alpha}log(\Sigma_{i=1}^np_i^{\alpha})=\frac{\alpha}{1-\alpha}log\| p \| _{\alpha}</script><h2 id="Hartley-Function-or-max-entropy"><a href="#Hartley-Function-or-max-entropy" class="headerlink" title="Hartley Function or max-entropy"></a>Hartley Function or max-entropy</h2><p>当$\alpha=0$时，$H_0(X)$实际上就是Hartley熵</p>
<script type="math/tex; mode=display">
H_{\alpha}(X)=\frac{1}{1-0}log(\Sigma_{i=1}^np_i^{0})=log\ n</script><p>他表示的意思是：如果从有限集合<em>A</em>中均匀随机地选取样本，则已知结果后所揭示的信息由哈特利函数给出。</p>
<p>哈特利使用了以十为底的对数，以这个底数，信息单位被称为哈特利（又名ban或dit）以纪念他。它也称为哈特利熵或最大熵。</p>
<h3 id="Shannon-entropy"><a href="#Shannon-entropy" class="headerlink" title="Shannon entropy"></a>Shannon entropy</h3><p>当$\alpha \rarr 1$时，$H_1{X}$实际上就是<strong>Shannon熵</strong></p>
<script type="math/tex; mode=display">
H_1(X)=\lim_{\alpha \rarr 1} \frac{1}{1-\alpha}log(\Sigma_{i=1}^np_i^{\alpha})</script><script type="math/tex; mode=display">
H_1(X)=\lim_{\alpha \rarr 1} \frac{1}{-1} \frac{\Sigma_{i=1}^n p_i^{\alpha}\ln p_i}{\Sigma_{i=1}^np_i^{\alpha}}=-\Sigma_{i=1}^n p_i \ln p_i</script><h1 id="Renyi-Divergence"><a href="#Renyi-Divergence" class="headerlink" title="Renyi Divergence"></a>Renyi Divergence</h1><p><code>Divergence</code>并不是距离，因为不满足距离定义中的<code>对称性</code>，但是我们仍然可以用它来衡量两个分布之间的差距，比如常用的<code>KL-Divergence</code>。而和<code>Renyi Entropy</code>一样，<code>Renyi Divergence</code>也是<code>KL-Divergence</code>和<code>Max-Divergence</code>的推广。</p>
<script type="math/tex; mode=display">
D_{\alpha}(p\| Q)=\frac{1}{\alpha-1}\log (\Sigma_{i=1}^n q_i \frac {p_i^{\alpha}}{q_i^{\alpha}})</script><h2 id="KL-Divergece"><a href="#KL-Divergece" class="headerlink" title="KL Divergece"></a>KL Divergece</h2><p>当$\alpha \rarr 1$</p>
<script type="math/tex; mode=display">
D_{\alpha}(p\| Q)=\frac{1}{\alpha-1}\log (\Sigma_{i=1}^n q_i \frac {p_i^{\alpha}}{q_i^{\alpha}})</script><script type="math/tex; mode=display">
D_{1}(p\| Q)=\log \Sigma_{i=1}^n p_i \frac {p_i}{q_i}</script><h2 id="Max-Divergence"><a href="#Max-Divergence" class="headerlink" title="Max Divergence"></a>Max Divergence</h2><p>当$\alpha \rarr \infty$</p>
<script type="math/tex; mode=display">
D_{\infty}(p\| Q)=\lim_{\alpha \rarr \infty}\frac{1}{\alpha-1}\log (\Sigma_{i=1}^n q_i \frac {p_i^{\alpha}}{q_i^{\alpha}})=\log \max \frac{p_i}{q_i}</script><h1 id="3-差分隐私中的Divergence"><a href="#3-差分隐私中的Divergence" class="headerlink" title="3 - 差分隐私中的Divergence"></a>3 - 差分隐私中的Divergence</h1><p>从<code>Max-Divergence</code>可以看到，当对这个<code>Max-Divergence</code>进行约束之后：</p>
<script type="math/tex; mode=display">
D_{\infty}(P\| Q)=\log \max \frac{p_i}{q_i}</script><script type="math/tex; mode=display">
\frac {Pr(A(x)=t)}{Pr(A(x^\prime)=t)} \le exp(\varepsilon)</script>]]></content>
      <categories>
        <category>差分隐私</category>
      </categories>
      <tags>
        <tag>差分隐私</tag>
      </tags>
  </entry>
  <entry>
    <title>承诺</title>
    <url>/posts/2de2aebf.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="承诺"><a href="#承诺" class="headerlink" title="承诺"></a>承诺</h1><span id="more"></span>
<p>承诺分为三个步骤：承诺，打开承诺，验证承诺。</p>
<p>承诺：承诺:发送方将某个值$x$封装为$y$发送给接收方。(1)发送方不能修改信封中的值(绑定性);(2)接收方无法知道$x$(隐藏性)。</p>
<p>打开承诺:发送方揭露$x$。</p>
<p>校验承诺:接收方校验打开的值$x$与$y$中封装的$x$是否相同。</p>
<p><strong>承诺一个值</strong></p>
<ul>
<li>承诺：选择$x$，计算$y=f(x)$，发送函数值$y$</li>
<li>打开承诺：发送原象$x$</li>
<li>校验承诺：函数一致性$y=f(x)$</li>
</ul>
<p>对函数有一定要求：</p>
<ul>
<li>函数求逆是 NP 困难的,需要指数时间暴力搜索。防止根据承诺值 y 计算 x。</li>
<li>但是校验简单,仅需要多项式时间计算复杂度。</li>
<li>该函数通常是哈希函数或 pedersen 承诺函数等。</li>
</ul>
<p><strong>承诺一个多项式</strong></p>
<ul>
<li>承诺：选择$n+1$个随机数$a<em>0,a_1,…,a_n$，构造多项式$f(x)=\Sigma</em>{i=0}^na_ix^i$，计算$A_i=a_iG,\ i=0,…,n$，发送$A_i$</li>
<li>打开承诺：打开一个随机点$k$，计算$f(k)=\Sigma_{i=0}^na_ik^i$，发送$(k,f(k))$</li>
<li>校验承诺：基于$A<em>i$，校验$(k,f(k))$正确性，$f(k)G=\Sigma</em>{i=0}^n(k^iA_i)$</li>
</ul>
<p>如果攻击者不知道多项式,选择随机数作为函数值,则发生碰撞的概率可忽略。</p>
<p>因此,不必打开多项式所有系数,仅打开一个或多个函数点即可,从而减少发送数据。</p>
<p>此外,没泄露多项式,具有保密性。需要 n+1 个值,才会泄露多项式的系数。</p>
<h1 id="哈希承诺"><a href="#哈希承诺" class="headerlink" title="哈希承诺"></a>哈希承诺</h1><ul>
<li>承诺：发送哈希值$y$</li>
<li>打开承诺：发送原象$x$</li>
<li>校验承诺：校验哈希一致性$y=hash(x)$</li>
</ul>
<p>哈希函数求逆满足NP困难</p>
<h1 id="Merkle承诺与Merkle证明"><a href="#Merkle承诺与Merkle证明" class="headerlink" title="Merkle承诺与Merkle证明"></a>Merkle承诺与Merkle证明</h1><ul>
<li><p>承诺：发送$root$</p>
</li>
<li><p>打开承诺：发送叶子节点$x_i$和$path_i$，其中$path_i$是指兄弟节点</p>
</li>
<li>校验承诺：校验$root=Merkle(x_i,path_i)$</li>
</ul>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202308031557201.png" alt="image-20230803155735081"></p>
<p>问题：证明方证明知道每个叶子的值$x_i,i0=,..,2^n$</p>
<p>低效做法：</p>
<ul>
<li>承诺：发送root</li>
<li>打开承诺：发送所有叶子节点$x_i$</li>
<li>校验承诺：校验$root=Merkle(x<em>0,…,x</em>{2^n})$</li>
</ul>
<p>高效做法：</p>
<ul>
<li><p>承诺：发送$root$</p>
</li>
<li><p>打开承诺：发送叶子节点$x_i$和$path_i$</p>
</li>
<li>校验承诺：校验$root=Merkle(x_i,path_i)$</li>
</ul>
<p>发送数据和校验复杂度均降低。</p>
<p>如果每个叶子的取值是 0 或 1,则 n 次均成功概率为$1/2^n$ 。</p>
<p>如果每个叶子的取值空间为m,则 n 次均成功概率为$1/m^{20}$。</p>
<p>核心思想：从概率角度，不必打开全部叶子节点；仅需要打开 n 个点，如果每次都正确，则伪造成功概率指数降低。因此，验证方相信证明方知道所有叶子节点。</p>
<h1 id="Sigma零知识证明中的承诺"><a href="#Sigma零知识证明中的承诺" class="headerlink" title="Sigma零知识证明中的承诺"></a>Sigma零知识证明中的承诺</h1><p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202308031604670.png" alt="image-20230803160409620"></p>
<p>承诺$A=rG$，挑战$e$，相应$z=r+e\omega$，校验$zG=A+eQ$</p>
<h1 id="Pedersen承诺"><a href="#Pedersen承诺" class="headerlink" title="Pedersen承诺"></a>Pedersen承诺</h1><p>初始化：椭圆曲线生成元为$G,H,H=\alpha G$，其中$\alpha$保密</p>
<ul>
<li>承诺：Token数量为m和随机数为r，计算$P=mG+rH$，发送P</li>
<li>打开承诺：发送m和r</li>
<li>校验承诺：校验一致性$P=mG+rH$</li>
</ul>
<p>Pedersen承诺的同态性</p>
<p>初始状态：A和B的余额密文是0</p>
<ul>
<li>C对$m<em>1$个Token承诺：$P_1=m_1G+r_1H$，接收地址为$Addr</em>{Alice}$，然后签名广播。<strong>打开承诺</strong>：私底下保密发送$m_1,r_1$给A，A校验Pedersen承诺的一致性，且等交易单上链后，则收款成功</li>
<li>D对$m<em>2$个Token承诺：$P_2=m_2G+r_2H$，接收地址为$Addr</em>{Alice}$，然后签名广播。<strong>打开承诺</strong>：私底下保密发送$m_2,r_2$给A，A校验Pedersen承诺的一致性，且等交易单上链后，则收款成功</li>
</ul>
<p>经过共识算法：矿工上链A余额密文：$P_1+P_2=(m_1+m_2)G+(r_1+r_2)H$</p>
<p>A知道秘密，$m_1+m_2$和随机数$r_1+r_2$，则A能花费该费用。</p>
<ul>
<li>A对$m<em>3$个Token承诺：$P_3=m_3G+r_3H$，接收地址为$Addr</em>{Bob}$，然后签名广播，<strong>打开承诺</strong>：私底下保密发送$m_3,r_3$给B，B校验Pedersen承诺的一致性，且等交易单上链后，则收款成功</li>
</ul>
<p>经过共识算法：矿工上链A和B余额密文：</p>
<script type="math/tex; mode=display">
A:P_1+P_2-P_3=(m_1+m_2-m_3)G+(r_1+r_2-r_3)H\\
B:P_3=m_3G+r_3H</script><ul>
<li>A知道$(m_1+m_2-m_3),(r_1+r_2-r_3)$可以继续支付</li>
<li>B知道$m_3,r_3$也可以继续支付</li>
</ul>
<p>如果$\alpha$泄露：</p>
<p>A知道$G,H$之间的离散对数$\alpha$，后果很严重。</p>
<p><strong>真实情况</strong>，A拥有小金额$m=10$和随机数$r$，余额承诺为$P=mG+rH$</p>
<p>A能够计算$\alpha^{_1}$，选择一个大金额$m^{\prime}=200000$，计算随机数$r^{\prime}=r-(m^{\prime}-m)\alpha^{-1}$</p>
<ul>
<li>A支付$m^{\prime}$个Token，支付承诺为$P=m^{\prime}G+r^{\prime}H$，接收地址为$Addr_{Bob}$，然后签名广播，打开承诺：私底下保密发送$m^{\prime},r^{\prime}$给B，B校验Pedersen承诺的一致性，且等交易单上链后，则收款成功</li>
</ul>
<p>经过共识算法：矿工上链B余额密文：$P=m^{\prime}G+r^{\prime}H$</p>
<script type="math/tex; mode=display">
m^{\prime}G+r^{\prime}H=m^{\prime}G+(r-(m^{\prime-m})\alpha^{-1})H\\
=m^{\prime}G+rH-m^{\prime}\alpha^{-1}H+m\alpha^{-1}H\\
=mG+rH=P</script><p>类似结论：zcash中各个生成元$g_i,h_i$之间的离散对数不能泄露</p>
]]></content>
      <categories>
        <category>密码学基础</category>
      </categories>
      <tags>
        <tag>密码学基础</tag>
      </tags>
  </entry>
  <entry>
    <title>拜占庭攻击</title>
    <url>/posts/c64cf0b7.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>拜占庭将军问题（Byzantine Generals Problem），是由莱斯利·兰波特在其同名论文中提出的分布式对等网络通信容错问题。</p>
<p>在分布式计算中，不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动。但有时候，系统中的成员计算机可能出错而发送错误的信息，用于传递信息的通讯网络也可能导致信息损坏，使得网络中不同的成员关于全体协作的策略得出不同结论，从而破坏系统一致性。</p>
<span id="more"></span>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307241549063.png" alt="img"></p>
<p>在第t轮训练迭代中，一个诚实的参与者上传梯度：</p>
<script type="math/tex; mode=display">
\Delta \omega _i ^{(t)}:=\bigtriangledown F_i(\omega_i^{(t)})</script><p>而一个恶意用户可能会上传任意值。</p>
<script type="math/tex; mode=display">
\Delta \omega _i ^{(t)}=
\begin {cases}
*,malicious\\
\bigtriangledown F_i(\omega_i^{(t)}),otherwise
\end {cases}</script><p>其中，*为任意值，Fi代表第i个用户模型的目标函数。</p>
<p>目前针对联邦学习的拜占庭攻击主要分为三种模式。</p>
<p>第一种攻击模式称为数据污染攻击，是通过在客户端本地数据集中加入污染过的图片使得客户端上传的模型准确度很差，进而影响全局模型。常见的数据污染攻击包括标签反转攻击（Label-flipping Attack）、基于反向梯度优化的攻击（Back-gradient optimization based attack）等等。相比于其他方式，数据污染攻击的攻击强度比较弱、攻击精度比较差，但是比较容易进行。</p>
<p>第二种攻击模式称为模型污染攻击，是在模型的训练过程中以及传输过程中进行修改，不涉及对本地数据的变更，代表是局部模型污染攻击（Local Model Poisoning Attack）。模型污染攻击的攻击强度很高，并且可以进行更有针对性的攻击，但是相应的也需要对客户端更多的控制权。</p>
<p>第三种攻击模式是前两种攻击的融合，比如目标模型污染（Targeted Model Poisoning）和隐式模型污染（Stealthy Model Poisoning）。第三种模式不但会修改被控制的客户端的本地数据，而且也会对模型训练过程进行影响。相比于前两种攻击方式，第三种攻击方式不但拥有较好的隐秘性而且还拥有很强的精确性。</p>
]]></content>
      <categories>
        <category>AI安全</category>
      </categories>
      <tags>
        <tag>模型攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>数学基础</title>
    <url>/posts/e403a46.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>本文介绍密码学中常用的一些符号和数学知识。</p>
<span id="more"></span>
<h1 id="标准符号"><a href="#标准符号" class="headerlink" title="标准符号"></a>标准符号</h1><p>$#S$，集合$S$中的元素数目</p>
<p>$F_q$，q个元素的有限域</p>
<p>$desc(A)$，代数结构A的描述</p>
<p>$x\larr D$，根据分布$D$进行赋值</p>
<p>$x\larr _US$，按$S$为均匀分布进行赋值</p>
<p>$ord(x)$，群元素的阶</p>
<p>$<g>$，由g生成的循环群</g></p>
<h1 id="概率论和信息论"><a href="#概率论和信息论" class="headerlink" title="概率论和信息论"></a>概率论和信息论</h1><p>概率论和信息论是现代密码技术发展必不可少的工具。</p>
<p>现代密码系统，特别是公钥密码系统，对概率行为的要求已经达到相当苛刻的程度：语义安全性。</p>
<h2 id="概率论的基本概念"><a href="#概率论的基本概念" class="headerlink" title="概率论的基本概念"></a>概率论的基本概念</h2><p>令$S$为一个任意确定的点的集合,称之为概率空间(或样本空间)。任意元素$x\in S$称为样点(也称为结果、简单事件或不可分事件;为了简单我们将只用点)。一个事件(也称为合成事件或可分事件)是$S$的一个子集,通常用一个大写字母表示(比如$E$)。一次实验或观察是一种从$S$中产生(取出)一个点的动作。一个事件$E$的发生就是一个试验产生某个点$x\in S$,并满足:$x\in E$。</p>
<p><strong>概率的经典定义</strong></p>
<p>假设一个实验可以从$n=# S$个等可能的点中产生一个点，并且每次实验必须产生一个点。令$m$表示事件$E$包含的点的数目，那么$\frac{m}{n}$为事件$E$发生的概率，并记为$Prob[E]=\frac{m}{n}$</p>
<p><strong>概率的统计定义</strong></p>
<p>假设在相同条件下进行了$n$次实验，其中事件$E$发生了$\mu$次，如果对所有足够大的$n$，$\frac{\mu}{n}$保持不变，那么就是说事件$E$的概率为$\frac{\mu}{n}$，记为，$Prob[E]\approx \frac{\mu}{n}$</p>
<h2 id="随机变量及其概率分布"><a href="#随机变量及其概率分布" class="headerlink" title="随机变量及其概率分布"></a>随机变量及其概率分布</h2><p>在密码学中，我们主要考虑定义在离散空间上的函数。设离散空间$S$包含有限个或者可数个孤立的点$x_1,…,$</p>
<p><strong>离散随机变量及其分布函数</strong></p>
<p>一个离散随机变量是一个实验的数字化结果。它是定义在样本空间上的函数</p>
<p>设$S$为一个概率空间，$\xi$为一个随机变量。$\xi$的分布函数是$S\rarr R$的一个函数，以一个概率值$Prob[\xi=x_i]=p_i$</p>
<h3 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h3><p>密码学中最常用的随机变量服从均匀分布：$Prob[\xi=x_i]=\frac{1}{ # S}$</p>
<p>设$S$表示最长为$k$比特的非负数集合，依据均匀分布，从$S$中随机取出一个数，所取的数为k比特的概率是$\frac{1}{2}$</p>
<h3 id="二项式分布"><a href="#二项式分布" class="headerlink" title="二项式分布"></a>二项式分布</h3><p>假定一个实验只有两个结果,记为“成功”和“失败”(例如,抛一枚硬币只有两个结果,“正面”和“反面”)。独立地重复进行该实验,如果每一次实验结果仅有两种可能的点，且它们的概率在整个实验过程中保持不变,那么这样的实验就称为贝努利试验(bernoulli trials)。</p>
<p>假设在任何一次试验中：$Prob[Y]=p,Prob[N]=1-p$</p>
<p>那么$Prob[n\ test,k\ N]=C_n^kp^k(1-p)^{n-k}$</p>
<p>如果随机变量$\xi_n$取值为0，1，n，且对每一个p，$0&lt; p&lt;1$，有$Prob[\xi_n=k]=C_n^kp^k(1-p)^{n-k}$</p>
<p>那么我们说$\xi _n$服从贝努利分布</p>
<h2 id="生日悖论"><a href="#生日悖论" class="headerlink" title="生日悖论"></a>生日悖论</h2><p>对任意函数$f:X\rarr Y$，其中$Y$为包含n个元素的集合，我们来解决下面的问题：</p>
<p>对于一个概率界限$\epsilon,0&lt;\epsilon&lt;1$，找一个整数$k$，使得对于$k$个两两互异的值$x_1,x_2,…,x_k\in_U X$，$k$个函数值$f(x_1),f(x_2),…,f(x_k)$对某些$i\ne j$有 $Prob[f(x_i)=f(x_j)]\ge \epsilon$</p>
<p>即在$k$个函数值中，以不小于$\epsilon$的概率发生碰撞</p>
<p>上述问题可以表示成：从装有$n$个不同颜色小球的袋子中去一个球，记下该球的颜色，然后放回。找到一个整数$k$，至少出现一次颜色匹配的概率为$\epsilon$。令$y_i$表示第$i$次取出的小球的颜色，第二次取出小球颜色不同的概率为$1-1/n$，以此类推，第$k$个球还未发生碰撞的概率为$(1-\frac{1}{n})(1-\frac{2}{n})…(1-\frac{k-1}{n})$</p>
<p>当n足够大且x相对较小时$1+\frac{x}{n}=e^{\frac{x}{n}}$</p>
<p>因此$(1-\frac{1}{n})(1-\frac{2}{n})…(1-\frac{k-1}{n})=e^{-\frac{k(k-1)}{2n}}$</p>
<p>这是不碰撞的概率，因此碰撞的概率为$1-e^{-\frac{k(k-1)}{2n}}=\epsilon$</p>
<p>我们有$k\approx \sqrt {2n\log \frac{1}{1-\epsilon}}$</p>
<p>考虑$\epsilon=1/2$，则$k=1.1774\sqrt{n}$，它表示对于一个输出空间大小为$n$的随机函数，我们只需计算大约$\sqrt n$个函数值，就能以一个不可忽略的概率发现一个碰撞。</p>
<p>如果说，我们将一组数据作为某个密码函数的原像隐藏，如果该数据的平方根不够大，那么就可以通过随即计算函数值来找出这组数据。这种攻击被称为<strong>生日攻击</strong>。它来源于：$n=365,k\approx22.49$，为了以大于50%的概率从房间中找到有两个人的生日相同，在该房间中只需有23人即可。</p>
<h3 id="生日悖论的应用：指数计算的Pollard袋鼠算法"><a href="#生日悖论的应用：指数计算的Pollard袋鼠算法" class="headerlink" title="生日悖论的应用：指数计算的Pollard袋鼠算法"></a>生日悖论的应用：指数计算的Pollard袋鼠算法</h3><p>$p$为素数，$f(x)=g^x(mod\ p)$是一个随机函数，对于$x=1,2,..,p-1$，函数值$f(x)$在整数区间$[1,p-1]$范围内任意变化，这个函数具有单向性。求逆十分困难。</p>
<p>在某些情况下，我们知道a和b，可以计算$f(a),f(a+1),…$在穷尽b-a步之前找到x。如果b-a太大，那么这种穷搜索方法不现实。但如果$\sqrt{b-a}$是一个容易处理的值，那么生日悖论在$\sqrt{b-a}$步求$f(x)$中起到作用。</p>
<p>Pollard发现了这种方法，他称之为$\lambda$算法或袋鼠算法。</p>
<p>Pollard用两个袋鼠描述他的算法，一只是驯养的袋鼠$T$，另一只是野生的袋鼠$W$，已知$f(x)=g^x(mod\ p)$求解x的问题可以模型化为$T$追捕$W$。这一点是通过让袋鼠沿着跳跃的方式完成的。</p>
<p>$S={s(0),s(1),…,s(J-1)}={2^0,2^1,…,2^{J-1}}$</p>
<p>袋鼠每一次跳跃的距离为$S$中随机的一个数，每只袋鼠都随身携带一个里程表来计算它跳过的总距离。</p>
<p>$T$从已知点$t_0=g^b(mod\ p)$开始跳，$T$是驯服的袋鼠，它的路线为$t(i+1)=t(i)g^{s(t(i)mod\ J)}(mod\ p)$</p>
<p>在跳了n此后，$T$携带的里程表记录着它目前跳过的距离$d(n)=\Sigma_{i=0}^ns(t(i)mod\ J)$</p>
<p>我们将上面的表达式重新表达为$t(n)=g^{b+d(n-1)}mod\ p$</p>
<p>$W$是野生的，它从一个未知的点$w_0=g^xmod\ p$，它的路线为$w(i+1)=w(i)g^{s(w(i)mod\ J)}(mod\ p)$</p>
<p>$W$携带的里程表记录着它目前跳过的距离$D(j)=\Sigma_{k=0}^js(w_kmod\ J)$</p>
<p>我们将上面的表达式重新表达为$w(i)=g^{x+D(i-1)}mod\ p$</p>
<p>显然，它们的足迹$t(i)$和$w(j)$是两个随机函数，根据生日悖论，在$T$和$W$分别大约跳$n\approx\sqrt{b-a}$步内，发生碰撞，也就是跳在了同一个点。如果超过$n\approx\sqrt{b-a}$，那么碰撞发生的概率趋向于1.</p>
<h2 id="信息论"><a href="#信息论" class="headerlink" title="信息论"></a>信息论</h2><p>香农关于消息源的熵(entropy)的定义用来衡量这个源所含信息量的多少。这个量度以源输出的所有可能的消息集上的概率分布函数形式给出。</p>
<p>设$L={a<em>1,a_2,…,a_n}$为由n个不同符号组成的语言，假设信源$S$以独立的概率$Prob[a_1],Prob[a_2],…,Prob[a_n]$分别输出这些符号，并且满足$\Sigma</em>{i=1}^nProb[a_i]=1$</p>
<p>S的熵为$H(S)=\Sigma_{i=1}^nProb[a_i]\log_2(\frac{1}{Prob[a_i]})$，我们称之为“每个信源输出的比特数”</p>
<p>如果$S$以概率1输出某个符号，例如$a_1$，则熵函数$H(S)$有最小值0，这是因为$H(S)=Prob[a_1]\log_2(\frac{1}{Prob[a_1]})=\log_21=0$，这种情况说明，当我们确信信源$S$确定地仅输出$a_1$，我们没必要浪费比特来记录它。</p>
]]></content>
      <categories>
        <category>信息安全数学基础</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数学基础-群</title>
    <url>/posts/f40e8fb8.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="群"><a href="#群" class="headerlink" title="群"></a>群</h1><p>群是一个对象集合，在这个集合中任意两个对象之间定义了一种运算。</p>
<span id="more"></span>
<h2 id="群的基本定义"><a href="#群的基本定义" class="headerlink" title="群的基本定义"></a>群的基本定义</h2><p><strong>定义1</strong>： 群，集合$G$和运算$\circ$一起称为群$(G,\circ)$，运算满足下列条件：</p>
<ol>
<li>$\forall a,b \in G , a \circ b \in G$</li>
<li><p>$\forall a,b,c \in G, a \circ(b \circ c)=(a \circ b)\circ c$</p>
</li>
<li><p>$\exists e \in G, st \forall a \in G,a \circ e =e \circ a =a ,e$被称为单位元</p>
</li>
<li>$\forall a \in G, \exists a^{-1} \in G, st\quad a\circ a^{-1}=a^{-1}\circ a$</li>
</ol>
<p>我们通常省略运算符，用$G$表示一个群</p>
<p><strong>定义2：</strong>有限群和无限群，如果集合$G$中的元素个数是有限的，那么群G就称为<strong>有限群</strong>，否则称为<strong>无限群</strong> </p>
<p><strong>定义3：</strong>阿贝尔群，如果对所有的 $a,b \in G$,均有 $a\circ b = b\circ a$，则称群$G$为阿贝尔群</p>
<p><strong>例1</strong> 群</p>
<ol>
<li>整数集$Z$在加法+下构成群，即$(Z,+)$是一个群，其中 $e=0,a^{-1}=-a$，这是一个加法群，同时还是无限群，阿贝尔群。同理，有理数集$Q$，实数集$R$和复数集$C$都是无限加法群，单位元逆元定义同上。</li>
<li>Q,R,C中的非零元素在乘法下构成群，其中$e=1,a^{-1}$就是乘法逆元。</li>
<li><p>对任意 $n \geq 1$，整数模n集合构成一个包含n个元素的有限加法群，这里的加法指的是模n的假发，单位元是0，对于群中任一元素a，$a^{-1}=n-a$，我们将这个群记为$Z_n$</p>
</li>
<li><p>$Z<em>n$中包含所有与n互素的元素的子集构成一个有限乘法群，这里的乘法指模n乘法，e=1.我们用$Z_n^*$表示这个群，例如$(Z</em>{15}^*,(mod15))=(\lbrace1,2,4,7,8,11,13,14 \rbrace,(mod15))$</p>
</li>
</ol>
<p><strong>定义4：</strong> G是运算$\circ$下的一个群，对任一元素$a\in G$和任一非负整数$i \in N$,我们将下面的元素</p>
<script type="math/tex; mode=display">
a \circ a \circ ...\circ a</script><p>记为 $a^i \in G$</p>
<p><strong>定义5：</strong> 子群 如果群$G$的非空子集$H$在与$G$同样的运算下自身构成一个群，我们就把$H$称为群$G$的一个子群，用 $H\subseteq G$来表示H是G的一个子群，而$H\subset G$则表示H是G的一个真子群。</p>
<p><strong>例2</strong></p>
<ol>
<li><p>在加法运算下，$Z \sube Q  \sube R\sube C$</p>
</li>
<li><p>在加法运算下，所有偶数与0构成的集合是（1）中所有群的一个子群</p>
</li>
<li>集合$e$是任意群的一个子群。</li>
</ol>
<p><strong>定义6：</strong> 群的阶，有限群$G$中元素的个数称为$G$的阶。例如，$Z_n=n$ </p>
<h2 id="拉格朗日定理"><a href="#拉格朗日定理" class="headerlink" title="拉格朗日定理"></a>拉格朗日定理</h2><p><strong>定义7：</strong>  陪集 ，令 $G$ 是一个阿贝尔群，并且 $H \sube G$，对于 $a \in G$， 集合$a \circ H = \lbrace a \circ h|h \in H \rbrace$称为H的一个陪集</p>
<p><strong>定理1：</strong>若H是G的一个子群，则 $#H | #G$</p>
<p><strong>定义8：</strong> 商群，$G$是一个阿贝尔群，且$H\in G$，则所有陪集 $a \circ H$构成的集合，称为 $G$模$H$的商群，其中 $a$ 取自于 $G$，记为 $G/H$，群定义 $(a \circ H) * (b \circ H)= (a\circ b)\circ H$，单位元是 $e \circ H$</p>
<p><strong>例3：</strong> </p>
<ol>
<li>对$Z12$的每一个子群$H$，均有 $# H | #Z_{12}$</li>
<li>n&gt;0是一个整数，在整数加法运算下，集合$nZ= \lbrace 0, \pm n, \pm 2n… \rbrace$显然是Z的一个子群。那么商群</li>
</ol>
<script type="math/tex; mode=display">
Z/nZ = \lbrace x+nZ|x\in Z\rbrace</script><p><strong>定义9：</strong>群元素的阶，G为一群，且 $a\in G$，满足 $a^i = e$的最下正整数 $i \in N$称为元素a的阶，记为 $ord(a)$，如果这样的整数$i$不存在，则a为无限阶元</p>
<p><strong>例4：</strong></p>
<ol>
<li>$Z_{12}$中，ord(1)=12,ord(2)=6,ord(3)=4,ord(4)=3,ord(5)=12</li>
</ol>
<p><strong>定义10：</strong> 循环群，群生成元，如果存在一个元素 $a\in G$ ，对任一 $b\in G$， 都存在一个整数 $i \ge 0$, 使得 $b=a^i$，则群G称为循环群，元素 a称为 G的一个生成元，G是由a生成的群，记作 $G=<a>$</a></p>
<p><strong>例5：</strong></p>
<ol>
<li>对于 $n \ge 1$，加法群 $Z_n$是循环群，1是生成元。</li>
</ol>
<p><strong>定理2：</strong> </p>
<ol>
<li>循环群的每一个子群均为循环群。</li>
<li>对于 $ord<a>$的每一个正因子d，$<a>$ 恰包含一个d阶子群。</a></a></li>
<li>如果 $ord <a> =m$，那么 $ord<a^k>= m/gcd(k,m)$</a^k></a></li>
<li>对 $ord<a>$的每一个正因子d,$<a>$包含 $\phi(d)$个d阶元。</a></a></li>
<li>令 $ord<a>=m$，那么$<a>$包含 $\phi(m)$ 个生成元，这些生成元形如 $a^r$, 其中 $gcd(r,m)=1$</a></a></li>
</ol>
]]></content>
      <categories>
        <category>信息安全数学基础</category>
      </categories>
      <tags>
        <tag>群</tag>
      </tags>
  </entry>
  <entry>
    <title>数据完整性</title>
    <url>/posts/86c8c9d8.html</url>
    <content><![CDATA[<h1 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h1><p>我们需要一种机制，使得到消息的接收者可以验证该消息确实是来自所声称的消息源，且在传输的过程中未受到未授权方式修改。<strong>数据完整性</strong>就是抗击对消息未授权修改的安全服务。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>数据完整性保护</strong> 设Data为任意信息，$Ke$未编码密钥，$Kv$为与该编码密钥相匹配的验证密钥。Data的数据完整性保护如下：检测码的生成：$MDC\larr f(Ke,Data)$</p>
<p>检测码的验证：</p>
<script type="math/tex; mode=display">
G(Kv,Data,MDC)=
\begin {cases}
True,MDC=f(Ke,Data) \\
False ,MDC≠f(Ke,Data)
\end {cases}</script><p>其中f和g都是有效的密码变换：前者由一个辅助输入Ke参数化，后者由任意输入Kv参数化、</p>
<h1 id="对称技术"><a href="#对称技术" class="headerlink" title="对称技术"></a>对称技术</h1><p>在实现数据完整性的对称技术中，密码变换f和g是对称密码算法，这意味着$f=g,Ke=Kv$。</p>
<h2 id="密码杂凑函数"><a href="#密码杂凑函数" class="headerlink" title="密码杂凑函数"></a>密码杂凑函数</h2><p>实现MAC通常的方法时使用密钥<strong>杂凑函数</strong>技术。</p>
<p>杂凑函数是一个确定的函数，它将任意长的比特串映射为定长比特串的杂凑值。设$h$为一个杂凑函数，其固定的输出长度用$\vert h \vert$，它有以下的性质：</p>
<ul>
<li><p>混合变换，对于任意的输入$x$，输出的杂凑值$h(x)$应当和区间$[0,2^{\vert h \vert}]$中均匀的二进制串在计算上是不可区分的。</p>
</li>
<li><p>抗碰撞攻击，输入$x,y,x≠y$，使得$h(x)=h(y)$在计算上应当是不可行的。</p>
</li>
<li>抗原像攻击，已知一个杂凑值$h$，找一个输入串$x$，使得$h=h(x)$，在计算上是不可行的。</li>
<li>实用有效性，给定一个输入串$x$，$h(x)$的计算可以在关于$x$的长度规模的低阶多项式时间内完成。</li>
</ul>
<h3 id="杂凑函数在密码学中的应用"><a href="#杂凑函数在密码学中的应用" class="headerlink" title="杂凑函数在密码学中的应用"></a>杂凑函数在密码学中的应用</h3>]]></content>
  </entry>
  <entry>
    <title>数论基础</title>
    <url>/posts/d1fe2c48.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>格</title>
    <url>/posts/3efe364e.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="格密码学"><a href="#格密码学" class="headerlink" title="格密码学"></a>格密码学</h1><p>Lattice-based cryptography，格密码学，是一种基于格（lattice）的密码学算法，目前是后量子密码学的重要候选方案，与 RSA、Diffie-Hellman 或椭圆曲线密码系统等更广泛使用和众所周知的公钥方案（理论上可以在量子计算机上使用肖尔算法击败这些方案）不同，一些基于格的构造似乎既能抵御经典计算机的攻击，也能抵御量子计算机的攻击。</p>
<span id="more"></span>
<h1 id="关于格"><a href="#关于格" class="headerlink" title="关于格"></a>关于格</h1><p>传统公钥密码学的安全，往往建立在数学问题的困难性上，RSA基于大整数分解的困难性，Elgamal，ECC基于有限域上离散对数求解的困难性，这些难题均可使用量子计算机并应用秀尔算法破解。虽然大型量子计算机尚未普及，但是后量子密码学已经成为人们关注的焦点。格密码学是后量子密码学的代表之一。</p>
<p><strong>格</strong>，是一种类似向量空间的数学空间，实数空间$R$上的向量空间$V$,是一些向量的集合，任意两个向量可以相加，任意一个向量可以和一个实数相乘，运算具有封闭性。在lattice中，与向量空间有所区别，具体来说，就是乘法中的乘数，从实数改为整数。如下图，是几种不同的格空间。</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307251105947.png" alt="image-20230725110500839"></p>
<p>数学表示，给定$n$维实数空间$R^n$中的一组线性无关向量$B={b<em>1,…,b_n}\subset R^n$，其整数系数线性组合构成的集合被称为<strong>格（Lattice）</strong>，即$L=\Sigma</em>{i=1}^nb_i \cdot Z={Bx,x\in Z^n}$其中$B={b_1,…,b_n}$被称为格基。同一个格可能有不同的格基。</p>
<p><strong>某种程度上，格可以理解成系数为整数的向量空间。</strong></p>
<p><strong>与格相关的基本计算性难题：</strong><br>1.SVP: Shortest Vector Problem （在格中寻找最短的非零向量）<br><strong>最短向量问题(SVP)</strong>:在格$L$中寻找一个最短的非零向量，即寻找一个非零向量$v\in L$,使它的欧几里得范数$\vert \vert v\vert \vert$最小。</p>
<p>2.CVP: Closet Vector Problem（在格中寻找与指定非格向量最为接近的向量）<br><strong>最近向量问题(CVP)</strong>:给定一个不在格$L$中的向量$\omega \in R^m$ ，寻找一个向量$v \in L$，使它最接近$\omega$，即寻找一个向量$v\in L$，使欧几里得范数$\vert \vert \omega - v\vert\vert$最小。</p>
]]></content>
      <categories>
        <category>同态加密</category>
      </categories>
      <tags>
        <tag>格密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>横向联邦学习</title>
    <url>/posts/86cff816.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>比特安全性</title>
    <url>/posts/cc63f144.html</url>
    <content><![CDATA[<h1 id="比特安全性"><a href="#比特安全性" class="headerlink" title="比特安全性"></a>比特安全性</h1><p>关于基本的和通用的公钥密码函数比特安全性的实际结果意味着，只要明文消息是随机的，那么恢复有关明文的任何消息的问题就同这些基本函数求逆一样困难，这是因为后者是恢复整个明文消息的问题。</p>
<h1 id="RSA比特"><a href="#RSA比特" class="headerlink" title="RSA比特"></a>RSA比特</h1><p>如果一条RSA密文是对不包含事前可猜测的信息进行的加密，那么从密文中提取一比特的明文信息就同提取整个明文组一样困难。</p>
]]></content>
  </entry>
  <entry>
    <title>环和域</title>
    <url>/posts/3c8c316a.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="环和域"><a href="#环和域" class="headerlink" title="环和域"></a>环和域</h1><p><strong>定义1：</strong> 环（Ring）</p>
<span id="more"></span>
<p>一个同时有两种运算：加法和乘法的集合，如果满足如下性质，就称为环R：</p>
<ol>
<li>R在加法+下是一个阿贝尔群，加法单位元记作0（称为零元）</li>
<li>R在乘法 $\cdot$ 下满足封闭律，结合律和单位元律，乘法单位元记作1</li>
<li>$\forall a, b \in R, a \cdot b =b \cdot a$</li>
<li>$\forall a,b,c \in R, a \cdot (b+c) = a \cdot b +a \cdot c$</li>
</ol>
<p>如果乘法还满足交换律，则是一个交换环。</p>
<p><strong>例1：</strong></p>
<ol>
<li>在通常的加法和乘法运算下， Z,Q,R和C均是环</li>
<li>对 n&gt;0， 在模n加法和模n乘法运算下，$Z_n$是一个环</li>
</ol>
<p><strong>定义2：</strong> 域（Field）</p>
<p>如果一个环中的非零元在乘法运算下构成群，则该环就称为域。</p>
<p>域中乘法群（即非零元）满足封闭律，这表明域$F$不含零因子，即对任意的$a,b\in F,ab=0$可推出a=0或b=0</p>
<p><strong>例2：</strong></p>
<ol>
<li>在通常的加法和乘法运算下，QRC均是域。</li>
</ol>
<p><strong>定义3：</strong> 一个代数结构如果包含有限个元素，就说该代数结构是有限的，元素的个数称为这个结构的阶。</p>
<p>如果一个代数结构A的一个非空子集S在A的运算下自身成为一个代数结构，那么S就称为代数结构A的子结构。</p>
<h1 id="有限域的结构"><a href="#有限域的结构" class="headerlink" title="有限域的结构"></a>有限域的结构</h1><p>有限域在密码学和密码协议中有着广泛的应用。现在我们对有限域的结构进行一下完整的讨论。</p>
<h2 id="含有素数个元素的有限域"><a href="#含有素数个元素的有限域" class="headerlink" title="含有素数个元素的有限域"></a>含有素数个元素的有限域</h2><p>最简单结构的有限域就是阶为素数的有限域，然而这样的域在密码学中的应用却最广泛。</p>
<p>素域：不含真子域的域称为素域</p>
<p>例如，Q为素域，由于Q为R的真子域，所以R不是素域，Q是一个无限域。</p>
<p>同态和同构：</p>
]]></content>
      <categories>
        <category>信息安全数学基础</category>
      </categories>
      <tags>
        <tag>环和域</tag>
      </tags>
  </entry>
  <entry>
    <title>盲签名</title>
    <url>/posts/4e6420da.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="盲签名"><a href="#盲签名" class="headerlink" title="盲签名"></a>盲签名</h1><p>随着互联网的普及，为在线支付营造了丰沃的土壤，支付宝、微信支付与各大银行App纷纷登上在线支付的头把交椅。有的人甚至说“<strong>只需要一部手机就可以走遍天</strong>下”。但是，在线支付虽然便捷且交易的是一串数字但并不是电子现金，在线支付并不具备匿名性，容易追踪到某笔交易金额的来源和购买的商品，而电子现金具备匿名性，无法追踪电子现金来源。其中技术用到了假名、零知识证明、环签名、盲签名等等。</p>
<span id="more"></span>
<h1 id="电子现金"><a href="#电子现金" class="headerlink" title="电子现金"></a>电子现金</h1><p>电子现金(Electronic Cash)其实是一种用电子形式模拟现金的技术。电子现金系统企图在多方面为在线交易复制现金的特性：方便、费用低（或者没有交易费用）。不记名以及其他性质。但不是所有的电子现金系统都满足这些特点，多数电子现金系统都能为小额在线交易提供快捷与方便。</p>
<p>电子现金优于真实现金之处在于它安全、超距、迅速、低成本、匿名性、精确性等，这大大强化了现金的可移动性。电子现金通过信息网络系统和公共信息平台实现流通、存取、支付。在电子现金的支付中有三方参与：<strong>银行、用户、商家</strong>。</p>
<p>电子现金在线交易一般需要以下三个基本阶段：</p>
<p><strong>取款阶段：</strong>用户从自己的银行账户上提取数字现金</p>
<p><strong>支付阶段：</strong>用户使用数字现金从商店中购买商品</p>
<p><strong>存款阶段：</strong>用户及商家将数字现金存入到自己的银行账户上</p>
<p>在电子现金支付和使用的过程中，为了保护用户购买商品、服务时的隐私，接收方不应获得支付方的任何身份信息。</p>
<p>盲签名可以实现银行向合法用户发放有效的电子现金，使用户可以使用有效的电子现金进行交易，银行本身也无法通过电子现金追踪到该电子现金是属于哪个用户的。</p>
<h1 id="盲签名的概念"><a href="#盲签名的概念" class="headerlink" title="盲签名的概念"></a>盲签名的概念</h1><p>盲签名的概念首先由 David Chaum 于1982年提出，盲签名实现了签名者对发送者的消息进行签名，却不能知道签名者消息的具体内容。</p>
<p>相当于将文件放入信封，签名者在信封上对文件进行签名，而不知道具体的文件内容。</p>
<p><strong>性质</strong></p>
<ol>
<li>不可伪造性，除了签名者本人外，任何人不能以他的名义生成有效的盲签名</li>
<li>不可抵赖性，签名者一旦签署了某个消息，他无法否认自己对消息的签名</li>
<li>盲性，签名者虽然对某个消息进行了签名，但他不可能得到消息的具体内容。</li>
<li>不可跟踪性，一旦消息的签名公开后，签名者不能确定自己何时签署的这条消息。</li>
</ol>
<p><strong>模型</strong></p>
<ol>
<li>接收者首先将待签数据进行盲变换，把变换后的盲数据发给签名者。</li>
<li>经签名者签名后再发给接收者。</li>
<li>接收者对签名再作去盲变换，得出的便是签名者对原数据的盲签名。</li>
</ol>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307261915303.jpeg" alt="img"></p>
<h1 id="基于RSA的盲签名"><a href="#基于RSA的盲签名" class="headerlink" title="基于RSA的盲签名"></a>基于RSA的盲签名</h1><p>假设A是接收者，B是签名者，私钥$d$，公开RSA公钥$(n,e)$，A让B盲签名消息$m$</p>
<ol>
<li><p>选取盲引子$r$，计算$m^{\prime}=m*r^e\ mod\ n$</p>
</li>
<li><p>B对$m^{\prime}$进行签名$m^{\prime d}=(m*r^e)^d\ mod\ n$</p>
</li>
<li><p>A去盲得到原始签名 $s=m^{\prime d} <em> r^{-1}=(m</em>r^e)^d<em>r^{-1}\ mod\ n=m^d</em>r^{ed}*r^{-1}\ mod\ n=m^d\ mod\ n$</p>
</li>
</ol>
<p>正确性容易证明</p>
<p>java测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 盲签名相关</span></span><br><span class="line"><span class="comment"> * Created by forest on 2017/5/23.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">blindSignature</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这里是盲签名测试&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;32663&quot;</span>);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;23&quot;</span>);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;42167&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;123&quot;</span>);       <span class="comment">//签名的消息</span></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">factor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;37&quot;</span>);   <span class="comment">//盲因子</span></span><br><span class="line"></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">blindMsg</span> <span class="operator">=</span> blindHideMsg(m, factor, e, n);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">blindSig</span> <span class="operator">=</span> blindSignature(blindMsg, d, n);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">sig</span> <span class="operator">=</span> blindRetriveSig(blindSig, factor, n);</span><br><span class="line">        System.out.println(<span class="string">&quot;盲签名 = &quot;</span> + sig);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">realSig</span> <span class="operator">=</span> m.modPow(d, n);</span><br><span class="line">        System.out.println(<span class="string">&quot;原签名 = &quot;</span> + realSig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**盲签名-盲化*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title function_">blindHideMsg</span><span class="params">(BigInteger msg, BigInteger factor, BigInteger e, BigInteger n)</span>&#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">hideMsg</span> <span class="operator">=</span> msg.multiply(factor.modPow(e, n)).mod(n);</span><br><span class="line">        <span class="keyword">return</span> hideMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**盲签名-签名*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title function_">blindSignature</span><span class="params">(BigInteger blindMsg, BigInteger d, BigInteger n)</span>&#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">blindSig</span> <span class="operator">=</span> blindMsg.modPow(d, n);</span><br><span class="line">        <span class="keyword">return</span> blindSig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**盲签名-解盲得到签名*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title function_">blindRetriveSig</span><span class="params">(BigInteger blindSig, BigInteger factor, BigInteger n)</span>&#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">signature</span> <span class="operator">=</span> blindSig.multiply(factor.modInverse(n)).mod(n);</span><br><span class="line">        <span class="keyword">return</span> signature;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="盲签名在区块链中的应用"><a href="#盲签名在区块链中的应用" class="headerlink" title="盲签名在区块链中的应用"></a>盲签名在区块链中的应用</h1><p>区块链系统中地址是由用户自行生成，与用户的身份信息无关，用户创建和使用地址不需要第三方参与。因此，区块链地址具有较好的匿名性。</p>
<p>但是区块链交易之间的关联性可以被用于推测敏感信息。区块链所有数据都存储在公开的全局账本中，通过分析这些交易之间的关联关系(比如：同一交易的所有输入地址属于同一用户集合、找零地址和输入地址属于同一用户等等)，再结合一些背景知识，能够逐步降低区块链地址的匿名性，甚至发现匿名地址对应用户的真实身份。</p>
<p>因此，在区块链网络中，为了保护隐私信息，出现了一些隐私保护机制，其中<strong>Blindcoin协议</strong>是其中一种中心化混币技术，是一个<strong>基于盲签名技术的隐藏机制。</strong></p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307261932708.png" alt="image-20230726193222630"></p>
<p>如上图所示，<strong>Blindcoin协议</strong>是在<strong>Mixcoin 协议</strong>基础上，通过盲签名技术，使得混币用户的输入输出地址映射关系对混币服务商M不可见。</p>
]]></content>
      <categories>
        <category>密码学基础</category>
      </categories>
      <tags>
        <tag>盲签名</tag>
      </tags>
  </entry>
  <entry>
    <title>联邦学习的安全机制</title>
    <url>/posts/c9b3f285.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>本章将介绍联邦学习系统里常用的隐私保护技术。</p>
<span id="more"></span>
<h1 id="基于同态加密的安全机制"><a href="#基于同态加密的安全机制" class="headerlink" title="基于同态加密的安全机制"></a>基于同态加密的安全机制</h1>]]></content>
      <categories>
        <category>联邦学习</category>
      </categories>
      <tags>
        <tag>联邦学习</tag>
      </tags>
  </entry>
  <entry>
    <title>联邦学习综述</title>
    <url>/posts/5262bc4b.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>本文将介绍当前人工智能面临的挑战以及联邦学习可以作为一个有效的解决方案，并介绍联邦学习的分类和发展。</p>
<span id="more"></span>
<h1 id="人工智能面临的挑战"><a href="#人工智能面临的挑战" class="headerlink" title="人工智能面临的挑战"></a>人工智能面临的挑战</h1><p>在过去的十年，我们见证了机器学习（Machine Learning，ML）在人工智能（Artificial Intelligence，AI）应用领域中的迅猛发展，如计算机视觉，自然语言处理，推荐系统。近些年的产品，如AlphaGo，ChatGpt已经深深地影响着人类的生活。这些技术的成功，尤其是深度学习，都是建立在大量的数据基础上的。通过使用这些数据，深度学习系统能够在许多领域执行人类难以完成的任务。</p>
<p>随着社会的不断发展，人们逐渐意识到主权的重要性，也会刻意选择去保护自己的隐私，这带来这样的意识问题：<strong>什么人或者组织能够拥有和使用数据建立人工智能技术应用的权力</strong>。在一般的产品服务中，商家都会要求获取产品数据和购买者记录的使用权，这种请求是不明确的。最近更是有许多互联网企业由于泄露用户数据而被重罚，垃圾邮件制作者和不法的数据交易也常常被曝光和处罚。例如<a href="https://www.secrss.com/articles/49493">Meta数据泄露</a>，<a href="https://ici.radio-canada.ca/rci/zh-hans/%E6%96%B0%E9%97%BB/1968323/%E6%8B%BC%E5%A4%9A%E5%A4%9A%E8%A2%AB%E6%8C%87%E7%94%A8%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF-cnn%E8%B0%83%E6%9F%A5">拼多多用户数据非法收集</a>。</p>
<p>在法律层面，法规制定者和监管机构正在考虑出台新的法律法规来规范数据的管理和使用。经典的例子是2018年欧盟开始执行的<a href="https://zh.wikipedia.org/zh-cn/%E6%AD%90%E7%9B%9F%E4%B8%80%E8%88%AC%E8%B3%87%E6%96%99%E4%BF%9D%E8%AD%B7%E8%A6%8F%E7%AF%84">GDPR</a>，此外，中国的《中华人民共和国民法通则》和《中华人民共和国网络安全法》同样对数据的收集和处理提出了严格的要求。</p>
<p>在这样的环境下，我们在不同组织之间收集和分享数据会变得越来越困难。某些高度敏感的数据（如医疗数据）的拥有者会极力反对无限制地计算和使用这些数据。在这种情况下，数据只保存在个人手中，往往会出现数据孤岛的现象。行业竞争，用户隐私，数据安全，复杂的管理规程，都会对数据的使用带来困难。</p>
<p><strong>如何在遵守更加严格的，新的隐私保护条例的前提下，解决数据碎片化和数据隔离的问题</strong>，是当前人工智能研究者和实践者面临的首要挑战。倘若不能及解决，将会导致新一轮的人工智能的寒冬。</p>
<p>人工智能产业面临的另一个挑战：各方协同分享处理大数据的的益处并不明显。人们对数据失去掌控的担忧，以及对于增益分配效果的不透明，加剧了所谓数据碎片化和孤岛分布的严重性。</p>
<p>随着物联网和边缘计算的兴起，大数据往往不会拘泥于单一的整体，而是分布在许多方面。对于自动驾驶汽车，每辆汽车必须能够在本地使用机器学习模型处理大量信息，同时需要与全球汽车协同工作。<strong>如何安全且有效地实现模型在多个地点间的更新和共享，是当前各类计算方法所面临的挑战</strong>。</p>
<h1 id="联邦学习概述"><a href="#联邦学习概述" class="headerlink" title="联邦学习概述"></a>联邦学习概述</h1><p>由于数据孤岛的出现，正阻碍着训练人工智能模型所必需的大数据的使用，所以人们开始寻求：不必将所有数据集中到一个中心存储点就能够训练机器学习模型。</p>
<p>一种可行的方法是由每一个拥有数据源的组织训练一个模型，之后让各个组织在各自的模型上彼此交流沟通，最终通过模型聚合得到一个全局模型。为了确保用户隐私和数据安全，各组织间交换模型信息的过程将会被精心地设计，使得没有组织能够猜测到其他任何组织的隐私数据内容。这便是联邦机器学习（Fedrated machine learning）或者联邦学习（Fedrated learning）的思想。</p>
<p>谷歌的H.B M等人通过使用边缘服务器架构，将联邦学习用于智能手机上的语言预测模型更新，<a href="https://proceedings.mlr.press/v54/mcmahan17a?ref=https://githubhelp.com">Communication-Efficient Learning of Deep Networks from Decentralized Data</a>，<a href="https://arxiv.org/pdf/1602.05629v1.pdf">Federated learning of deep networks using model averaging</a>。通过联邦学习，每台移动设备上的模型将会被加密并上传到云端。最终，所有的加密模型都会被聚合到一个加密的全局模型中。</p>
<p>谷歌的联邦学习很好地展示了企业对消费者（Business to Customer，B2C）的一个应用案例，除此之外，还应该支持企业对企业（Business to Business，B2B）的应用。</p>
<h2 id="联邦学习的定义"><a href="#联邦学习的定义" class="headerlink" title="联邦学习的定义"></a>联邦学习的定义</h2><p>联邦学习旨在建立一个基于分布数据集的联邦学习模型。联邦学习包括两个过程，分别是<strong>模型训练</strong>和<strong>模型推理</strong>。在模型训练的过程中，模型相关的信息能够在各方之间交换（或者是以加密形式交换），但数据不能。这一交换不会暴露每个站点上数据的任何受保护的隐私部分。当推理时，模型可以应用于新的数据实例。</p>
<p>联邦学习是一种具有以下特征的用来建立机器学习模型的算法框架。其中，机器学习模型是指将某一方的数据实例映射到预测结果输出的函数。</p>
<ul>
<li>有两个或以上的联邦学习参与方协作构建一个共享的机器学习模型。每一个参与方都拥有若干能够用来训练模型的训练数据。</li>
<li>在联邦学习模型的训练过程中，每一个参与方拥有的数据都不会离开该参与方。</li>
<li>联邦学习模型相关的信息能够以加密方式在各方之间进行传输和交换，并且需要保证任何一个参与方都不能推测出其他方的原始数据。</li>
<li>联邦学习模型的性能要能够充分逼近理想模型的性能。</li>
</ul>
<p>设有$N$位参与方${F<em>i}</em>{i=1}^N$协作通过使用各自的训练数据集${D<em>i}</em>{i=1}^N$来训练机器学习模型。传统的方法是将所有的数据${D<em>i}</em>{i=1}^N$收集起来并存储在一个地方训练得到一个机器学习模型$M<em>{SUM}$，这样会导致任何一方$F_i$的训练数据会直接暴露出来$D_i$。联邦学习是一种不需要收集各参与方所有的数据${D_i}</em>{i=1}^N$便能协作的训练一个模型$M<em>{FED}$的机器学习过程。设$v</em>{SUM}$和$v<em>{FED}$分别为集中型模型$M</em>{SUM}$和联邦型模型$M{FED}$的性能量度，设$\delta$为一个非负实数，在满足以下条件时，联邦学习模型$M_{FED}$具有$\delta$的性能损失。</p>
<script type="math/tex; mode=display">
v_{SUM}-v_{FED}<\delta</script><p>该公式说明了：如果使用安全的联邦学习在分布式数据源上构建机器学习模型，这个模型在未来数据上的性能近似于把所有数据集中到一个地方训练所得到的模型的性能。但实际上，我们允许联邦学习模型在性能上比集中训练的模型稍差。</p>
<p>根据应用场景的不同，联邦学习系统可能设计也可能不涉及中央协调方。</p>
<p>图一展示了一种包括协调方的联邦学习架构示例。</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202308061536270.png" alt="img"></p>
<center>图一：联邦学习系统示例：客户端-服务器架构</center>

<p>在此场景中，协调方是一台聚合服务器，可以将初始模型发送给各参与方A~C。参与方分别使用各自的数据集训练该模型，并将模型权重更新发送到聚合服务器。之后，聚合服务器将从参与方处接收到的模型更新聚合起来，并将聚合后的模型更新发回给参与方。这一过程会反复进行，直至模型收敛。这种方法不仅保护了用户的隐私和数据安全，还减少了发送原始数据所带来的通信开销。</p>
<p>联邦学习架构也能被设计为对等（P2P）网络的方式，不需要协调方。这进一步确保了安全，因为各方无需借助第三方便可以直接通信，如图二所示。</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202308061547018.png" alt="img"></p>
<center>图二：联邦学习系统示例：对等架构</center>

<p>这种体系结构的优点时=是提高了安全性，但可能需要更多的计算操作来对消息内容进行加密和解密。</p>
<h2 id="联邦学习的分类"><a href="#联邦学习的分类" class="headerlink" title="联邦学习的分类"></a>联邦学习的分类</h2><p>设矩阵$D_i$表示第$i$个参与方的数据，设矩阵$D_i$的每一行表示一个数据样本，每一列表示一个具体的数据特征（figure）。</p>
<p>我们将特征空间设为$\chi$，数据标签（label）空间设为$y$，并用$I$表示数据样本ID空间，例如：在教育领域，数据标签可以是学生的成绩分数。三者组成了一个训练数据集$(I,\chi,y)$。不同的参与方拥有的数据的特征空间和样本$ID$空间是不同的。根据分布情况的不同，我们将联邦学习划分为<strong>横向联邦学习</strong>（Horizontal Fedrated Learning，HFL），<strong>纵向联邦学习（Vertica</strong>l Fedrated Learning，VFL）和<strong>联邦迁移学习</strong>（Fedrated Transfer Learning，VFL）</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202308061837905.png" alt="image-20230806183730725"></p>
<center>图三：联邦学习划分</center>

<p>横向联邦学习适用于联邦学习的参与方的数据有重叠的数据特征，即数据特征在参与方之间是对齐的，但是参与方拥有的数据样本是不同的。它类似于在表格视图中将数据水平划分的情况。因此，我们将横向联邦学习称为按样本划分的联邦学习（Sample-Partitioned Fedrated learning）。</p>
<p>与横向联邦学习不同，纵向联邦学习适用于联邦学习参与方的训练数据有重叠的数据样本，即参与方之间的数据样本是对齐的，但是在数据特征上有所不同。它类似于数据在表格视图中将数据垂直划分的情况。因此，我们将纵向联邦学习称为按特征划分的联邦学习（Feature-Partitioned Fedrated learning）。</p>
<p>联邦迁移学习适用于参与方的数据样本和数据特征重叠都很少的情况。</p>
<p>例如，当两家位于不同地区的银行，他们重叠的用户可能很少，但是由于具有相似的<strong>商业模式</strong>都具有相同的特征，这意味着，两家银行的数据特征重叠部分较大，那么就可以通过横向联邦学习建立一个机器学习模型。</p>
<p>当两家公司（如银行和电子商务公司）提供不同的服务，但在客户群体上有非常大的交集时，它们可以在各自的不同特征空间上协作，为各自的到一个更好的机器学习模型。用户重叠部分较大，数据特征的重叠部分较小，则这两家公司可以协作地通过纵向联邦学习方式训练机器学习模型。</p>
<h1 id="联邦学习的发展"><a href="#联邦学习的发展" class="headerlink" title="联邦学习的发展"></a>联邦学习的发展</h1><p>在计算机科学和机器学习的发展史中，联邦学习的概念曾多次以不同的形式出现过，如：面向隐私保护的机器学习，协作式机器学习，联邦优化和面向隐私保护的数据分析。</p>
]]></content>
      <categories>
        <category>联邦学习</category>
      </categories>
      <tags>
        <tag>联邦学习</tag>
      </tags>
  </entry>
  <entry>
    <title>计算复杂度</title>
    <url>/posts/74967696.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>本文介绍图灵机，确定性多项式时间类和非确定性多项式时间问题。</p>
<span id="more"></span>
<h1 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h1><p>为了精确定义有效程序(即算法)这一概念，图灵构思了一种称为图灵机(Turing machine)的计算设备，把它作为一个计算原型，但却是非常通用的计算模型。这里要介绍的计算复杂性材料沿用了图灵机计算模型。下面介绍图灵机的个变型，这对我们学习计算复杂性的目的来说已经足够了。</p>
<p>在我们的变型里，图灵机由有限状态控制单元、k(≥1)条纸带( tape)以及同样数量的读写头( tapehead)组成。有限控制单元控制磁头读写纸带的操作，每个读写头访问一条纸带(称为它的纸带)，沿着纸带或左或右地移动完成这一操作。每一条纸带分成无限个单元(cell)。图灵机求解一个问题时,读写头扫描一个有有限个字符的串。该串从纸带最左边的单元开始按顺序存放在纸带上，每个字符占用一个单元,右边剩下的是空白(blank)单元，该串称为问题的一个输入。扫描从含有输入的纸带左端开始，同时图灵机赋一个初态( initial state）。任何时刻图灵机都只有一个读写头访问它的纸带。读写头对它的纸带的一次访问称为一个合法移动。</p>
<p>如果图灵机从初始状态开始，一步接一步地合法移动，完成对输入串的扫描，最终满足了终止条件而停下来，则称图灵机识别了该输入。图灵机识别的一个输入被称为一种可识别语言（language）的一个实例。</p>
<p>对给定的问题，图灵机可以由它的有限控制单元的功能完全描述。这样的功能可以用一张表的形式给出，列出图灵机每个状态的下一步。</p>
<p>为识别一个输入，图灵机$M$在停下来之前所移动的步数称为$M$的运行时间或$M$的时间复杂性，记为$T_M$。$T_M$可以表示为函数$T_M(N):N\rarr N$，其中n是输入实例的长度或规模。当$M$在初始状态时，它就是组成输入串的字符数，$T_M(n)\ge n$。除了对时间的要求外，$M$还有对空间的要求$S_M$，它是$M$在写操作中读写头访问的纸带单元数。$S_M$可表示为函数$S_M(n):N\rarr N$，称为$M$的空间复杂性。</p>
<p>下面我们介绍一个具体的图灵机。</p>
<h1 id="确定性多项式时间"><a href="#确定性多项式时间" class="headerlink" title="确定性多项式时间"></a>确定性多项式时间</h1><p>$p(n)$是整数上关于$n$的一个多项式，它有下列形式：</p>
<script type="math/tex; mode=display">
p(n)=c_kn^k+c_{k-1}n^{k-1}+...+c_1n+c_0</script><p>其中$k,c_i$是常整数且$c_k\ne 0$，当$k&gt;0$是，前者称为多项式$p(n)$的次数，记为$deg(p(n))$，后者称为多项式$p(n)$的系数。</p>
<p><strong>P类</strong>，我们记$P$表示具有下列特征的语言类。语言$L$在$P$中，如果存在一个图灵机$M$和一个多项式$p(n)$使得对任意非负整数n，M可以在时间$T_M(n)\le p(n)$内识别任意实例$I\in L$，其中n是表示实例$I$规模的整数参数。我们称L是可以在多项式时间内识别的。</p>
<p>粗略地说，可以在多项式时间内识别的语言总是很容易的。</p>
]]></content>
      <categories>
        <category>信息安全数学基础</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>认证协议</title>
    <url>/posts/f6c879e6.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="认证协议"><a href="#认证协议" class="headerlink" title="认证协议"></a>认证协议</h1><p>认证这一概念可以分为三个子概念，数据源认证（验证消息的某个声称属性），实体认证（验证消息发送者所声称的身份），认证的密钥建立（产生一条安全信道，用于后继的应用层安全通话）</p>
<span id="more"></span>
<h2 id="数据源认证"><a href="#数据源认证" class="headerlink" title="数据源认证"></a>数据源认证</h2><p>数据源认证涉及通信，是一种安全服务，消息接收者用它来验证消息是否来源于所声称的消息源，数据完整性不一定包含通信过程。其次，数据源认证必然涉及消息源的识别，数据完整性不一定涉及。数据源认证必然涉及确认消息的新鲜性。</p>
<p>我们可以将数据源认证这一概念的特征总结如下：</p>
<ul>
<li><p>包含从某个声称的源(发送者)到接收者的消息传输过程,该接收者在接收时会验证消息。</p>
</li>
<li><p>接收方执行消息验证的目的在于确认消息发送者的身份。</p>
</li>
<li><p>接收方执行消息验证的目的还在于确认在原消息离开消息发送者之后的数据完整性。</p>
</li>
<li><p>验证的进一步目的在于确认消息传输的“活现性”。</p>
</li>
</ul>
<h2 id="实体认证"><a href="#实体认证" class="headerlink" title="实体认证"></a>实体认证</h2><p>实体认证是一个通信过程，通过这个过程某个实体和另一个实体建立一种真实通信，并且第二主体声称的身份应该和第一主体所寻求的通信方一致。</p>
<p>根据协议主体的不同归类方法，在分布式系统中，实体认证可以分为若干类型，包括如下：主机-主机类型，用户-主机类型，进程-主机类型，成员-俱乐部类型</p>
<h2 id="认证的密钥建立"><a href="#认证的密钥建立" class="headerlink" title="认证的密钥建立"></a>认证的密钥建立</h2><p>在现代密码学中，密钥是安全通信信道的基础，因此，为了进行高层或应用层安全通信而运行的实体认证协议通常都有一个子任务，即密钥建立、</p>
<h2 id="基本认证技术"><a href="#基本认证技术" class="headerlink" title="基本认证技术"></a>基本认证技术</h2><h3 id="消息新鲜性和主体活现性"><a href="#消息新鲜性和主体活现性" class="headerlink" title="消息新鲜性和主体活现性"></a>消息新鲜性和主体活现性</h3><p>判断某条消息是否新鲜是数据源认证必不可少的一部分。</p>
<h4 id="询问-应答机制"><a href="#询问-应答机制" class="headerlink" title="询问-应答机制"></a>询问-应答机制</h4><p>在<strong>询问-应答</strong>机制中，B在协议消息的组合中拥有他的输入信息，并且该合成消息涉及了A所进行的密码操作，于是B能够通过他自己输入的消息的新鲜性来验证A通信的真实性。假设$N_B$代表B生成的一次性随机数，这种机制通常有以下交互方式：</p>
<ol>
<li><p>$Bob \rarr Alice:N_B$</p>
</li>
<li><p>$Alice \rarr Bob: \varepsilon_{KAB}(M,N_B)$</p>
</li>
<li><p>B接收到密文分组并接受/拒绝</p>
</li>
</ol>
<p>发送的第一条消息通常为B对A的<strong>询问</strong>，第二条消息为A对B的<strong>应答</strong></p>
<p>以上给出的机制使用了对称加密技术。</p>
]]></content>
      <categories>
        <category>密码学基础</category>
      </categories>
      <tags>
        <tag>认证协议</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读_FedIPR</title>
    <url>/posts/f9a8f369.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>今天的论文题目是《FedIPR: Ownership Verification for Federated Deep Neural Network Models》</p>
<p>论文地址：<a href="https://arxiv.org/abs/2109.13236">https://arxiv.org/abs/2109.13236</a></p>
<span id="more"></span>
<h1 id="FedIPR-Ownership-Verification-for-Federated-Deep-Neural-Network-Models"><a href="#FedIPR-Ownership-Verification-for-Federated-Deep-Neural-Network-Models" class="headerlink" title="FedIPR: Ownership Verification for Federated Deep Neural Network Models"></a>FedIPR: Ownership Verification for Federated Deep Neural Network Models</h1><p>FedIPR： 联合深层神经网络模型的所有权验证</p>
<p>为了解决联合学习模型开发和部署过程中，面临的非法复制，再分配，滥用等风险，本文提出一种联合深度神经网络（FedDNN）所有权验证方案，允许嵌入和验证私人水印，以保证联合学习模型知识产权（IPR）。本文所做的主要工作<strong>在不透露其私人水印的情况下证明训练模型的所有权</strong>。</p>
<p>考虑到水印和联合学习中的威胁模型，本文提出了名为FedIPR的统一框架，它由两个独立的过程组成：1）水印嵌入过程，允许多方嵌入它们基于特征和后门的秘密水印。2）验证过程，允许每一方独立验证模型的所有权。</p>
<p><strong>技术挑战</strong></p>
<p>挑战A：如何确保不同的客户嵌入到同一个FedDNN模型中的私人水印不会相互诋毁？</p>
<p>挑战B：如何确保嵌入式水印对保护隐私的学习策略具有鲁棒性？</p>
<p><strong>安全水平联合学习</strong></p>
<p>一个安全的水平联合学习系统由$K$个客户组成，它们用自己的数据建立自己的模型然后把本地模型${W<em>k}</em>{k=1}^K$发送到一个聚合器以获得一个全局模型，如下：</p>
<script type="math/tex; mode=display">
W\leftarrow\sum_{k=1}^K \frac{n_k}{K}W_k</script><p>其中$n_k$是每个客户的本地模型Wk的权重。</p>
<p><strong>自由人</strong></p>
<p><em>freeider</em>自由人，表示不贡献数据或计算资源，只为免费获得全局模型。自由人创建模型：</p>
<script type="math/tex; mode=display">
W^{free}=Free(W^t,W^{t-1})</script><p>带高斯噪声的自由人</p>
<script type="math/tex; mode=display">
W^{free}=W^t+\xi_t \quad,\quad \xi_t\backsim N(0,\sigma_t)</script><p><strong>DNN水印</strong></p>
<p>DNN水印有两类</p>
<p>基于后门的水印：基于后门的水印$T={(X_T^1,Y_T^1),…(X_T^{N_T},Y_T^{N_T})}$是在训练期间通过加入后门样本的损失函数嵌入到模型函数N中</p>
<p>基于特征的水印：在水印嵌入步骤中，在模型参数W的学习过程中，通过在原始学习任务中加入正则化项，嵌入N比特目标二进制水印$B \in \lbrace{0,1}\rbrace^N$。</p>
<p><strong>FedIPR水印</strong></p>
<p>一个给定的联邦深度神经网络（FedDNN）模型所有权验证方案（FedIPR）被定义为元组 $V=(g,\xi,A,V_W,V_B)$，由以下构成</p>
<p>1）对于每个客户端$K \in \lbrace1,…k \rbrace$，密钥生成过程$G()\rightarrow (B<em>k,\theta_k,T_k)$生成水印$B_k$，水印提取参数$\theta_k=\lbrace S_k,E_k\rbrace$，触发器$T_k=\lbrace (X</em>{T<em>k}^1,Y</em>{T<em>k}^1),…(X</em>{T<em>k}^{N_T},Y</em>{T_k}^{N_T})\rbrace$，注意：以上参数均应得到保密，其中$S_k$表示水印$B_k$的位置，$E_k$表示水印$B_k$的秘密嵌入矩阵。</p>
<p>2）嵌入过程：$L<em>k:=L</em>{D<em>k}(W^t)+\alpha_kL</em>{T<em>k}(W^t)+\beta_kL</em>{B_k,\theta_k(W^t)}$</p>
<p>3）聚合过程：使用 <em>FedAvg algorithm</em>： $W^{t+1}\larr \Sigma_{k=1}^K \frac{n_k}{n}W^{t+1}_k$，其中，$W^{t+1}_k \larr ClentUpdate(L_k,W^t)$是客户端k在第t轮的本地模型。$\frac{n_k}{n}$ 表示聚合权重</p>
<p>4）黑盒验证过程，检查由触发器样本$X<em>{T_k}$产生的指定标签$Y</em>{T_k}$的检测误差是否小于 $\epsilon_B$</p>
<script type="math/tex; mode=display">
V_b(N,T_k)=
\begin{cases}
TRUE,\quad if \quad E_{T_k}(I(Y_{T_k}!=N(X_{T_k}))) \leq \epsilon_B\\
FALSE,\quad otherwise
\end{cases}</script><p>5）白盒验证过程：验证模型参数是否嵌入能证明所属权的“水印”。</p>
<script type="math/tex; mode=display">
V_w(W,(B_k,\theta_k))
\begin {cases}
TRUE \quad H(B_k,B_k^~)\leq \epsilon_W\\
FALSE
\end {cases}</script>]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>模型产权</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读_EIFFEL</title>
    <url>/posts/b7d0b83d.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>今天的论文题目是《E FFeL: Ensuring Integrity For Federated Learning》</p>
<p>论文地址：<a href="https://doi.org/10.1145/3548606.3560611">https://doi.org/10.1145/3548606.3560611</a></p>
<span id="more"></span>
<h1 id="E-FFeL-Ensuring-Integrity-For-Federated-Learning"><a href="#E-FFeL-Ensuring-Integrity-For-Federated-Learning" class="headerlink" title="E FFeL: Ensuring Integrity For Federated Learning"></a>E FFeL: Ensuring Integrity For Federated Learning</h1><p>联邦学习（FL）使客户端能够与服务器协作训练机器学习模型。为了确保隐私，服务器对来自客户端的更新进行安全聚合。不幸的是，由于更新被掩盖，这使得无法验证更新的完整性。因此，可以在不被检测的情况下注入旨在毒化模型的畸形更新。在本文中，我们将联邦学习中更新隐私和完整性问题进行形式化，并提出了一种新的系统，EIFFeL，它能够实现已验证更新的安全聚合。EIFFeL是一个通用框架，可以实施任意完整性检查，并从聚合中移除畸形更新，同时不违反隐私。我们的实证评估证明了EIFFeL的实用性。例如，在有100个客户端和10%毒化的情况下，每次迭代仅需2.4秒，EIFFeL就可以训练出与非毒化联邦学习器相同精度的MNIST分类模型。</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>FL 的一个主要挑战是容易受到拜占庭攻击。特别是，恶意客户端可以向学习器注入有毒更新，目的是降低全局模型的准确性，或者在模型中植入后门，以便日后加以利用。</p>
<p>FL 中的这些挑战引出了研究问题： 联合学习器如何在不侵犯客户隐私的情况下有效验证客户更新的完整性？</p>
<p>我们提出了安全聚合验证输入（SAVI）协议，从而使这一问题正规化： (1) 安全验证每个本地更新的完整性，(2) 只聚合格式良好的更新，(3) 只以明文形式发布最终聚合。</p>
<p>我们通过提出 EIFFeL 来证明 SAVI 的可行性：这是一个实例化 SAVI 协议的系统，它可以执行任何完整性检查，而这些检查可以用带有公共参数的算术电路来表示。</p>
<h1 id="Problem-Overview"><a href="#Problem-Overview" class="headerlink" title="Problem Overview"></a>Problem Overview</h1><h2 id="Setting"><a href="#Setting" class="headerlink" title="Setting"></a>Setting</h2><p>在 FL 中，拥有分布式数据的多方共同训练一个全局模型 $M$，但彼此不会明确披露数据。FL 有两类参与者：</p>
<ul>
<li><p>Clients : n个客户端，$C_i$，拥有各自的数据集$D_i$，原始数据从不共享，相反，每个客户端通过私有数据集 $D_i$计算 M 的本地更新，如平均梯度。</p>
</li>
<li><p>Server:  有一个不受信任的服务器 S，它负责协调来自不同客户端的更新，以训练 M。</p>
</li>
</ul>
<p>FL的一次训练迭代包括以下步骤：</p>
<ul>
<li><p>Boradcast: 服务器向所有客户端广播模型 M 的当前参数。</p>
</li>
<li><p>Local computation: 每个客户端 $C_i$本地计算更新</p>
</li>
<li>Aggregation: 服务器 S 收集客户端更新并将其聚合 $U=\sum _i \in[n] u_i$</li>
<li>Global model update.服务器 S 根据聚合更新 U 更新全局模型 M。</li>
</ul>
<h2 id="goals-and-threat"><a href="#goals-and-threat" class="headerlink" title="goals and threat"></a>goals and threat</h2><ul>
<li><p>输入隐私（客户目标）。第一个目标是确保隐私。除了从最终模型输出$U$ 中可以了解到的信息外，任何一方都不能了解到诚实客户端$C_i$的原始输入（更新）$u_i$ 的任何信息。</p>
</li>
<li><p>输入完整性（服务器的目标）。服务器$S$确保来自每个客户端的更新都是完整的。具体来说，服务器有一个公共验证谓词 Valid(-)，它定义了输入（更新）的语法。如果 Valid(𝑢) = 1，则输入（更新）𝑢 被视为有效，并因此通过完整性检查。</p>
</li>
</ul>
<p>我们考虑恶意对手威胁模型：</p>
<ul>
<li><p>Malicious Server: 我们认为恶意服务器可以任意偏离协议，目的是恢复原始更新$u_i$</p>
</li>
<li><p>Malicious Clients: 恶意客户端可以任意偏离协议，其目标是 (1) 向服务器发送畸形输入，从而破坏最终聚合；(2) 不对提交格式良好更新的诚实客户端进行完整性检查；(3) 侵犯诚实客户端的隐私，可能与服务器串通一气。</p>
</li>
</ul>
<h2 id="带有验证输入的安全聚合"><a href="#带有验证输入的安全聚合" class="headerlink" title="带有验证输入的安全聚合"></a>带有验证输入的安全聚合</h2><p><strong>定义1</strong> 给定验证$Valid(\cdot)$和安全参数$\kappa$，协议$Ⅱ(u_1…u_n)$，安全的聚合协议SAVI如下：</p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>联邦学习</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读_Videre</title>
    <url>/posts/11d64058.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>今天的论文题目是《Characterizing and Detecting Non-Consensual Photo Sharing on Social Networks》</p>
<p>论文地址：<a href="https://dl.acm.org/doi/10.1145/3548606.3560571">https://dl.acm.org/doi/10.1145/3548606.3560571</a></p>
<span id="more"></span>
<h2 id="Characterizing-and-Detecting-Non-Consensual-Photo-Sharing-on-Social-Networks"><a href="#Characterizing-and-Detecting-Non-Consensual-Photo-Sharing-on-Social-Networks" class="headerlink" title="Characterizing and Detecting Non-Consensual Photo Sharing on Social Networks"></a>Characterizing and Detecting Non-Consensual Photo Sharing on Social Networks</h2><p>描述和检测社交网络上未经同意的照片共享</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在社交平台上，拍照和分享已成为日常活动。然而，在社交互动的娱乐背后，我们也在经历巨大的视觉侵犯和照片滥用问题。特别是，用户可能会在不知情的情况下被拍摄并在线曝光，这被称为非共识性分享问题。不幸的是，由于用户对自己的处境毫不知情，可能会被偷偷拍摄，因此这个问题无法通过主动访问控制或专门的旁观者检测来解决。我们提出了 Videre，代表那些在不知情的情况下被拍摄的人的隐私，在这样的照片公之于众之前，自动识别并警告他们。为此，我们首先通过深入的用户研究详细阐述了非共识性拍摄照片中遇到的主要特征。然后，我们为这个背景建立了一个数据集，并基于多深度特征融合构建了一个主动检测器作为分类器。为了减轻逐个识别不知情者的负担，我们进一步设计了一种基于签名的本地预授权过滤器，这也可以隐含地避免分类错误。我们在各种现场环境中实施并测试 Videre，以展示其有效性和性能。</p>
<h2 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h2><p>摄像头的普及促进了照片的快速发展，社交网络则推动了照片分享。前所未有的照片捕捉和分享活动将人们置于随时随地都可能被看到的尴尬境地，从而对其隐私构成严重威胁。即使谨慎的社交分享用户，也会不可避免地或无意识地被偷拍，这在本文被叫做 <strong>未经同意的照片分享问题</strong> 。如果与公众分享，就会不小心泄露他们的生活圈子和日常活动。更糟糕的是，这些照片可能会在社交网络和云服务器上迅速传播，使隐私泄露的范围更广、时间更长。</p>
<h2 id="现存技术的问题"><a href="#现存技术的问题" class="headerlink" title="现存技术的问题"></a>现存技术的问题</h2><p>人们已经探索了许多保护被拍照者隐私的技术手段，通常是通过防止照片被偷拍或设计访问策略来控制照片在社交网络上的传播。有的会要求用户主动参与，在照相设备上安装特定应用程序，已检测未经授权的照片捕获。这些建议无法扩展，因为它们不适用于传统相机，而且恶意摄影师可以通过禁用这些应用程序轻松绕过检测。</p>
<p>在一项开创性的工作中，训练了一个机器学习模型来自动识别照片中的旁观者。然而，这两个术语/问题在定义上是不同的。”旁观者 “指的是没有被摄影者有意捕捉到的人（如图1中两张照片所示），而非自愿照片共享中的 “不知情方 “更广泛地指的是如果被捕捉到就更容易被侵犯隐私的人(如图1中中间两张照片所示)。</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307140947904.png" alt="image-20230714094706768"></p>
<p>因此，非自愿照片分享涵盖了更严重的、但以前被忽视的偷拍情况。</p>
<h2 id="方案设计思路"><a href="#方案设计思路" class="headerlink" title="方案设计思路"></a>方案设计思路</h2><p>我们首先进行了两项用户调查。其中一项调查的重点是研究共享照片中 <strong>主观感知的不可见性的主要特征</strong>。详细的观察结果有助于描述在未经同意的照片中可以统计发现的视觉线索的特征。另一个重点是研究用户对非自愿照片共享的行为偏好，这有助于我们建立用户习惯/体验的基线。</p>
<p>此外，我们还建立了一个带有未感知人物注释的照片数据集，以填补在此背景下缺乏相关数据资源的空白。</p>
<p>最后，我们提出了Videre框架。简而言之，它利用用户研究中阐述的融合特征进行联合分类，以识别上传照片中的未意识到的个人，并使用<strong>基于签名的过滤器</strong>进行本地收集授权，减轻了人物分类的负担。</p>
<p>调查特征——建立数据集——提出框架——分类过滤</p>
<p><strong>本文贡献：</strong>  我们发现了未经同意的照片分享的可量化特征，并提出了一种对可能的违规分享行为敏感的自动检测器。从高层次来看，考虑到被无意识拍照的不可预测性（随时随地），该检测器将作为平台中的隐私保护代理反应性地工作，在必要时提醒用户，同时避免繁琐的事先设置。</p>
<ul>
<li>我们进行了一项真实世界的用户研究，对共享照片中的不可见性进行了主观描述，并发现眼睛注视方向和头部朝向构成了识别未经同意的照片共享的两个主要线索。</li>
<li>我们建立了一个可公开获取的数据集，并对图片中每个人的不自觉性进行了精确的人工注释，以促进相关研究。</li>
<li>我们提出了Videre的设计方案，通过训练一个多特征融合的机器学习分类器来检测不知情方。Videre通过在本地执行无证书聚合签名的预授权阶段来实现效率。</li>
<li>我们进行了广泛的实验和实地调查来评估Videre的性能。</li>
</ul>
<h2 id="问题动机"><a href="#问题动机" class="headerlink" title="问题动机"></a>问题动机</h2><h3 id="社交网络上的非自愿照片分享"><a href="#社交网络上的非自愿照片分享" class="headerlink" title="社交网络上的非自愿照片分享"></a>社交网络上的非自愿照片分享</h3><p>一般的照片分享行为过程如图1所示，基本涉及四类主体：</p>
<ul>
<li>摄影师/照片分享者根据自己的兴趣爱好拍摄照片并提交到网络上</li>
<li>被分享照片覆盖的个人</li>
<li>接收提交照片并发布到网络空间的社交平台</li>
<li>通过社交平台浏览并转发分享照片的浏览者</li>
</ul>
<h3 id="未感知方的定义"><a href="#未感知方的定义" class="headerlink" title="未感知方的定义"></a>未感知方的定义</h3><p>在我们的研究中，我们将未经同意的照片所描述的客观实体定义为 “未感知方”。从被拍摄者的角度来看，”未感知方 “指的是 “不知道自己被拍摄的人”，如图1中的照片②和③。</p>
<h3 id="无意识方与旁观者的区别"><a href="#无意识方与旁观者的区别" class="headerlink" title="无意识方与旁观者的区别"></a>无意识方与旁观者的区别</h3><p>目前的研究协议根据人对照片的重要性和拍摄者的意图，将共享照片中的人分为两类，主体和旁观者。被偷拍者 “与 “旁观者 “之间不存在逻辑或因果关系，”被偷拍者 “的概念主要是指被偷拍者在拍照时的不知情状态，与是否为旁观者无关。而在这篇文章中，我们关注的是<strong>被偷拍者</strong> 。</p>
<h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><p>未知情者的隐私更容易被侵犯，也更难保护，因此他们的隐私更值得关注。在本文中，我们将重点解决未经同意的照片分享问题</p>
<h2 id="主要挑战"><a href="#主要挑战" class="headerlink" title="主要挑战"></a>主要挑战</h2><h3 id="如何描述不知情和有意识"><a href="#如何描述不知情和有意识" class="headerlink" title="如何描述不知情和有意识"></a>如何描述不知情和有意识</h3><p>对于共享照片中的当事人而言，”不知情 “或 “有意识 “等术语可能具有主观和微妙的解释，且因人而异。</p>
<p>首先进行了一项用户研究，目的是列举这些认知的多样性。在这项研究中，参与者根据社会规范、过去的经验和图像中的视觉信息将一个人分为 “未意识到的一方 “或 “意识到的一方”。</p>
<h3 id="如何自动识别未感知方"><a href="#如何自动识别未感知方" class="headerlink" title="如何自动识别未感知方"></a>如何自动识别未感知方</h3><p>建立自动分类器的前提是收集训练特征和标签。首先建立了一个人工标注的数据集，并且选择了一组与未觉察密切相关的视觉特征。为了实证检验这组视觉特征作为自动分类预测因子的有效性，我们分别使用不同的单一特征和由多种特征融合得到的新特征建立了几个分类器。从现实世界中的分享行为来看，大多数人都强烈希望在他人将包含自己的照片上传到社交网络之前征求自己的意见。为此，我们在调查了未知情者的分享偏好，并评估了对分享前咨询行为的接受程度，以建立用户习惯/体验基线。</p>
<h2 id="Videre设计"><a href="#Videre设计" class="headerlink" title="Videre设计"></a>Videre设计</h2><p>我们为本研究进行了三项调查。第一项用户调查是关于未知方的预测功能。第二项调查是评估用户行为。最后一项调查是关于人在环设计的反馈。</p>
<h3 id="调查设计"><a href="#调查设计" class="headerlink" title="调查设计"></a>调查设计</h3>]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>隐私保护</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读_Platypus</title>
    <url>/posts/8ad5d7eb.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h2 id="Platypus-A-Central-Bank-Digital-Currency-with-Unlinkable-Transactions-and-Privacy-Preserving-Regulation"><a href="#Platypus-A-Central-Bank-Digital-Currency-with-Unlinkable-Transactions-and-Privacy-Preserving-Regulation" class="headerlink" title="Platypus: A Central Bank Digital Currency with Unlinkable Transactions and Privacy-Preserving Regulation"></a>Platypus: A Central Bank Digital Currency with Unlinkable Transactions and Privacy-Preserving Regulation</h2><p>论文地址：<a href="https://dl.acm.org/doi/10.1145/3548606.3560617">https://dl.acm.org/doi/10.1145/3548606.3560617</a></p>
<span id="more"></span>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>由于基于区块链的加密货币的普及，支付的日益数字化以及现金在社会中的作用不断减弱，各国央行对部署央行数字货币（CBDC）表现出越来越大的兴趣，这种数字货币可以作为数字现金的替代品。尽管大多数关于CBDC的研究都集中在区块链技术上，但这种技术选择是否提供了最优解决方案尚不明确。特别是，CBDC的集中信任模型为不同的设计提供了机会。在本文中，我们摒弃区块链设计，转而借鉴传统电子现金方案的思想。我们提出了一种新的构建数字货币的方法，将电子现金的交易处理模型与基于账户的资金管理模型相结合。我们认为，这种构建数字货币的方式特别适用于CBDC。我们还设计了第一个这样的数字货币系统，名为Platypus，它提供了强大的隐私保护、高可扩展性以及简单却具有表现力的监管，这些都是CBDC的关键特性。Platypus通过采用类似于Zcash等匿名区块链加密货币中使用的技术来适应我们的账户模型，并将它们应用于电子现金环境，从而实现了这些特性。</p>
<p><strong>关键词</strong> 数字货币</p>
<h2 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h2><p>区块链在无权限数字货币（即不依赖于可信中央机构的数字货币）中的普及。中央银行数字货币（CBDC）受到这种启发，具有不同于无许可加密货币的信任模式和要求。传统的电子现金为发送者提供了隐私，但泄露了交易金额，在分布帐的系统中，硬币不需要存入，而是进行价值转移。</p>
<p>与基于分类账的系统相比，电子现金系统有几个优点。电子现金系统更容易扩展，对客户端的要求可能会降低，因为在基于分类账的系统中，客户端会随时更新整个分类账或使用轻量级客户端，这就降低了客户端的隐私性。</p>
<p>本文的目标：希望利用中央银行数字货币的不同信任模型，并结合基于账本的数字货币和传统电子现金方案的优势。</p>
<p>为了实现这些目标，作为本文的第一个主要贡献，我们提出了一种构建数字货币的新方式，它将电子现金支付的交易处理模式与基于账户的用户资金管理模式相结合。</p>
<p>作为本文的第二个主要贡献，我们设计了第一个遵循这种设计模式的数字货币系统，名为Platypus。在Platypus中，每个参与者都拥有一个账户，该账户由中央银行签署的一个序列号和余额的承诺（称为账户状态承诺）来表示。交易包括更新发送方和接收方的承诺。发送方和接收方披露其当前账户状态的序列号，以零知识证明他们拥有由中央银行签署的相应状态承诺，并且他们的余额之和保持不变。</p>
<h2 id="动机和目标"><a href="#动机和目标" class="headerlink" title="动机和目标"></a>动机和目标</h2><p>目前，在许多司法管辖区，现金的获取和使用都在下降，这就造成了一些企业和家庭无法获取无风险的中央银行货币的风险。CBDC可以填补这一空白，确保人们对货币的信心。</p>
<p>现金不仅提供无风险的中央银行货币，而且还提供非常强大的隐私保证。在现金支付中，第三方既不会知道交易双方的身份，也不会知道交易的价值。这也是CBDC应该具有的特性。对CBDC的另一个监管要求是执行反洗钱法。然而，这与改善支付隐私的目标存在部分冲突。解决这一冲突的方法是允许匿名支付，但每单位时间内的支付金额不得超过一定限额，超过限额后收款人需向监管机构披露身份。基于这些动机和想法，我们将重点放在零售CBDC上。</p>
<h2 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h2><p>我们假设中央银行的隐私是不可信的。</p>
<p>我们认为完全防范基于网络的去匿名化攻击（例如，将一个IP地址与多个交易联系起来）不在本文的讨论范围之内。</p>
<p>我们假设客户之间通过安全通道进行通信，并且所有使用的加密原语根据其安全性的标准定义都是安全的。</p>
<p>我们假设承诺具有计算约束力和隐藏性，签名是不可伪造的，零知识证明系统是零知识并提供健全性，加密是CPA安全的。</p>
<p>我们还假设零知识证明提供语句的不可并行性</p>
<h2 id="Platypus-设计"><a href="#Platypus-设计" class="headerlink" title="Platypus 设计"></a>Platypus 设计</h2><p>Platypus采用账户模型和电子现金的混合设计，每个参与者负责跟踪自己的<strong>账户状态</strong>，账户状态被保存为类似于电子现金系统中硬币的对象。然而，与电子现金不同的是，客户通常拥有多个可用于交易的硬币，而客户只有一个账户状态，该账户状态在每次交易中都会被消耗，并被新的账户状态取代。该账户状态由账户余额$bal_i$和序列号$serial_i$的账户状态承诺$state_i$表示。账户状态承诺由之前的交易产生，并由中央银行签署。为了签署这些状态承诺，中央银行使用其秘密密钥$sk_C$（与公钥$pk_C$相对应）。</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307190942950.png" alt="image-20230719094248803"></p>
<p>如图显示了在发送方和接收方均已参与系统的正常情况下交易的处理过程。</p>
<p>在步骤1中，Alice发起交易，通过创建发送方账户更新向接收方Bob发送$v<em>{Tx}$值。Alice 使用随机盲因子 $blind</em>{Tx}$ 对值 $v<em>Tx$ 创建一个承诺，称为交易承诺，用 $comm</em>{Tx}=comm(v<em>{Tx},blind</em>{Tx})$ 表示。</p>
<p>然后，爱丽丝创建一个新的状态承诺$state<em>{i+1}^A$，该状态承诺$state</em>{i+1}^A$承诺一个新的伪随机（基于长期密钥）选择的序列号$serial^A<em>{i+1}$和一个值$bal_i+1^A=bal_i^A-v</em>{Tx}$，其中$bal^A<em>i$是在当前状态承诺$state_i^A$中承诺的余额。然后 Alice 创建一个非交互式零知识证明$zkp</em>{i+1}^A$ 来证明她正确地执行了这些步骤。</p>
<p>零知识证明$zkp<em>{i+1}^A$ 以及交易承诺$comm</em>{Tx}$、旧状态$serial<em>i^A$和新账户状态承诺$state</em>{i+1}^A$随后被发送给接收者Bob。Alice还提供了打开承诺$comm<em>{Tx}$所需的随机值$blind</em>{Tx}$，这样Bob就可以用它为自己的账户更新创建零知识证明。</p>
<p>为了完成交易（步骤 2 ），Bob 接着创建一个接收方的账户更新，其步骤与 Alice 类似，不同之处在于他的零知识证明$zkp<em>{j+1}^B$重复使用了交易承诺 $comm</em>{Tx}$，并证明了他在新状态$state^B<em>{j+1}$ 中的账户余额与他之前的状态$state_j^B$相比，正好增加了$v</em>{Tx}$，序列号为 $serial_j^B$ 。</p>
<p>一旦 Bob 创建了证明 $zkp<em>{j+1}^B$，他就会发送交易承诺 $comm</em>{Tx}$、Alice’ 和他的序列号$(serial<em>𝑖^𝐴, serial^𝐵</em>𝑗 )$、 向中央银行提交两个新的状态承诺$(state<em>{i+1}^{𝐴}, state^𝐵</em>{𝑗+1})$和两个零知识证明$zkp^A<em>{i+1}, zkp^𝐵</em>{𝑗+1}$。</p>
<p>然后，中央银行通过验证两个零知识证明并检查序列号$(serial<em>𝑖^𝐴, serial^𝐵</em>𝑗 )$是否在以前的交易中使用过来执行交易（步骤 3 ）。如果是这种情况，中央银行会将这两个序列号添加到已使用的序列号集合中，用其私人密钥$sk<em>C$签署两个新的状态承诺$(state</em>{i+1}^{𝐴}, state^𝐵<em>{𝑗+1})$，并发送签署的序列号$\sigma </em>{𝑖+1}^A = Sign(𝑠𝑘<em>𝐶, state^A</em>{𝑖+1})$ 和 $\sigma <em>{𝑖+1}^B = Sign(𝑠𝑘</em>𝐶, state^B<em>{j+1})$ 返回给 Bob，Bob 检查签名是否有效，如果有效，则接受付款（步骤 4）。然后，鲍勃将$\sigma</em>{i+1}^A$ 转发给爱丽丝，爱丽丝验证签名并更新其存储的状态信息，从而完成支付（第 5 步）。</p>
<h2 id="交易细节"><a href="#交易细节" class="headerlink" title="交易细节"></a>交易细节</h2><h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p>为建立系统，中央银行创建一个用于签署账户状态承诺的私钥/公钥对$sk<em>C,pk_C$，并公布其公钥$pk_C$。中央银行还设置了一个参数 $bal</em>{max}$，这是账户余额的最大限制，以防止数值溢出（即由于所有数值都是有限域元素，因此可确保余额不能为负），其值可设置为大于账户余额的所有实际数值。</p>
<p>当用户𝑈 注册进入系统时，他们会创建一个密钥$𝑠𝑘<em>𝑈 = (𝑠𝑘</em>{U1},𝑠𝑘<em>{𝑈2})$，由两个随机选择的密钥$𝑠𝑘</em>{𝑈 1},𝑠𝑘_{𝑈 2}$ 组成。</p>
<p>为了创建注册交易，𝑈 会生成伪随机值 $serial^𝑈<em>1,blind^𝑈_1 $从他们的私钥$serial_1^U=f</em>{sku1},blind<em>1^U=g</em>{shku2}$，并用它们创建新的状态承诺 $state^𝑈_1 = comm(serial^𝑈_1,bal^𝑈_1,blind^𝑈_1 )$，表示没有余额的账户，即 $bal_1^U=0$，𝑈 创建一个非交互式零知识证明 $zkp^𝑈_1$，证明账户状态承诺对应于余额为零的账户，即 zkp𝑈1 证明了以下语句</p>
<p>给出公众值：$state<em>1^U$，知晓私值： $sk</em>{U1},serial_1^U,blind_1^U$</p>
<p>这样：$state<em>1^U=comm(serial_1^U,0,blind_1^U),serial_1^U=f</em>{skU1}(0)$</p>
<p>然后𝑈 将状态$state_1^U$和 $zkp^𝑈_1$ 发送给中央银行。银行检查证明是否正确，然后签署账户状态承诺状态$state_1^U$，并将签名发回给𝑈。</p>
<h3 id="Transaction-Creation"><a href="#Transaction-Creation" class="headerlink" title="Transaction Creation"></a>Transaction Creation</h3><p>我们将介绍发送方（Alice）和接收方（Bob）之间的交易是如何创建的。我们假定，除非另有说明，客户会对所有值保密，并且他们会通过安全通道进行通信。在实践中，发送方需要通过认证通道（类似于接收比特币地址）从接收方那里接收一个公钥，然后用来建立通道。这个公钥可以作为二维码显示在支付终端、电子商务网站或手机上。</p>
<p>A当前账户状态：$state<em>𝑖^𝐴 = comm(serial</em>𝑖^𝐴, bal<em>𝑖^𝐴, blind</em>𝑖^𝐴)$</p>
<p>B前账户状态：$state_j^B = comm(serial_j^B, bal_j^B, blind_j^B)$</p>
<p>此外，两人都持有中央银行对其账户状态承诺的签名：$\sigma _i^A =Sign(sk_C,state_i^A),\sigma _j^B =Sign(sk_C,state_j^B)$</p>
<ol>
<li><strong>Transaction Initiation</strong>:</li>
</ol>
<p>(i) 为了给 Bob 创建一个值为$v<em>{Tx}$的交易，Alice 选择一个新的随机值 $blind_Tx$ 并创建一个承诺 $comm</em>{Tx} = comm(𝑣<em>{Tx},blind</em>{Tx})$。<br>(ii) Alice 还从她的秘钥推导出伪随机值 $serial<em>{𝑖+1}^A, blind</em>{𝑖+1}^A$ 从$serial<em>{𝑖+1}^A = 𝑓</em>{𝑠𝑘𝐴1} (serial<em>𝑖^𝐴) ,blind</em>{𝑖+1}^A = 𝑔<em>{𝑠𝑘𝐴2} (blind</em>𝑖^𝐴)$ 并创建新的账户状态 $state<em>{𝑖+1}^A =comm(serial</em>{𝑖+1}^A, bal<em>𝑖^𝐴 - 𝑣Tx, blind</em>{𝑖+1}^A)$.</p>
<p>(iii) 然后，爱丽丝创建一个非交互式零知识证明 $zkp<em>{𝑖+1}^A$，证明以下语句： 给定公共值<br>$serial</em>𝑖^𝐴, comm<em>{Tx}, state</em>{𝑖+1}^A, bal<em>{max}, 𝑝𝑘</em>𝐶$<br>我知道秘密值<br>$𝑠𝑘<em>{𝐴1}，bal</em>𝑖^𝐴，bal<em>{𝑖+1}^A，blind</em>𝑖^𝐴，𝜎<em>𝑖^𝐴，𝑣</em>{Tx}，blind<em>{Tx}，serial</em>{𝑖+1}^A，blind_{𝑖+1}^A$，</p>
<p>使得<br>$True = Vrfy(𝑝𝑘<em>𝐶, comm(serial</em>𝑖^𝐴, bal<em>𝑖^𝐴, blind</em>𝑖^𝐴), 𝜎_𝑖^𝐴)$</p>
<p>$comm<em>{Tx} = comm(𝑣</em>{Tx}, blind<em>{Tx})$<br>$state</em>{𝑖+1}^A = comm(serial<em>{𝑖+1}^A, bal</em>{𝑖+1}^A, blind_{𝑖+1}^A)$ </p>
<p>$bal<em>{max} ≥ bal</em>{𝑖+1}^A$</p>
<p>$bal<em>{𝑖+1}^A = bal</em>𝑖^𝐴 - 𝑣_{Tx}$</p>
<p>$serial<em>{𝑖+1}^A = 𝑓</em>{𝑠𝑘𝐴1} (serial<em>i^𝐴)$<br>(iv) 然后 Alice 将$𝑣</em>{Tx}、blind<em>{Tx}、comm</em>{Tx}、serial<em>𝑖^𝐴、state</em>{𝑖+1}^A、zkp_{𝑖+1}^A$发送给 Bob。</p>
<ol>
<li><strong>Transaction Completion</strong></li>
</ol>
<p>(i) 收到 Alice 发送的部分交易后，Bob 会删除$serial<em>{j+1}^B=f</em>{skB1}(serial<em>j^B),blind^𝐵</em>{𝑗+1}=g<em>{skB2}(blind_j^B)$的伪随机值$serial</em>{j+1}^B,blind<em>{j+1}^B$并且创建新的$state</em>{j+1}^B=comm(serial^B<em>{j+1}，bal_j^B+v</em>{Tx},blind_{j+1}^B)$</p>
<p>(ii) 如果B已经有一个账户，鲍勃创建一个非交互式零知识证明 $zkp^𝐵_{𝑗+1}$，与A的证明类似（不同之处在于证明他的余额增加了交易值），证明以下语句：</p>
<p>$serial<em>j^B,comm</em>{Tx},state<em>{j+1}^B,bal</em>{max},pk_C$</p>
<p>知道秘密值<br>$𝑠𝑘<em>{B1}，bal_j^B，bal</em>{j+1}^B，blind<em>j^B，𝜎_j^B，𝑣</em>{Tx}，blind<em>{Tx}，serial</em>{j+1}^B，blind_{j+1}^B$，</p>
<p>使得</p>
<p>$True = Vrfy(𝑝𝑘_𝐶, comm(serial_j^B, bal_j^B, blind_j^B), 𝜎_j^B)$</p>
<p>$comm<em>{Tx} = comm(𝑣</em>{Tx}, blind<em>{Tx})$<br>$state</em>{j+1}^B = comm(serial<em>{j+1}^B, bal</em>{j+1}^B, blind_{j+1}^B)$ </p>
<p>$bal<em>{max} ≥ bal</em>{j+1}^B$</p>
<p>$bal<em>{j+1}^B = bal_j^B - 𝑣</em>{Tx}$</p>
<p>$serial<em>{j+1}^B = 𝑓</em>{𝑠𝑘B1} (serial_j^B)$</p>
<p>(iii) 然后 B将$comm<em>{Tx},serial</em>𝑖^𝐴,state<em>{𝑖+1}^A,zkp</em>{𝑖+1}^A,serial<em>i^B,state</em>{i+1}^B,zkp_{i+1}^B$发送给 银行。</p>
<ol>
<li><strong>Transaction Execution</strong></li>
</ol>
<p>(i) 中央银行检查序列号$serial<em>i^A$、$serial^𝐵</em>𝑗$ 是否出现在其存储的以前使用过的序列号集中，并且两个零知识证明 $zkp<em>{i+1}^A$、$zkp^𝐵</em>{𝑗+1}$ 均已验证。如果情况并非如此，则中央银行拒绝交易并通知 Bob。<br>(ii) 否则，中央银行接受交易，并将这两个序列号添加到之前使用过的序列号集合中，将新的状态承诺签名为 $𝜎^𝐴<em>{i+1} =Sign(𝑠𝑘</em>𝐶, state<em>{𝑖+1}^A)$ 和$𝜎^𝐵</em>{𝑗+1} = Sign(𝑠𝑘<em>𝐶, state^𝐵</em>{𝑗+1})$ 并发送给B。此外，中央银行还会发布转行动（即从 B 收到的所有值加上 $𝜎<em>{𝑖+1}^A$ 和 $𝜎^𝐵</em>{𝑗+1}$）。</p>
<ol>
<li><strong>Payment Acceptance</strong></li>
</ol>
<p>Bob 检查从中央银行收到的签名是否有效，接受付款并存储$𝜎^𝐵<em>{𝑗+1}$，以便在这种情况下更新其账户，并将$𝜎^A</em>{i+1}$转发到A。否则，他会拒绝付款并通知 Alice。</p>
<ol>
<li><strong>Payment Completion</strong> </li>
</ol>
<p>Alice 检查从 Bob 收到的签名是否有效。否则，或者如果超时后仍未收到 Bob 的签名，她会检查中央银行的公共交易日志，以检索交易和新账户状态承诺上的签名。然后，她存储 $\sigma ^A_{i+1}$ 来更新她的账户，支付完成。</p>
<h2 id="REGULATION-IN-PLATYPUS"><a href="#REGULATION-IN-PLATYPUS" class="headerlink" title="REGULATION IN PLATYPUS"></a>REGULATION IN PLATYPUS</h2><p> CBDC 要求能够执行监管政策。特别是，CBDC 应该能够执行确保系统金融稳定的规则（例如，防止银行挤兑），以及允许执行反洗钱立法或允许检测逃税的规则。</p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>数字货币</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读DPIS</title>
    <url>/posts/4d931e35.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>今天的论文题目是《Private and Reliable Neural Network Inference》</p>
<p>论文地址：<a href="https://doi.org/10.1145/3548606.3560562">https://doi.org/10.1145/3548606.3560562</a></p>
<span id="more"></span>
<h1 id="DPIS-An-Enhanced-Mechanism-for-Differentially-Private-SGD-with-Importance-Sampling"><a href="#DPIS-An-Enhanced-Mechanism-for-Differentially-Private-SGD-with-Importance-Sampling" class="headerlink" title="DPIS: An Enhanced Mechanism for Differentially Private SGD with Importance Sampling"></a>DPIS: An Enhanced Mechanism for Differentially Private SGD with Importance Sampling</h1><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>如今，差分隐私（DP）已成为隐私保护的广泛认可标准，而深度神经网络（DNN）在机器学习领域取得了巨大成功。将这两种技术相结合，即具有差分隐私的深度学习，有望保护隐私地发布使用敏感数据（如医疗记录）训练的高效用模型。为此，经典的机制是 DP-SGD，它是一种用于 DNN 训练的差分隐私版本的随机梯度下降（SGD）优化器。随后的方法改进了模型训练过程的各个方面，包括噪声衰减时间表、模型架构、特征工程和超参数调整。然而，自原始 DP-SGD 算法以来，SGD 优化器中强制执行 DP 的核心机制一直未发生变化，这越来越成为限制 DP 合规机器学习解决方案性能的基本障碍。受此启发，我们提出了 DPIS，一种新颖的差分隐私SGD训练机制，可作为 DP-SGD 核心优化器的替代品，与后者相比具有一致且显著的准确性提升。主要思想是在每次 SGD 迭代中，使用重要性采样（IS）进行小批量选择，从而减少采样方差和满足 DP 所需注入梯度的随机噪声量。尽管在非隐私设置中，使用 IS 的 SGD 在机器学习文献中已被广泛研究，但将 IS 集成到 DP-SGD 的复杂数学机制中是非常重要的；此外，IS 还涉及到额外的私有数据发布，这些数据必须在差分隐私下受到保护，以及计算密集型梯度计算。DPIS 通过新颖的机制设计、细粒度的隐私分析、效率增强和自适应梯度裁剪优化来应对这些挑战。在四个基准数据集（即 MNIST、FMNIST、CIFAR-10 和 IMDb）上进行的大量实验，涉及卷积神经网络和循环神经网络，证明了 DPIS 在具有差分隐私的深度学习方面优于现有解决方案的有效性。</p>
<h1 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h1><p>传统的深度学习将会带来隐私上的困扰。现如今，DP-SGD被看作是具有隐私保护性质的机器学习模型，DP-SGD 向 SGD 算法每次迭代中计算出的梯度注入随机噪音，但是，由于梯度中注入了噪声，在典型的隐私参数设置下，用 DP-SGD 训练出来的模型与不考虑隐私因素的普通 SGD 训练出来的模型在性能上仍有相当大的差距</p>
<p>本文提出在核心层面优化DP-SGD的DPIS，其主要思想是每次SGD迭代中加入重要性采样（IS），以取代非私有SGD和DP-SGD中的随机抽样步骤。IS有助于降低SGD的采样方差并加快收敛速度，并且还有助于减少注入梯度的噪声量。</p>
<p>在每次迭代中，DPIS 都会以与其梯度规范成比例的概率对每条记录进行采样，并对梯度进行加权，以获得对总梯度的无偏估计。</p>
<p>本文采用了四个实验数据集：MNIST、Fashion MNIST (FMNIST)、CIFAR-10 和 IMDb。</p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>差分隐私</tag>
      </tags>
  </entry>
  <entry>
    <title>隐私计算</title>
    <url>/posts/b6d1aa03.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="隐私计算"><a href="#隐私计算" class="headerlink" title="隐私计算"></a>隐私计算</h1><h2 id="什么是隐私计算"><a href="#什么是隐私计算" class="headerlink" title="什么是隐私计算"></a>什么是隐私计算</h2><p><strong>百度百科：</strong>隐私计算(Privacy compute 或Privacy computing)是指<strong>在保护数据本身不对外泄露的前提下实现数据分析计算的技术集合，达到对数据“可用、不可见”的目的</strong>；在充分保护数据和隐私安全的前提下，实现数据价值的转化和释放。</p>
<p>简单来说：隐私+技术=数据可用不可见</p>
<span id="more"></span>
<h2 id="隐私计算前景"><a href="#隐私计算前景" class="headerlink" title="隐私计算前景"></a>隐私计算前景</h2><h3 id="隐私数据相关法律法规"><a href="#隐私数据相关法律法规" class="headerlink" title="隐私数据相关法律法规"></a>隐私数据相关法律法规</h3><p>目前，随着智能化社会的日益推广，许多人都意识到隐私和数据的重要性，各国政府和组织机构，从政策法规层面进行了规范，如下：</p>
<ul>
<li><p><strong>GDPR</strong>全称<a href="https://gdpr-info.eu/">General Data Protection Regulation</a>，中文是<strong>通用数据保护条例</strong>，是在欧盟法律中对所有欧盟个人关于数据保护和隐私的规范，主要目标为取回个人对于个人数据的控制，以及为国际商务而简化在欧盟内的统一规范。</p>
</li>
<li><p>2021年8月，美国通过UPDPA，《统一个人数据保护法》，是<strong>旨在统一州隐私立法的示范法案</strong>。</p>
</li>
<li>2021年6月《中华人民共和国数据安全法》（以下称《数据安全法》）历经三审三读，于2021年6月10日经第十三届全国人民代表大会常务委员会第二十九次会议通过。</li>
</ul>
<h3 id="行业前景"><a href="#行业前景" class="headerlink" title="行业前景"></a>行业前景</h3><h2 id="隐私计算概述"><a href="#隐私计算概述" class="headerlink" title="隐私计算概述"></a>隐私计算概述</h2><p>隐私计算本质上是在保护数据隐私的前提下，解决数据流通、数据应用等数据服务问题，在保证数据提供方不泄露原始数据的前提下，对数据进行计算、分析与建模的一系列信息技术，涵盖数据的产生、采集、存储、计算、应用、销毁等数据流转的全生命周期。说得更通俗一些，就是在保证数据安全的前提下，让数据可以自由流通或共享，消除数据孤岛问题，从而释放更大的数据价值，提升生产效率，推进产业创新。</p>
<h3 id="隐私计算技术路线"><a href="#隐私计算技术路线" class="headerlink" title="隐私计算技术路线"></a>隐私计算技术路线</h3><p>隐私计算的理念包括“数据可用不可见，数据不动模型动”，“数据可用不可见，数据不动模型动”。这门技术综合性强，涉及众多领域，包括数学，密码学，高性能计算，传统机器学习框架与算法。网络安全体系，隐私计算基础技术等等。</p>
<p>根据目前市场上隐私计算的主要相关技术特性，整体总结可分为三大方向与五大基座</p>
<p>三大方向：安全多方计算（MPC），可信执行环境（TEE），联邦学习（FL）</p>
<p>五大基座：</p>
<ul>
<li>基座一：隐私计算基础组件，包含同态加密、秘密分享、不经意传输、混淆电路等；</li>
<li>基座二：传统的安全机制，包含网络安全、主机安全、破解与反破解（横向联邦需要端侧计算的能力，需要安全防护）</li>
<li>基座三：机器学习能力，传统机器学习与深度学习的算法与框架能力</li>
<li>基座四：工程架构，分布式、高并发、大数据、实时计算等</li>
<li>基座五：数学与密码学知识，传统学科知识，例如数学、统计学习、密码学等；</li>
</ul>
]]></content>
      <categories>
        <category>隐私计算</category>
      </categories>
      <tags>
        <tag>隐私计算</tag>
      </tags>
  </entry>
  <entry>
    <title>隐私，安全及机器学习</title>
    <url>/posts/ecc00b19.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<span id="more"></span>
<h1 id="面向隐私保护的机器学习"><a href="#面向隐私保护的机器学习" class="headerlink" title="面向隐私保护的机器学习"></a>面向隐私保护的机器学习</h1><p>不断发生的数据泄露和隐私侵权事件使得社会公众更加认识到，在人工智能系统的构建与使用中，需要保护用户隐私和数据机密性，由此产生的系统便称作面向隐私保护的机器学习（Privacy-Preserving Machine Learning，PPML）系统。</p>
<p>我们对于信息安全有如下定义：由个人，团体或机构自行决定何时，如何以及在多大程度上将有关他们的信息传达给他人。</p>
<h1 id="面向隐私保护的机器学习与安全机器学习"><a href="#面向隐私保护的机器学习与安全机器学习" class="headerlink" title="面向隐私保护的机器学习与安全机器学习"></a>面向隐私保护的机器学习与安全机器学习</h1><p>我们首先要分清PPML和安全机器学习（Secure ML）的区别。这二者的区别在于它们被设计用来应用不同类型的安全威胁。在安全机器学习中，敌手被假设违反了机器学习系统的完整性和可用性。在PPML中，递手被假设违反了机器学习的隐私性和机密性</p>
<h2 id="完整性（Integrity）"><a href="#完整性（Integrity）" class="headerlink" title="完整性（Integrity）"></a>完整性（Integrity）</h2><p>对完整性的攻击可能导致机器学习系统会出现检测错误，例如可能会将入侵点检测为正常。</p>
<h2 id="可用性（Availability）"><a href="#可用性（Availability）" class="headerlink" title="可用性（Availability）"></a>可用性（Availability）</h2><p>对可用性的攻击可能导致系统会出现分类错误（假阴性和假阳性），即系统会变成不可用的。这是比完整性攻击更宽泛的一种攻击类型。</p>
<h2 id="机密性（Confidentiality）"><a href="#机密性（Confidentiality）" class="headerlink" title="机密性（Confidentiality）"></a>机密性（Confidentiality）</h2><p>对机密性的攻击可能会导致一些机器学习系统中的敏感信息（如训练数据或训练模型）出现错误。</p>
<h1 id="威胁与安全模型"><a href="#威胁与安全模型" class="headerlink" title="威胁与安全模型"></a>威胁与安全模型</h1><h2 id="隐私威胁模型"><a href="#隐私威胁模型" class="headerlink" title="隐私威胁模型"></a>隐私威胁模型</h2><p>在机器学习任务中，参与方会扮演三种不同的角色</p>
<ul>
<li>输入方：数据的原始拥有者</li>
<li>计算方：模型建立者和推理服务提供者</li>
<li>结果方：模型查询者和用户</li>
</ul>
<p>对机器学习系统的攻击可能在任何阶段发生，包括数据发布，模型训练和模型推理。在模型训练阶段发生的攻击叫做<strong>重构攻击</strong>，在数据发布阶段，发生<strong>模型反演攻击</strong>，<strong>成员推理攻击</strong>，<strong>特征推理攻击</strong>。</p>
<h3 id="重构攻击"><a href="#重构攻击" class="headerlink" title="重构攻击"></a>重构攻击</h3><p>在模型的训练期间抽取训练数据，或抽取训练数据的特征向量。</p>
<p>在集中式学习中，来自不同数据方的数据被上传至计算方，这使得数据很容易受到敌手的攻击。大型企业可能会从用户中收集原始数据，然而收集到的数据可能会用于其他目的或者是未经用户知情同意便传达给第三方。</p>
<p>在联邦学习中，每一个参与方使用自己的本地数据来训练机器学习模型，只将模型的权重更新和梯度信息与其他参与方共享。</p>
<p>然而，如果数据结构是已知的，梯度信息可能也会被利用，从而泄露关于训练数据的额外信息</p>
<p>为了抵御重构攻击，应当避免使用明文存储特征值的机器学习模型，例如<strong>支持向量机（SVM）</strong>和<strong>k-近邻（kNN）</strong>模型。</p>
<h3 id="模型反演攻击"><a href="#模型反演攻击" class="headerlink" title="模型反演攻击"></a>模型反演攻击</h3><p>从模型中抽取训练数据或训练数据的特征向量。</p>
<p>对于白盒访问，攻击方不需要存储特征向量便能获取模型的明文内容。对于黑盒访问，攻击方只能查询模型的数据和收集返回结果。</p>
<p>理论上，对于一个$N$维的线性模型，一个敌手可以通过$N+1$次查询来窃取整个模型的内容。该问题的形式化是从$(X,h_\theta(x))$中求解$\theta$；攻击方能通过“查询-回应”过程对来模拟出一个与原始模型相似的模型。</p>
<p>为了抵御模型反演攻击，应当向敌手暴露尽可能少的关于模型的信息，对模型的访问应当被限制为黑盒访问，模型输出同样应当受限。</p>
<h3 id="成员推理攻击"><a href="#成员推理攻击" class="headerlink" title="成员推理攻击"></a>成员推理攻击</h3><p>判断模型的训练集中是否包含特定的样本。</p>
<p>攻击者被假设为对模型拥有白盒访问权限或黑盒访问权限和一个样本，通过机器学习模型的输出试图推断此样本是否属于模型的训练集。攻击者的目标是获知给定样本是否在模型的训练集中。</p>
<h3 id="特征推理攻击"><a href="#特征推理攻击" class="headerlink" title="特征推理攻击"></a>特征推理攻击</h3><p>攻击者出于恶意目的，将数据去匿名化或锁定记录的拥有者。</p>
<p>在数据被发布之前，通过删除用户的个人可识别信息（也称为敏感特征）来实现匿名化，是保护用户隐私的一种常用方法。</p>
<h2 id="攻击者和安全模型"><a href="#攻击者和安全模型" class="headerlink" title="攻击者和安全模型"></a>攻击者和安全模型</h2><p>现阶段对于PPML技术，设计两种类型的敌手：</p>
<ul>
<li><strong>半诚实（Seni-honest）的敌手</strong>，在半诚实敌手模型中，敌手诚实地遵守协议，但也会试图从接收到的信息中学习更多除输出以外的信息。</li>
<li><strong>恶意（Malicious）的敌手</strong>，在恶意的敌手模型中，敌手不遵守协议，可以执行任意的攻击行为。</li>
</ul>
<p>在联邦学习中，诚实地遵守协议是对各方都有利的，恶意的行为也会损害敌手自身的利益。另外，在密码学中首先建立一个针对半诚实的敌手的安全协议是一种标准的方法，然后可以通过零知识证明对其进行加强，进而防御恶意的敌手的攻击。</p>
]]></content>
      <categories>
        <category>联邦学习</category>
      </categories>
      <tags>
        <tag>联邦学习</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读_RRNN</title>
    <url>/posts/47be9ab2.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>今天的论文题目是《Private and Reliable Neural Network Inference》</p>
<p>论文地址：<a href="https://dl.acm.org/doi/pdf/10.1145/3548606.3560709">https://dl.acm.org/doi/pdf/10.1145/3548606.3560709</a></p>
<span id="more"></span>
<h1 id="Private-and-Reliable-Neural-Network-Inference"><a href="#Private-and-Reliable-Neural-Network-Inference" class="headerlink" title="Private and Reliable Neural Network Inference"></a>Private and Reliable Neural Network Inference</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>可靠的神经网络（NNs）提供了重要的推理时可靠性保证，如公平性和稳健性。与此相辅相成的是，保护客户数据隐私的神经网络推理。迄今为止，这两个新兴领域在很大程度上是相互独立的，但它们的结合将变得越来越重要。在这项工作中，我们提出了第一个在可靠神经网络上实现隐私保护推理的系统。我们的关键思路是为随机平滑的核心算法构建模块设计高效的全同态加密（FHE）对等体，随机平滑是获得可靠模型的一种最先进的技术。FHE中缺乏所需的控制流使得这项任务具有挑战性，因为简单的解决方案会导致无法接受的运行时间。</p>
<p>我们利用这些构建模块在一个名为Phoenix的系统中实现具有稳健性和公平性保证的隐私保护神经网络推理。在实验中，我们证明Phoenix在不产生过多延迟的情况下实现了其目标。据我们所知，这是第一个将客户数据隐私与神经网络的可靠性保证领域联系起来的研究。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>鉴于数据隐私和可靠性这两个新兴方向的重要性，一个自然而然的问题出现了：在将机器学习模型过渡到隐私保护设置时，我们该如何保留可靠性保证？我们介绍一些例子来说明可靠性保证的必要性，并说明在保证客户端数据隐私的同时获得可靠性保证的重要性。</p>
<p>公平贷款资格。考虑金融机构在 MLaaS 环境中部署的 ML 系统，该系统可根据客户的财务记录自动预测贷款资格。最近的研究表明，如果不采取任何对策，这种模型可能会复制训练数据中的偏差并做出不公平的决定。例如，贷款申请可能会因为客户的敏感属性（如种族、年龄或性别）而被拒绝，也可能出现仅有细微差别的两对个人不公正地得到不同的结果。</p>
<p> 稳健的医学图像分析 考虑医疗图像分析问题，患者数据（核磁共振成像、X 光或 CT 扫描）被用于癌症诊断、视网膜病变检测、肺病分类等。ML 算法越来越多地用于此类应用，以降低令人担忧的高医疗错误率 。作为云服务部署的这种算法可被医疗提供者用于辅助诊断，甚至被患者用作第二意见。然而，据观察，这种算法对输入数据的轻微扰动特别不稳定，这种扰动可能是由于恶意行为，如患者篡改报告以获取补偿，或自然发生的测量误差。由于此类扰动可能导致不必要的成本或对患者健康产生负面影响，因此云服务提供稳健性保证符合双方利益。</p>
<p>提供可靠性保证的方法往往涉及额外的推理时间逻辑，这使得将计算提升到 FHE 以保护客户数据隐私的难度大大增加。Phoenix 首次在应对这一挑战方面迈出了重要一步，使可靠和隐私模型的部署成为可能。</p>
<h2 id="Phoenix"><a href="#Phoenix" class="headerlink" title="Phoenix"></a>Phoenix</h2><p>Phoenix利用随机平滑生成具有推理时间可靠性保证的 ML 模型。在 FHE 中实现这一点的关键是将现有的在 FHE 中评估神经网络的技术与新的 FHE 结合起来。</p>
<p><strong>Inference</strong> </p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>隐私集合求交</title>
    <url>/posts/d954c026.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>零知识证明</title>
    <url>/posts/63b33bfc.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="零知识证明"><a href="#零知识证明" class="headerlink" title="零知识证明"></a>零知识证明</h1><p>零知识证明（Zero Knowledge Proof）由S.Goldwasser、S.Micali 及 C.Rackoff于1985年在论文《The Knowledge Complexity of Interactive Proof Systems》（交互式证明系统中的知识复杂性）首次提出，是一种用于证明者在不泄露任何其他信息的情况下证明其掌握知识正确性的密码学协议。零知识证明目前有多种实现方式，如zk-SNARKS、zk-STARKS、PLONK以及Bulletproofs。每种方式在证明大小、证明者时间以及验证时间上都有自己的优缺点。</p>
<span id="more"></span>
<p>该协议的一方称为证明者（<strong>Prover</strong>），用$P$表示；另一方称为验证者（<strong>Verifier</strong>），用$V$表示。零知识证明指$P$试图使$V$相信某个论断是正确的，但却不向$V$泄露任何有用的信息，即$P$在论证的过程中$V$得不到任何有用的信息。零知识证明除了证明证明者论断的正确性外不泄露任何其他信息或知识。<br>零知识证明一般包含以下阶段：</p>
<ul>
<li><p>承诺（Commit）：证明者针对命题做出承诺，该承诺等待验证者提出挑战并进行验证。</p>
</li>
<li><p>挑战（Challenge）：验证者选择随机数（即上述例子中的行、列或格）对提出的承诺进行挑战。</p>
</li>
<li><p>回应挑战（Response）：证明者将收到的随机数结合给出的承诺（承诺不可修改），返回挑战的回应。</p>
</li>
<li><p>验证（Verify）：验证者验证挑战的回应是否正确，如果错误，则证明失败。</p>
</li>
</ul>
<p>证明者与验证者重复执行以上步骤，直到可以相信的概率达到验证者接受的条件，证明成功。<br>零知识证明具有以下特点：</p>
<p>完备性（Completeness）：如果证明者和验证者都是诚实的，并遵守证明过程的每一步进行正确的计算，则该证明一定会成功，验证者也一定能够接受证明者；<br>合理性（Soundness）：没有人能够假冒证明者，从而使这个证明成功；<br>零知识性（Zero-Knowledge）：证明过程执行完后，验证者只会得悉”证明者拥有这项知识”，而没有获得关于这项知识本身的任何信息。</p>
<h1 id="零知识证明的例子"><a href="#零知识证明的例子" class="headerlink" title="零知识证明的例子"></a>零知识证明的例子</h1><h2 id="山洞问题"><a href="#山洞问题" class="headerlink" title="山洞问题"></a>山洞问题</h2><p>如果要用一个概念直观地解释零知识证明如何证明用户拥有数据，可以想象一个山洞只有一个入口，洞里面有两条路（路径A和路径B），这两条路由一扇门连接，要说出密码才能通过这扇门。</p>
<p>Alice希望向Bob证明她知道开门的密码，但不想将密码透露给Bob。因此，Bob需要站在山洞外，Alice从其中一条路走进山洞，而Bob并不知道她选了哪条路。接着，Bob指定Alice从其中一条路回到山洞入口（注：这是随机选择的）。</p>
<p>如果Alice最初选择从路径A走到门口，但Bob让她从路径B回来，唯一的方法就是穿过那扇门，而穿过门必须知道密码。为了充分证明Alice真的知道门的密码，而不是运气好刚好选到了同一条路，这个过程可以反复重复好几次。</p>
<p>这一步操作完成后，Bob就可以非常确信Alice知道门的密码，与此同时Alice也不用向Bob透露密码是什么。虽然以上只是零知识证明机制简单的概念演示，但真正的零知识证明运用的是密码学，在不透露数据的情况下证明数据的存在。在这个山洞的示例中有一个输入数据，一条路径和一个输出数据。在计算机中也存在类似的系统和电路，传入数据，数据通过某些电路门之后再输出。零知识证明利用了类似这种电路机制来创建证明。</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307191911294.png" alt="image-20230719191136232"></p>
<h2 id="红绿色盲问题"><a href="#红绿色盲问题" class="headerlink" title="红绿色盲问题"></a>红绿色盲问题</h2><p>Q：有两颗形状、大小完全一样的球：一颗红球、一颗绿球，X XX是红绿色盲，Y YY能够向X XX证明这两颗球是一红一绿吗？</p>
<p>A：X左手拿着红球，右手拿着绿球，并在背后不让Y看到，进行交换（或者不交换）两只球<br>Y能够根据颜色精准判断X是否进行了交换<br>执行上述操作N次后，即能在X是色盲的情况下，Y仍能够向X证明能这两颗球是一红一绿</p>
<h2 id="数独问题"><a href="#数独问题" class="headerlink" title="数独问题"></a>数独问题</h2><p>假设$P$给出一道数独题目，由$V$来完成，但$V$过了很久都未能解出，他怀疑该数独题目没有解，要求$P$证明该题目有解。因此$P$希望在不告诉$V$答案相关的任何信息的情况下证明这道题有解且自己知道这个解。</p>
<p>1）承诺</p>
<p>$P$将答案的每个数字写在纸片上，并按照答案摆放(正面朝下)，题目中已有的数字正面朝上，这81个纸片的放置为$P$的“承诺”。</p>
<p>2）挑战</p>
<p>$V$不能直接将纸片翻转查看数字，但是$V$可以在行、列、格中任意指定一种验证方式。如图所示，$V$选择按照行的方式进行挑战。</p>
<p>3）挑战回应</p>
<p>$P$按照$V$选择行验证方式将桌面上每行的9张卡片装入一个袋子里，并且将纸片进行混淆后，把袋子交给$V$，作为挑战的回应。</p>
<p>4）验证</p>
<p>$V$打开纸袋可验证每个纸袋里的9张纸片刚好为1 − 9，即$P$在承诺阶段做出的承诺满足“每行1 − 9都出现且只出现一次”的要求，同时在一定程度上说明$P$做出的承诺很可能是一个合法的解（因为随意给出的数字不会满足这一要求，并且在承诺的时候并不知道$V$会选择行、列、格哪种验证方式）。</p>
<h2 id="三染色问题"><a href="#三染色问题" class="headerlink" title="三染色问题"></a>三染色问题</h2><p>如何用三种颜色染色一个地图，保证任意两个相邻的地区都是不同的颜色。</p>
<p>该问题可转变成<strong>连通图的顶点三染色问题</strong>，即不同城市（节点）之间修建了一些道路（边），是否存在一种染色方式，使得每个城市都用特定的三种颜色之一表示，并且任意有道路相连的两个城市都不是相同颜色。</p>
<p>思路：</p>
<p>1）Alice 先要对染过色的图进行一些变换，把颜色做一次全改，例如把所有的绿色变成橙色，把所有的黄色变成蓝色，把所有的红色变成粉色。然后 Alice 得到了一个新的染色答案，这时候她把新的图的每一个顶点都用纸片盖上，然后出示给 Bob 看。</p>
<p>2）Bob要随机挑选一条边，并由Alice揭开这条边两端的纸片，让Bob检查，Bob发现这两个顶点的颜色是不同的，那么Bob认为这次检验同构。</p>
<p>经过多次验证，可以证明Bob认为这个图满足三染色的要求。</p>
]]></content>
      <categories>
        <category>零知识证明</category>
      </categories>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>零知识证明zk-SNARKs</title>
    <url>/posts/6c3f0187.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>本文介绍经典零只是证明协议——zk-SNARKs</p>
<span id="more"></span>
<h1 id="zk-SNARK-算法简介"><a href="#zk-SNARK-算法简介" class="headerlink" title="zk-SNARK 算法简介"></a>zk-SNARK 算法简介</h1><p>zk-SNARK 是 <strong>zero-knowledge succint non-interactive arguments of knowledge</strong> 的简称，其中：</p>
<ul>
<li>Succint (简洁性) : 与实际计算的长度相比，生成的零知识证据消息很小。</li>
<li>Non-interactive (非交互性) : 几乎没有任何交互。对于算法而言，通常会有一个构建阶段，构建阶段完成之后，证明者（prover）只需向验证者（verifier）发送一个消息即可。SNARK还有一个“公开验证者”的特性，意味着<strong>任何人无需任何交互即可验证零知识证据</strong>，这一点对区块链很重要</li>
</ul>
]]></content>
      <categories>
        <category>零知识证明</category>
      </categories>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>非对称密码体制</title>
    <url>/posts/2933aa2b.html</url>
    <content><![CDATA[<h1 id="加密-非对称技术"><a href="#加密-非对称技术" class="headerlink" title="加密-非对称技术"></a>加密-非对称技术</h1><meta name="referrer" content="no-referrer">

<p>在公钥密码体制中，加密不用密钥，密钥仅在解密阶段使用，Diffie和Hellman描述了几个可能用来实现公钥密码的数学变换，它们称之为<strong>单向陷门函数</strong>。</p>
<p><strong>单向陷门函数</strong> 单向陷门函数 $f_t(x):D\rarr R$，是一个单向函数，即对任意的 $x\in D$，容易计算，而对几乎所有的 $x\in D$，求逆困难，但是如果知道陷门信息 $t$ ，则对所有的 $y \in R$，容易计算满足 $y=f_t(x)$ 的 $x\in D$。</p>
<span id="more"></span>
<h2 id="Diffie-Hellman密钥交换协议"><a href="#Diffie-Hellman密钥交换协议" class="headerlink" title="Diffie-Hellman密钥交换协议"></a>Diffie-Hellman密钥交换协议</h2><p>与对称密码体制相比，公钥密码体制的一个显著优点就是远程通信各方无需安全信道就能实现相互交换密钥。最早实现这一点的方案是Diffie-Hellman指数密钥交换协议。</p>
<p>首先，假设用户Alice和Bob约定有限域$F_q$和元素 $g\in F_p$，g生成一个群。为简化，我们考虑有限域 $F_p$，p为素数。协议如下：</p>
<p>协议：Diffie-Hellman密钥交换协议</p>
<p>共同输入 (p，g)：p为大素数，g为$F_q$ 的生成元。</p>
<p>输出：Alice和Bob共享$F_p$ 中的一个元素</p>
<ol>
<li><p>Alice选择 $a \in [1,p-1)$，计算 $g_a=g^a(modp)$，发送$g_a$给Bob</p>
</li>
<li><p>Bob选择 $b \in [1,p-1)$，计算 $g_b=g^b(modp)$，发送$g_b$给Alice</p>
</li>
<li><p>Alice计算 $k=g_b^a(modp)$</p>
</li>
<li>Bob计算 $k=g_b^a(modp)$</li>
</ol>
<p>可以不难看出，对于Alice和Bob都有: $k=g^{ab}modp$</p>
<h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>处于Alice和Bob通信中间的主动攻击者能够操纵这个协议的消息以达到成功的攻击，称为<strong>中间人攻击</strong>。</p>
<p>在对协议运行的攻击当中，Malice截获Alice发送给Bob的第一条消息$g_a$，并伪装成Alice向Bob发送消息。</p>
<p>Malice发送给Bob：$g_m(modp)$</p>
<p>Bob将按照协议的规则回复$g_b$给Malice，这个发送的数值再一次被Malice截获，现在M和B写上了一个密钥$g^{bm}(modp)$，而Bob以为这个密钥就是他和Alice所共享的密钥。</p>
<p><img src="https://gitee.com/jia-huaiyu/images/raw/master/202307181913599.png" alt="image-20230718191316520"></p>
<ol>
<li>Alice选择 $a \in [1,p-1)$，计算 $g_a=g^a(modp)$，发送$g_a$给Malice(‘“Bob”)</li>
</ol>
<p>1`. M(“Alice”)对某个 $m \in [1,p-1)$,计算$g_m=g^m(modp)$</p>
<ol>
<li>Bob选择 $b \in [1,p-1)$，计算 $g_b=g^b(modp)$，发送$g_b$给Malice(“Alice”)</li>
</ol>
<p>2`. M(“B”)向A发送：$g_m$</p>
<ol>
<li><p>Alice计算 $k_1=g_m^a(modp)$</p>
</li>
<li><p>Bob计算$k_2=g_m^b(modp)$</p>
</li>
</ol>
<h2 id="Diffie-Hellman问题和离散对数问题"><a href="#Diffie-Hellman问题和离散对数问题" class="headerlink" title="Diffie-Hellman问题和离散对数问题"></a>Diffie-Hellman问题和离散对数问题</h2><p>DH密钥交换协议中共享密钥的保密性就是已知$g_a,g_b$，计算$g^{ab}(modp)$的问题，这个问题被称为CDH。</p>
<p><strong>CDH</strong> 输入：$F_q,g,g^a,g^b$，输出：$g^{ab}$</p>
<p>如果CDH问题是容易的，则$g^{ab}(modp)$可以由$p,g,g_a,g_b$来计算得到，而这些参数是作为协议消息的一部分传送的。</p>
<p>进一步，CDH问题是基于<strong>离散对数问题（DL）</strong>的困难性。</p>
<p><strong>DL</strong> 输入： $F_q,g,h$，输出：唯一的整数a，满足$h=g^a$，我们用 $log_gh$来表示整数a</p>
<h2 id="RSA密码体制"><a href="#RSA密码体制" class="headerlink" title="RSA密码体制"></a>RSA密码体制</h2><p>RSA是最熟悉的公钥密码体制，是基于DH所想象的单向陷门函数的定义，而给出的第一个公钥密码的实现。</p>
<p><strong>RSA密码体制</strong></p>
<p><strong>密钥建立</strong></p>
<p>为了生成用户的基本参数，A执行以下步骤：</p>
<ol>
<li><p>随机选择两个素数p和q，$p\approx q$</p>
</li>
<li><p>计算N=pq</p>
</li>
<li><p>计算 $\phi (N) =(p-1)(q-1)$</p>
</li>
<li><p>随机选择整数 $e &lt; \phi(N)$，满足$gcd(e,\phi(N))=1$，并计算整数d满足$ed \equiv1 (mod\phi(N)$</p>
</li>
<li><p>公开公钥$(N,e)$，安全销毁$p,q,\phi(N)$，并保留$d$作为私钥</p>
</li>
</ol>
<p><strong>加密</strong></p>
<p>为了秘密的发送m给A，发送者B生成密文c如下：</p>
<p>$c \larr m^e(modN)$</p>
<p><strong>解密</strong></p>
<p>为了解密密文c，A计算 $m \larr c^d(modN)$</p>
<h2 id="公钥密码体制的分析"><a href="#公钥密码体制的分析" class="headerlink" title="公钥密码体制的分析"></a>公钥密码体制的分析</h2><p>密码体制的安全性是根据攻击来定义的，</p>
<p><strong>密码体制的主动攻击</strong></p>
<p>选择明文攻击（CPA） 攻击者选择明文消息并得到加密服务，产生相应的密文。攻击者的任务是用所得到的明-密文来降低目标密码体制的安全性。</p>
<p>选择密文攻击（CCA） 攻击者选择密文消息并得到解密服务，产生相应的明文。攻击者的任务是用所得到的明-密文对来降低目标密码体制的安全性。在解密服务停止后，即在得到目标密文之后，解密服务立即停止，如果攻击者能够从“目标密文”中得到保密明文的信息，则就说明攻击是成功的。</p>
<p>适用性选择密文攻击（CCA2） 这是一个CCA，而且除了对“目标密文”解密外，永远能够得到解密服务。</p>
<p>我们可以用以下情形来想象上述攻击类型：</p>
<ul>
<li>在CPA中，攻击者有一个加密盒子</li>
<li>在CCA中，攻击者可以有条件地使用解密盒子，在交给攻击者目标密文之前关闭解密盒子。</li>
<li>在CCA2中，在攻击者得到目标密文之前或之后，只要攻击者不把目标密文输入解密盒子，他就可以一直使用这个解密盒子。</li>
</ul>
<p>在所有的情况下，攻击者都不应该拥有相应的密钥。</p>
<h2 id="RSA问题"><a href="#RSA问题" class="headerlink" title="RSA问题"></a>RSA问题</h2><p>抵抗CPA，RSA的安全性基于计算密文$C$模合数$n^e$的困难性，这就是RSA问题。</p>
<p><strong>RSA问题</strong></p>
<p>输入：$n=pq$，pq均是素数，e满足$gcd(e,((p-1)(q-1)))=1$，c</p>
<p>输出：唯一的整数m，满足$m^e \equiv c (modN)$</p>
<p><strong>RSA假设</strong> RSA算法是一个PPT算法$A$，对于一个概率$\epsilon &gt; 0$满足：</p>
<p>$\epsilon = Prob[m\larr A(N,e,m^e(modN))]$</p>
<p>令$Ig$是一个RSA生成器，输入$1^k$，在k的多项式时间内输出（i）一个2k比特的模N=pq，其中p和q是两个不同的均匀分布的素数，长度均为k比特，（ii）$e\in Z^*_{(p-1)(q-1)}$</p>
<p>我们说满足RSA假设，如果对于所有充分大的k，对于k不可忽略的概率$\epsilon&gt;0$不存在$Ig(1^k)$满足所产生的RSA问题的求解算法。</p>
<p><strong>强RSA问题</strong> 对于某些奇数的加密指数$e&gt;1$，可能是根据算法的选择，已知这样的e，解RSA问题。普遍认为强RSA问题仍然是不可求解的，所以某些加密算法或者协议的安全性基于这个困难性。</p>
<h2 id="整数分解问题"><a href="#整数分解问题" class="headerlink" title="整数分解问题"></a>整数分解问题</h2><p>RSA问题的困难性依赖于整数分解问题的困难性</p>
<p><strong>整数分解问题（IF）</strong> 输入：N，奇合数，至少有两个素因子</p>
<p>输出：素数p满足$p|N$</p>
<p>一个能解决IF问题的算法就能解决RSA问题，因为Alice知道了大整数N的分解，就能先计算出$d\equiv e^{-1}mod(p-1)(q-1)$，从而可准确地对RSA密文解密。</p>
]]></content>
      <categories>
        <category>密码学基础</category>
      </categories>
      <tags>
        <tag>非对称密码</tag>
      </tags>
  </entry>
</search>
